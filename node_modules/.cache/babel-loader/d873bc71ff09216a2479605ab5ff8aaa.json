{"ast":null,"code":"import _classCallCheck from \"/Users/jimmy/Documents/Wizschool/wizlab_web2/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jimmy/Documents/Wizschool/wizlab_web2/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { WizSpritePrefix, EDITORMODE } from \"../../../Common/Util/Constant\";\nimport ApiLibrary from \"./apiLibrary\";\nimport ApiLibrary3d from \"../../Builder3D/Util/ApiLibrary3d\";\n\nvar escodegen = require(\"escodegen\");\n\nvar acorn = require(\"acorn\");\n\nvar escodegenDan = require(\"./escodegen\");\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser() {\n    _classCallCheck(this, Parser);\n\n    this.editorMode = undefined;\n    this.apiList = null;\n    this.apiList3d = null;\n  }\n\n  _createClass(Parser, [{\n    key: \"setApiLibrary\",\n    value: function setApiLibrary() {\n      if (this.editorMode === EDITORMODE.JAVASCRIPT_3D) {\n        if (!this.apiList3d) {\n          this.apiList3d = ApiLibrary3d.getAllFunctions().map(function (f) {\n            return f.caption.split(\"(\")[0];\n          });\n        }\n      } else {\n        if (!this.apiList) {\n          this.apiList = ApiLibrary.getAllFunctions().map(function (f) {\n            return f.caption.split(\"(\")[0];\n          });\n          this.apiList.push(\"server\");\n          this.apiList.push(\"onJoystick\");\n          this.apiList.push(\"onDpad\");\n        }\n      }\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(code, editorMode) {\n      this.editorMode = editorMode;\n      this.setApiLibrary();\n      return this.execParse(code);\n    }\n  }, {\n    key: \"execParse\",\n    value: function execParse(code) {\n      var comments = [],\n          tokens = [];\n      var ast = acorn.parse(code, {\n        // collect ranges for each node\n        ranges: true,\n        // collect comments in Esprima's format\n        // onComment: comments,\n        // collect token ranges\n        onToken: tokens,\n        ecmaVersion: 8\n      });\n      this.consume(ast); // attach comments using collected information\n\n      escodegen.attachComments(ast, comments, tokens); // generate code\n\n      return escodegen.generate(ast, {\n        comment: true\n      });\n    }\n  }, {\n    key: \"consume\",\n    value: function consume(node) {\n      if (!node) return;\n\n      if (Array.isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          this.consume(node[i]);\n        }\n      } else {\n        // console.log(node);\n        if (this[node.type]) {\n          this[node.type](node);\n        } else {// console.log(\"-> unhandled node\");\n        }\n      }\n    }\n    /*\n      Explore All Nodes to...\n        => add wizSprite prefix to api, server(keyword)\n            - CallExpression, Identifier\n        => asynchronize all functions\n            - FunctionDeclaration, FunctionExpression, ArrowFunctionExpression\n            * need to async 'all' functions?\n              this.promiseList = [\n                \"moveForward\",\n                \"moveX\",\n                \"moveY\",\n                \"moveTo\",\n                \"moveToSprite\",\n                \"moveToMousePointer\",\n                \"moveToRandom\",\n                \"input\",\n                \"wait\"\n              ];\n        => add wait(0) to block inifinite loop\n            - WhileStatement, DoWhileStatement\n    */\n    // ===== Node ==========\n\n  }, {\n    key: \"Program\",\n    value: function Program(node) {\n      this.consume(node.body);\n    }\n  }, {\n    key: \"Property\",\n    value: function Property(node) {\n      this.consume(node.value);\n    }\n  }, {\n    key: \"Identifier\",\n    value: function Identifier(node) {\n      if (node.name === \"server\" || node.name === \"global\" || node.name === \"socket\") {\n        node.name = \"\".concat(WizSpritePrefix, \".\").concat(node.name);\n      }\n    }\n  }, {\n    key: \"VariableDeclarator\",\n    value: function VariableDeclarator(node) {\n      this.consume(node.init);\n    }\n  }, {\n    key: \"FunctionDeclaration\",\n    value: function FunctionDeclaration(node) {\n      node.async = true;\n      this.consume(node.body);\n    }\n  }, {\n    key: \"VariableDeclaration\",\n    value: function VariableDeclaration(node) {\n      this.consume(node.declarations);\n    }\n  }, {\n    key: \"ExpressionStatement\",\n    value: function ExpressionStatement(node) {\n      this.consume(node.expression);\n    }\n  }, {\n    key: \"WhileStatement\",\n    value: function WhileStatement(node) {\n      node.body.body.push({\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"wait\"\n          },\n          arguments: [{\n            type: \"Literal\",\n            value: 0,\n            raw: \"0\"\n          }]\n        }\n      });\n      this.consume(node.test);\n      this.consume(node.body);\n    }\n  }, {\n    key: \"DoWhileStatement\",\n    value: function DoWhileStatement(node) {\n      node.body.body.push({\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"wait\"\n          },\n          arguments: [{\n            type: \"Literal\",\n            value: 0,\n            raw: \"0\"\n          }]\n        }\n      });\n      this.consume(node.body);\n      this.consume(node.test);\n    }\n  }, {\n    key: \"BlockStatement\",\n    value: function BlockStatement(node) {\n      this.consume(node.body);\n    }\n  }, {\n    key: \"ForStatement\",\n    value: function ForStatement(node) {\n      this.consume(node.init);\n      this.consume(node.test);\n      this.consume(node.update);\n      this.consume(node.body);\n    }\n  }, {\n    key: \"IfStatement\",\n    value: function IfStatement(node) {\n      this.consume(node.test);\n      this.consume(node.consequent);\n      this.consume(node.alternate);\n    }\n  }, {\n    key: \"ReturnStatement\",\n    value: function ReturnStatement(node) {\n      this.consume(node.argument);\n    }\n  }, {\n    key: \"SwitchStatement\",\n    value: function SwitchStatement(node) {\n      this.consume(node.discriminant);\n      this.consume(node.cases);\n    }\n  }, {\n    key: \"SwitchCase\",\n    value: function SwitchCase(node) {\n      this.consume(node.test);\n      this.consume(node.consequent);\n    }\n  }, {\n    key: \"CallExpression\",\n    value: function CallExpression(node) {\n      this.consume(node.arguments);\n\n      if (node.callee.type === \"Identifier\") {\n        var name = node.callee.name;\n\n        if (this.apiList && this.apiList.indexOf(name) > -1 || this.apiList3d && this.apiList3d.indexOf(name) > -1) {\n          node.callee.name = \"\".concat(WizSpritePrefix, \".\").concat(node.callee.name);\n        }\n\n        node.callee.name = \"await \".concat(node.callee.name);\n      }\n\n      if (node.callee.type === \"MemberExpression\") {\n        var findObject = function findObject(object) {\n          return object.object ? findObject(object.object) : object;\n        };\n\n        this.consume(node.callee);\n        var object = findObject(node.callee.object);\n\n        if (object.type === \"CallExpression\") {\n          this.consume(object);\n        } else if (object.type === \"ArrayExpression\") {\n          this.consume(object);\n        } else if (object.type === \"Identifier\") {\n          if (object.name === \"server\" || object.name === \"global\" || object.name === \"socket\") {\n            object.name = \"\".concat(WizSpritePrefix, \".\").concat(object.name);\n          }\n\n          object.name = \"await \".concat(object.name);\n        }\n      }\n    }\n  }, {\n    key: \"ObjectExpression\",\n    value: function ObjectExpression(node) {\n      this.consume(node.properties);\n    }\n  }, {\n    key: \"MemberExpression\",\n    value: function MemberExpression(node) {\n      this.consume(node.object);\n      this.consume(node.property);\n    }\n  }, {\n    key: \"AssignmentExpression\",\n    value: function AssignmentExpression(node) {\n      this.consume(node.left);\n      this.consume(node.right);\n    }\n  }, {\n    key: \"FunctionExpression\",\n    value: function FunctionExpression(node) {\n      node.async = true;\n      this.consume(node.body);\n    }\n  }, {\n    key: \"ArrowFunctionExpression\",\n    value: function ArrowFunctionExpression(node) {\n      node.async = true;\n      this.consume(node.body);\n    }\n  }, {\n    key: \"ArrayExpression\",\n    value: function ArrayExpression(node) {\n      this.consume(node.elements);\n    }\n  }, {\n    key: \"BinaryExpression\",\n    value: function BinaryExpression(node) {\n      this.consume(node.left);\n      this.consume(node.right);\n    }\n  }, {\n    key: \"UnaryExpression\",\n    value: function UnaryExpression(node) {\n      this.consume(node.argument);\n    }\n  }, {\n    key: \"LogicalExpression\",\n    value: function LogicalExpression(node) {\n      this.consume(node.left);\n      this.consume(node.right);\n    }\n  }, {\n    key: \"ConditionalExpression\",\n    value: function ConditionalExpression(node) {\n      this.consume(node.test);\n      this.consume(node.consequent);\n      this.consume(node.alternate);\n    } // ===== Node End ==========\n\n  }, {\n    key: \"parseForSort\",\n    value: function parseForSort(code) {\n      var comments = [],\n          tokens = [];\n      var ast = acorn.parse(code, {\n        // collect ranges for each node\n        ranges: true,\n        // collect comments in Esprima's format\n        onComment: comments,\n        // collect token ranges\n        onToken: tokens,\n        ecmaVersion: 8\n      });\n      var _ast = ast; // attach comments using collected information\n\n      escodegenDan.attachComments(_ast, comments, tokens); // generate code\n\n      return escodegenDan.generate(_ast, {\n        comment: true,\n        format: {\n          quotes: \"double\",\n          semicolons: false,\n          space: \"\"\n        }\n      });\n    }\n  }]);\n\n  return Parser;\n}();\n\nexport default new Parser();","map":{"version":3,"sources":["/Users/jimmy/Documents/Wizschool/wizlab_web2/src/Page/Builder/utils/parser.js"],"names":["WizSpritePrefix","EDITORMODE","ApiLibrary","ApiLibrary3d","escodegen","require","acorn","escodegenDan","Parser","editorMode","undefined","apiList","apiList3d","JAVASCRIPT_3D","getAllFunctions","map","f","caption","split","push","code","setApiLibrary","execParse","comments","tokens","ast","parse","ranges","onToken","ecmaVersion","consume","attachComments","generate","comment","node","Array","isArray","i","length","type","body","value","name","init","async","declarations","expression","callee","arguments","raw","test","update","consequent","alternate","argument","discriminant","cases","indexOf","findObject","object","properties","property","left","right","elements","onComment","_ast","format","quotes","semicolons","space"],"mappings":"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","sourcesContent":["import { WizSpritePrefix, EDITORMODE } from \"../../../Common/Util/Constant\";\nimport ApiLibrary from \"./apiLibrary\";\nimport ApiLibrary3d from \"../../Builder3D/Util/ApiLibrary3d\";\n\nconst escodegen = require(\"escodegen\");\nconst acorn = require(\"acorn\");\nconst escodegenDan = require(\"./escodegen\");\n\nclass Parser {\n  constructor() {\n    this.editorMode = undefined;\n    this.apiList = null;\n    this.apiList3d = null;\n  }\n  setApiLibrary() {\n    if (this.editorMode === EDITORMODE.JAVASCRIPT_3D) {\n      if (!this.apiList3d) {\n        this.apiList3d = ApiLibrary3d.getAllFunctions().map(f => {\n          return f.caption.split(\"(\")[0];\n        });\n      }\n    } else {\n      if (!this.apiList) {\n        this.apiList = ApiLibrary.getAllFunctions().map(f => {\n          return f.caption.split(\"(\")[0];\n        });\n        this.apiList.push(\"server\");\n        this.apiList.push(\"onJoystick\");\n        this.apiList.push(\"onDpad\");\n      }\n    }\n  }\n\n  parse(code, editorMode) {\n    this.editorMode = editorMode;\n    this.setApiLibrary();\n    return this.execParse(code);\n  }\n\n  execParse(code) {\n    let comments = [],\n      tokens = [];\n    let ast = acorn.parse(code, {\n      // collect ranges for each node\n      ranges: true,\n      // collect comments in Esprima's format\n      // onComment: comments,\n      // collect token ranges\n      onToken: tokens,\n      ecmaVersion: 8\n    });\n    this.consume(ast);\n    // attach comments using collected information\n    escodegen.attachComments(ast, comments, tokens);\n    // generate code\n    return escodegen.generate(ast, { comment: true });\n  }\n\n  consume(node) {\n    if (!node) return;\n\n    if (Array.isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        this.consume(node[i]);\n      }\n    } else {\n      // console.log(node);\n      if (this[node.type]) {\n        this[node.type](node);\n      } else {\n        // console.log(\"-> unhandled node\");\n      }\n    }\n  }\n\n  /*\n    Explore All Nodes to...\n      => add wizSprite prefix to api, server(keyword)\n          - CallExpression, Identifier\n      => asynchronize all functions\n          - FunctionDeclaration, FunctionExpression, ArrowFunctionExpression\n          * need to async 'all' functions?\n            this.promiseList = [\n              \"moveForward\",\n              \"moveX\",\n              \"moveY\",\n              \"moveTo\",\n              \"moveToSprite\",\n              \"moveToMousePointer\",\n              \"moveToRandom\",\n              \"input\",\n              \"wait\"\n            ];\n      => add wait(0) to block inifinite loop\n          - WhileStatement, DoWhileStatement\n  */\n  // ===== Node ==========\n  Program(node) {\n    this.consume(node.body);\n  }\n  Property(node) {\n    this.consume(node.value);\n  }\n  Identifier(node) {\n    if (\n      node.name === \"server\" ||\n      node.name === \"global\" ||\n      node.name === \"socket\"\n    ) {\n      node.name = `${WizSpritePrefix}.${node.name}`;\n    }\n  }\n\n  VariableDeclarator(node) {\n    this.consume(node.init);\n  }\n  FunctionDeclaration(node) {\n    node.async = true;\n    this.consume(node.body);\n  }\n  VariableDeclaration(node) {\n    this.consume(node.declarations);\n  }\n\n  ExpressionStatement(node) {\n    this.consume(node.expression);\n  }\n  WhileStatement(node) {\n    node.body.body.push({\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"wait\"\n        },\n        arguments: [\n          {\n            type: \"Literal\",\n            value: 0,\n            raw: \"0\"\n          }\n        ]\n      }\n    });\n    this.consume(node.test);\n    this.consume(node.body);\n  }\n  DoWhileStatement(node) {\n    node.body.body.push({\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"wait\"\n        },\n        arguments: [\n          {\n            type: \"Literal\",\n            value: 0,\n            raw: \"0\"\n          }\n        ]\n      }\n    });\n    this.consume(node.body);\n    this.consume(node.test);\n  }\n  BlockStatement(node) {\n    this.consume(node.body);\n  }\n  ForStatement(node) {\n    this.consume(node.init);\n    this.consume(node.test);\n    this.consume(node.update);\n    this.consume(node.body);\n  }\n  IfStatement(node) {\n    this.consume(node.test);\n    this.consume(node.consequent);\n    this.consume(node.alternate);\n  }\n  ReturnStatement(node) {\n    this.consume(node.argument);\n  }\n  SwitchStatement(node) {\n    this.consume(node.discriminant);\n    this.consume(node.cases);\n  }\n  SwitchCase(node) {\n    this.consume(node.test);\n    this.consume(node.consequent);\n  }\n\n  CallExpression(node) {\n    this.consume(node.arguments);\n    if (node.callee.type === \"Identifier\") {\n      const name = node.callee.name;\n      if (\n        (this.apiList && this.apiList.indexOf(name) > -1) \n        || (this.apiList3d && this.apiList3d.indexOf(name) > -1)\n      ) {\n        node.callee.name = `${WizSpritePrefix}.${node.callee.name}`;\n      }\n      node.callee.name = `await ${node.callee.name}`;\n    }\n    if (node.callee.type === \"MemberExpression\") {\n      this.consume(node.callee);\n      function findObject(object) {\n        return object.object ? findObject(object.object) : object;\n      }\n      const object = findObject(node.callee.object);\n      if (object.type === \"CallExpression\") {\n        this.consume(object);\n      } else if (object.type === \"ArrayExpression\") {\n        this.consume(object);\n      } else if (object.type === \"Identifier\") {\n        if (\n          object.name === \"server\" ||\n          object.name === \"global\" ||\n          object.name === \"socket\"\n        ) {\n          object.name = `${WizSpritePrefix}.${object.name}`;\n        }\n        object.name = `await ${object.name}`;\n      }\n    }\n  }\n  ObjectExpression(node) {\n    this.consume(node.properties);\n  }\n  MemberExpression(node) {\n    this.consume(node.object);\n    this.consume(node.property);\n  }\n  AssignmentExpression(node) {\n    this.consume(node.left);\n    this.consume(node.right);\n  }\n  FunctionExpression(node) {\n    node.async = true;\n    this.consume(node.body);\n  }\n  ArrowFunctionExpression(node) {\n    node.async = true;\n    this.consume(node.body);\n  }\n  ArrayExpression(node) {\n    this.consume(node.elements);\n  }\n  BinaryExpression(node) {\n    this.consume(node.left);\n    this.consume(node.right);\n  }\n  UnaryExpression(node) {\n    this.consume(node.argument);\n  }\n  LogicalExpression(node) {\n    this.consume(node.left);\n    this.consume(node.right);\n  }\n  ConditionalExpression(node) {\n    this.consume(node.test);\n    this.consume(node.consequent);\n    this.consume(node.alternate);\n  }\n  // ===== Node End ==========\n\n  parseForSort(code) {\n    let comments = [],\n      tokens = [];\n    let ast = acorn.parse(code, {\n      // collect ranges for each node\n      ranges: true,\n      // collect comments in Esprima's format\n      onComment: comments,\n      // collect token ranges\n      onToken: tokens,\n      ecmaVersion: 8\n    });\n\n    const _ast = ast;\n\n    // attach comments using collected information\n    escodegenDan.attachComments(_ast, comments, tokens);\n    // generate code\n    return escodegenDan.generate(_ast, {\n      comment: true,\n      format: {\n        quotes: \"double\",\n        semicolons: false,\n        space: \"\"\n      }\n    });\n  }\n}\n\nexport default new Parser();\n"]},"metadata":{},"sourceType":"module"}