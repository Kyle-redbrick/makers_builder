{"ast":null,"code":"import lamejs from \"lamejs\";\nexport function encode(audioBuffer, start, end) {\n  var buffer = cropBuffer(audioBuffer, start, end);\n  var wav = bufferToWav(buffer);\n  var mp3Blob = wavToMp3(wav, 128);\n  return mp3Blob;\n}\n\nfunction cropBuffer(buffer, start, end) {\n  var audioContext = new AudioContext();\n  var computedStart = buffer.length * start / buffer.duration;\n  var computedEnd = buffer.length * end / buffer.duration;\n  var newBuffer = audioContext.createBuffer(buffer.numberOfChannels, computedEnd - computedStart, buffer.sampleRate);\n\n  for (var i = 0; i < buffer.numberOfChannels; i++) {\n    newBuffer.copyToChannel(buffer.getChannelData(i).slice(computedStart, computedEnd), i);\n  }\n\n  return newBuffer;\n}\n\nfunction bufferToWav(buffer) {\n  var numOfChan = buffer.numberOfChannels;\n  var length = buffer.length * numOfChan * 2 + 44;\n  var arrayBuffer = new ArrayBuffer(length);\n  var dataView = new DataView(arrayBuffer);\n  var channels = [];\n  var offset = 0;\n  var pos = 0;\n  var sample;\n  setUint32(0x46464952); // \"RIFF\"\n\n  setUint32(length - 8); // file length - 8\n\n  setUint32(0x45564157); // \"WAVE\"\n\n  setUint32(0x20746d66); // \"fmt \" chunk\n\n  setUint32(16); // length = 16\n\n  setUint16(1); // PCM (uncompressed)\n\n  setUint16(numOfChan);\n  setUint32(buffer.sampleRate);\n  setUint32(buffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n\n  setUint16(numOfChan * 2); // block-align\n\n  setUint16(16); // 16-bit\n\n  setUint32(0x61746164); // \"data\" - chunk\n\n  setUint32(length - pos - 4); // chunk length\n\n  for (var i = 0; i < buffer.numberOfChannels; i++) {\n    channels.push(buffer.getChannelData(i));\n  }\n\n  while (pos < length) {\n    for (var _i = 0; _i < numOfChan; _i++) {\n      // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[_i][offset])); // clamp\n\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n\n      dataView.setInt16(pos, sample, true); // write 16-bit sample\n\n      pos += 2;\n    }\n\n    offset++; // next source sample\n  }\n\n  var header = lamejs.WavHeader.readHeader(new DataView(arrayBuffer));\n  var data = new Int16Array(arrayBuffer, header.dataOffset, header.dataLen / 2);\n\n  if (header.channels === 2) {\n    //STEREO\n    var leftData = [];\n    var rightData = [];\n\n    for (var _i2 = 0; _i2 < data.length; _i2 += 2) {\n      leftData.push(data[_i2]);\n      rightData.push(data[_i2 + 1]);\n    }\n\n    var leftSamples = new Int16Array(leftData);\n    var rightSamples = new Int16Array(rightData);\n    return {\n      header: header,\n      leftSamples: leftSamples,\n      rightSamples: rightSamples\n    };\n  } else if (header.channels === 1) {\n    //MONO\n    return {\n      header: header,\n      leftSamples: data\n    };\n  }\n\n  function setUint16(data) {\n    dataView.setUint16(pos, data, true);\n    pos += 2;\n  }\n\n  function setUint32(data) {\n    dataView.setUint32(pos, data, true);\n    pos += 4;\n  }\n}\n\nfunction wavToMp3(wav, kbps) {\n  var header = wav.header,\n      leftSamples = wav.leftSamples,\n      _wav$rightSamples = wav.rightSamples,\n      rightSamples = _wav$rightSamples === void 0 ? null : _wav$rightSamples;\n  var buffer = [];\n  var encoder = new lamejs.Mp3Encoder(header.channels, header.sampleRate, kbps);\n  var samplesPerFrame = 1152;\n  var remaining = leftSamples.length;\n  var mp3buf;\n\n  for (var i = 0; remaining >= samplesPerFrame; i += samplesPerFrame) {\n    if (!rightSamples) {\n      var mono = leftSamples.subarray(i, i + samplesPerFrame);\n      mp3buf = encoder.encodeBuffer(mono);\n    } else {\n      var leftChunk = leftSamples.subarray(i, i + samplesPerFrame);\n      var rightChunk = rightSamples.subarray(i, i + samplesPerFrame);\n      mp3buf = encoder.encodeBuffer(leftChunk, rightChunk);\n    }\n\n    if (mp3buf.length > 0) {\n      buffer.push(mp3buf); //new Int8Array(mp3buf));\n    }\n\n    remaining -= samplesPerFrame;\n  }\n\n  var d = encoder.flush();\n\n  if (d.length > 0) {\n    buffer.push(new Int8Array(d));\n  }\n\n  var blob = new Blob(buffer, {\n    type: \"audio/mp3\"\n  });\n  return blob;\n}","map":{"version":3,"sources":["/Users/jimmy/Documents/Wizschool/wizlab_web2/src/Page/Builder/utils/audioUtil.js"],"names":["lamejs","encode","audioBuffer","start","end","buffer","cropBuffer","wav","bufferToWav","mp3Blob","wavToMp3","audioContext","AudioContext","computedStart","length","duration","computedEnd","newBuffer","createBuffer","numberOfChannels","sampleRate","i","copyToChannel","getChannelData","slice","numOfChan","arrayBuffer","ArrayBuffer","dataView","DataView","channels","offset","pos","sample","setUint32","setUint16","push","Math","max","min","setInt16","header","WavHeader","readHeader","data","Int16Array","dataOffset","dataLen","leftData","rightData","leftSamples","rightSamples","kbps","encoder","Mp3Encoder","samplesPerFrame","remaining","mp3buf","mono","subarray","encodeBuffer","leftChunk","rightChunk","d","flush","Int8Array","blob","Blob","type"],"mappings":"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","sourcesContent":["import lamejs from \"lamejs\";\n\nexport function encode(audioBuffer, start, end) {\n  const buffer = cropBuffer(audioBuffer, start, end);\n  const wav = bufferToWav(buffer);\n  const mp3Blob = wavToMp3(wav, 128);\n\n  return mp3Blob;\n}\n\nfunction cropBuffer(buffer, start, end) {\n  const audioContext = new AudioContext();\n  const computedStart = buffer.length * start / buffer.duration;\n  const computedEnd = buffer.length * end / buffer.duration;\n\n  const newBuffer = audioContext.createBuffer(\n    buffer.numberOfChannels,\n    computedEnd - computedStart,\n    buffer.sampleRate\n  );\n\n  for (var i = 0; i < buffer.numberOfChannels; i++) {\n    newBuffer.copyToChannel(buffer.getChannelData(i).slice(computedStart, computedEnd), i);\n  }\n\n  return newBuffer;\n}\n\nfunction bufferToWav(buffer) {\n  const numOfChan = buffer.numberOfChannels;\n  const length = buffer.length * numOfChan * 2 + 44;\n  const arrayBuffer = new ArrayBuffer(length);\n  const dataView = new DataView(arrayBuffer);\n  const channels = [];\n  let offset = 0;\n  let pos = 0;\n  let sample;\n  setUint32(0x46464952); // \"RIFF\"\n  setUint32(length - 8); // file length - 8\n  setUint32(0x45564157); // \"WAVE\"\n  setUint32(0x20746d66); // \"fmt \" chunk\n  setUint32(16); // length = 16\n  setUint16(1); // PCM (uncompressed)\n  setUint16(numOfChan);\n  setUint32(buffer.sampleRate);\n  setUint32(buffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n  setUint16(numOfChan * 2); // block-align\n  setUint16(16); // 16-bit\n  setUint32(0x61746164); // \"data\" - chunk\n  setUint32(length - pos - 4); // chunk length\n\n  for(let i = 0; i < buffer.numberOfChannels; i++){\n    channels.push(buffer.getChannelData(i));\n  }\n\n  while(pos < length) {\n    for(let i = 0; i < numOfChan; i++) {\n      // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n      dataView.setInt16(pos, sample, true); // write 16-bit sample\n      pos += 2;\n    }\n    offset++; // next source sample\n  }\n\n  const header = lamejs.WavHeader.readHeader(new DataView(arrayBuffer));\n  const data = new Int16Array(arrayBuffer, header.dataOffset, header.dataLen / 2);\n\n  if (header.channels === 2){\n    //STEREO\n    const leftData = [];\n    const rightData = [];\n    for (let i = 0; i < data.length; i += 2) {\n      leftData.push(data[i]);\n      rightData.push(data[i + 1]);\n    }\n    const leftSamples = new Int16Array(leftData);\n    const rightSamples = new Int16Array(rightData);\n    return { header, leftSamples, rightSamples }\n  } else if (header.channels === 1){\n    //MONO\n    return { header, leftSamples: data };\n  }\n  \n\n  function setUint16(data) {\n    dataView.setUint16(pos, data, true);\n    pos += 2;\n  }\n\n  function setUint32(data) {\n    dataView.setUint32(pos, data, true);\n    pos += 4;\n  }\n}\n\nfunction wavToMp3(wav, kbps) {\n  const { header, leftSamples, rightSamples = null } = wav;\n  const buffer = [];\n  const encoder = new lamejs.Mp3Encoder(header.channels, header.sampleRate, kbps);\n  const samplesPerFrame = 1152;\n  let remaining = leftSamples.length;\n  let mp3buf;\n\n  for (let i = 0; remaining >= samplesPerFrame; i += samplesPerFrame) {\n    if (!rightSamples) {\n      const mono = leftSamples.subarray(i, i + samplesPerFrame);\n      mp3buf = encoder.encodeBuffer(mono);\n    }\n    else {\n      const leftChunk = leftSamples.subarray(i, i + samplesPerFrame);\n      const rightChunk = rightSamples.subarray(i, i + samplesPerFrame);\n      mp3buf = encoder.encodeBuffer(leftChunk, rightChunk);\n    }\n    if (mp3buf.length > 0) {\n      buffer.push(mp3buf);//new Int8Array(mp3buf));\n    }\n    remaining -= samplesPerFrame;\n  }\n  \n  const d = encoder.flush();\n  if (d.length > 0) {\n    buffer.push(new Int8Array(d));\n  }\n\n  const blob = new Blob(buffer, { type: \"audio/mp3\" });\n  return blob;\n}"]},"metadata":{},"sourceType":"module"}