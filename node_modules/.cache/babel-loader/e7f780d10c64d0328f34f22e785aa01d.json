{"ast":null,"code":"/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*global exports:true, require:true, global:true*/\n(function () {\n  // \"use strict\";\n  var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;\n  estraverse = require(\"estraverse\");\n  esutils = require(\"esutils\");\n  Syntax = estraverse.Syntax; // Generation is done by generateExpression.\n\n  function isExpression(node) {\n    return CodeGenerator.Expression.hasOwnProperty(node.type);\n  } // Generation is done by generateStatement.\n\n\n  function isStatement(node) {\n    return CodeGenerator.Statement.hasOwnProperty(node.type);\n  }\n\n  Precedence = {\n    Sequence: 0,\n    Yield: 1,\n    Assignment: 1,\n    Conditional: 2,\n    ArrowFunction: 2,\n    LogicalOR: 3,\n    LogicalAND: 4,\n    BitwiseOR: 5,\n    BitwiseXOR: 6,\n    BitwiseAND: 7,\n    Equality: 8,\n    Relational: 9,\n    BitwiseSHIFT: 10,\n    Additive: 11,\n    Multiplicative: 12,\n    Exponentiation: 13,\n    Await: 14,\n    Unary: 14,\n    Postfix: 15,\n    Call: 16,\n    New: 17,\n    TaggedTemplate: 18,\n    Member: 19,\n    Primary: 20\n  };\n  BinaryPrecedence = {\n    \"||\": Precedence.LogicalOR,\n    \"&&\": Precedence.LogicalAND,\n    \"|\": Precedence.BitwiseOR,\n    \"^\": Precedence.BitwiseXOR,\n    \"&\": Precedence.BitwiseAND,\n    \"==\": Precedence.Equality,\n    \"!=\": Precedence.Equality,\n    \"===\": Precedence.Equality,\n    \"!==\": Precedence.Equality,\n    is: Precedence.Equality,\n    isnt: Precedence.Equality,\n    \"<\": Precedence.Relational,\n    \">\": Precedence.Relational,\n    \"<=\": Precedence.Relational,\n    \">=\": Precedence.Relational,\n    in: Precedence.Relational,\n    instanceof: Precedence.Relational,\n    \"<<\": Precedence.BitwiseSHIFT,\n    \">>\": Precedence.BitwiseSHIFT,\n    \">>>\": Precedence.BitwiseSHIFT,\n    \"+\": Precedence.Additive,\n    \"-\": Precedence.Additive,\n    \"*\": Precedence.Multiplicative,\n    \"%\": Precedence.Multiplicative,\n    \"/\": Precedence.Multiplicative,\n    \"**\": Precedence.Exponentiation\n  }; //Flags\n\n  var F_ALLOW_IN = 1,\n      F_ALLOW_CALL = 1 << 1,\n      F_ALLOW_UNPARATH_NEW = 1 << 2,\n      F_FUNC_BODY = 1 << 3,\n      F_DIRECTIVE_CTX = 1 << 4,\n      F_SEMICOLON_OPT = 1 << 5; //Expression flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_ALLOW_CALL\n  // F_ALLOW_UNPARATH_NEW\n\n  var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n      E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n      E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n      E_TFF = F_ALLOW_IN,\n      E_FFT = F_ALLOW_UNPARATH_NEW,\n      E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW; //Statement flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_FUNC_BODY\n  // F_DIRECTIVE_CTX\n  // F_SEMICOLON_OPT\n\n  var S_TFFF = F_ALLOW_IN,\n      S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n      S_FFFF = 0x00,\n      S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n      S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n\n  function getDefaultOptions() {\n    // default options\n    return {\n      indent: null,\n      base: null,\n      parse: null,\n      comment: false,\n      format: {\n        indent: {\n          style: \"    \",\n          base: 0,\n          adjustMultilineComment: false\n        },\n        newline: \"\\n\",\n        space: \" \",\n        json: false,\n        renumber: false,\n        hexadecimal: false,\n        quotes: \"single\",\n        escapeless: false,\n        compact: false,\n        parentheses: true,\n        semicolons: true,\n        safeConcatenation: false,\n        preserveBlankLines: false\n      },\n      moz: {\n        comprehensionExpressionStartsWithAssignment: false,\n        starlessGenerator: false\n      },\n      sourceMap: null,\n      sourceMapRoot: null,\n      sourceMapWithCode: false,\n      directive: false,\n      raw: true,\n      verbatim: null,\n      sourceCode: null\n    };\n  }\n\n  function stringRepeat(str, num) {\n    var result = \"\";\n\n    for (num |= 0; num > 0; num >>>= 1, str += str) {\n      if (num & 1) {\n        result += str;\n      }\n    }\n\n    return result;\n  }\n\n  function hasLineTerminator(str) {\n    return /[\\r\\n]/g.test(str);\n  }\n\n  function endsWithLineTerminator(str) {\n    var len = str.length;\n    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n  }\n\n  function merge(target, override) {\n    var key;\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        target[key] = override[key];\n      }\n    }\n\n    return target;\n  }\n\n  function updateDeeply(target, override) {\n    var key, val;\n\n    function isHashObject(target) {\n      return typeof target === \"object\" && target instanceof Object && !(target instanceof RegExp);\n    }\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        val = override[key];\n\n        if (isHashObject(val)) {\n          if (isHashObject(target[key])) {\n            updateDeeply(target[key], val);\n          } else {\n            target[key] = updateDeeply({}, val);\n          }\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    return target;\n  }\n\n  function generateNumber(value) {\n    var result, point, temp, exponent, pos; // eslint-disable-next-line\n\n    if (value !== value) {\n      throw new Error(\"Numeric literal whose value is NaN\");\n    }\n\n    if (value < 0 || value === 0 && 1 / value < 0) {\n      throw new Error(\"Numeric literal whose value is negative\");\n    }\n\n    if (value === 1 / 0) {\n      return json ? \"null\" : renumber ? \"1e400\" : \"1e+400\";\n    }\n\n    result = \"\" + value;\n\n    if (!renumber || result.length < 3) {\n      return result;\n    }\n\n    point = result.indexOf(\".\");\n\n    if (!json && result.charCodeAt(0) === 0x30\n    /* 0 */\n    && point === 1) {\n      point = 0;\n      result = result.slice(1);\n    }\n\n    temp = result;\n    result = result.replace(\"e+\", \"e\");\n    exponent = 0;\n\n    if ((pos = temp.indexOf(\"e\")) > 0) {\n      exponent = +temp.slice(pos + 1);\n      temp = temp.slice(0, pos);\n    }\n\n    if (point >= 0) {\n      exponent -= temp.length - point - 1;\n      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + \"\";\n    }\n\n    pos = 0;\n\n    while (temp.charCodeAt(temp.length + pos - 1) === 0x30\n    /* 0 */\n    ) {\n      --pos;\n    }\n\n    if (pos !== 0) {\n      exponent -= pos;\n      temp = temp.slice(0, pos);\n    }\n\n    if (exponent !== 0) {\n      temp += \"e\" + exponent;\n    }\n\n    if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = \"0x\" + value.toString(16)).length < result.length) && +temp === value) {\n      result = temp;\n    }\n\n    return result;\n  } // Generate valid RegExp expression.\n  // This function is based on https://github.com/Constellation/iv Engine\n\n\n  function escapeRegExpCharacter(ch, previousIsBackslash) {\n    // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n    if ((ch & ~1) === 0x2028) {\n      return (previousIsBackslash ? \"u\" : \"\\\\u\") + (ch === 0x2028 ? \"2028\" : \"2029\");\n    } else if (ch === 10 || ch === 13) {\n      // \\n, \\r\n      return (previousIsBackslash ? \"\" : \"\\\\\") + (ch === 10 ? \"n\" : \"r\");\n    }\n\n    return String.fromCharCode(ch);\n  }\n\n  function generateRegExp(reg) {\n    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n    result = reg.toString();\n\n    if (reg.source) {\n      // extract flag from toString result\n      match = result.match(/\\/([^/]*)$/);\n\n      if (!match) {\n        return result;\n      }\n\n      flags = match[1];\n      result = \"\";\n      characterInBrack = false;\n      previousIsBackslash = false;\n\n      for (i = 0, iz = reg.source.length; i < iz; ++i) {\n        ch = reg.source.charCodeAt(i);\n\n        if (!previousIsBackslash) {\n          if (characterInBrack) {\n            if (ch === 93) {\n              // ]\n              characterInBrack = false;\n            }\n          } else {\n            if (ch === 47) {\n              // /\n              result += \"\\\\\";\n            } else if (ch === 91) {\n              // [\n              characterInBrack = true;\n            }\n          }\n\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          previousIsBackslash = ch === 92; // \\\n        } else {\n          // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n          result += escapeRegExpCharacter(ch, previousIsBackslash); // prevent like /\\\\[/]/\n\n          previousIsBackslash = false;\n        }\n      }\n\n      return \"/\" + result + \"/\" + flags;\n    }\n\n    return result;\n  }\n\n  function escapeAllowedCharacter(code, next) {\n    var hex;\n\n    if (code === 0x08\n    /* \\b */\n    ) {\n      return \"\\\\b\";\n    }\n\n    if (code === 0x0c\n    /* \\f */\n    ) {\n      return \"\\\\f\";\n    }\n\n    if (code === 0x09\n    /* \\t */\n    ) {\n      return \"\\\\t\";\n    }\n\n    hex = code.toString(16).toUpperCase();\n\n    if (json || code > 0xff) {\n      return \"\\\\u\" + \"0000\".slice(hex.length) + hex;\n    } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n      return \"\\\\0\";\n    } else if (code === 0x000b\n    /* \\v */\n    ) {\n      // '\\v'\n      return \"\\\\x0B\";\n    } else {\n      return \"\\\\x\" + \"00\".slice(hex.length) + hex;\n    }\n  }\n\n  function escapeDisallowedCharacter(code) {\n    if (code === 0x5c\n    /* \\ */\n    ) {\n      return \"\\\\\\\\\";\n    }\n\n    if (code === 0x0a\n    /* \\n */\n    ) {\n      return \"\\\\n\";\n    }\n\n    if (code === 0x0d\n    /* \\r */\n    ) {\n      return \"\\\\r\";\n    }\n\n    if (code === 0x2028) {\n      return \"\\\\u2028\";\n    }\n\n    if (code === 0x2029) {\n      return \"\\\\u2029\";\n    }\n\n    throw new Error(\"Incorrectly classified character\");\n  }\n\n  function escapeDirective(str) {\n    var i, iz, code, quote;\n    quote = quotes === \"double\" ? '\"' : \"'\";\n\n    for (i = 0, iz = str.length; i < iz; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      ) {\n        quote = '\"';\n        break;\n      } else if (code === 0x22\n      /* \" */\n      ) {\n        quote = \"'\";\n        break;\n      } else if (code === 0x5c\n      /* \\ */\n      ) {\n        ++i;\n      }\n    }\n\n    return quote + str + quote;\n  }\n\n  function escapeString(str) {\n    var result = \"\",\n        i,\n        len,\n        code,\n        singleQuotes = 0,\n        doubleQuotes = 0,\n        single,\n        quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      ) {\n        ++singleQuotes;\n      } else if (code === 0x22\n      /* \" */\n      ) {\n        ++doubleQuotes;\n      } else if (code === 0x2f\n      /* / */\n      && json) {\n        result += \"\\\\\";\n      } else if (esutils.code.isLineTerminator(code) || code === 0x5c\n      /* \\ */\n      ) {\n        result += escapeDisallowedCharacter(code);\n        continue;\n      } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20\n      /* SP */\n      || !json && !escapeless && (code < 0x20\n      /* SP */\n      || code > 0x7e))\n      /* ~ */\n      ) {\n        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n        continue;\n      }\n\n      result += String.fromCharCode(code);\n    }\n\n    single = !(quotes === \"double\" || quotes === \"auto\" && doubleQuotes < singleQuotes);\n    quote = single ? \"'\" : '\"';\n\n    if (!(single ? singleQuotes : doubleQuotes)) {\n      return quote + result + quote;\n    }\n\n    str = result;\n    result = quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      && single || code === 0x22\n      /* \" */\n      && !single) {\n        result += \"\\\\\";\n      }\n\n      result += String.fromCharCode(code);\n    }\n\n    return result + quote;\n  }\n  /**\n   * flatten an array to a string, where the array can contain\n   * either strings or nested arrays\n   */\n\n\n  function flattenToString(arr) {\n    var i,\n        iz,\n        elem,\n        result = \"\";\n\n    for (i = 0, iz = arr.length; i < iz; ++i) {\n      elem = arr[i];\n      result += Array.isArray(elem) ? flattenToString(elem) : elem;\n    }\n\n    return result;\n  }\n  /**\n   * convert generated to a SourceNode when source maps are enabled.\n   */\n\n\n  function toSourceNodeWhenNeeded(generated, node) {\n    if (!sourceMap) {\n      // with no source maps, generated is either an\n      // array or a string.  if an array, flatten it.\n      // if a string, just return it\n      if (Array.isArray(generated)) {\n        return flattenToString(generated);\n      } else {\n        return generated;\n      }\n    }\n\n    if (node == null) {\n      if (generated instanceof SourceNode) {\n        return generated;\n      } else {\n        node = {};\n      }\n    }\n\n    if (node.loc == null) {\n      return new SourceNode(null, null, sourceMap, generated, node.name || null);\n    }\n\n    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);\n  }\n\n  function noEmptySpace() {\n    return space ? space : \" \";\n  }\n\n  function join(left, right) {\n    var leftSource, rightSource, leftCharCode, rightCharCode;\n    leftSource = toSourceNodeWhenNeeded(left).toString();\n\n    if (leftSource.length === 0) {\n      return [right];\n    }\n\n    rightSource = toSourceNodeWhenNeeded(right).toString();\n\n    if (rightSource.length === 0) {\n      return [left];\n    }\n\n    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n    rightCharCode = rightSource.charCodeAt(0);\n\n    if ((leftCharCode === 0x2b\n    /* + */\n    || leftCharCode === 0x2d\n    /* - */\n    ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2f\n    /* / */\n    && rightCharCode === 0x69\n    /* i */\n    ) {\n      // infix word operators all start with `i`\n      return [left, noEmptySpace(), right];\n    } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n      return [left, right];\n    }\n\n    return [left, space, right];\n  }\n\n  function addIndent(stmt) {\n    return [base, stmt];\n  }\n\n  function withIndent(fn) {\n    var previousBase;\n    previousBase = base;\n    base += indent;\n    fn(base);\n    base = previousBase;\n  }\n\n  function calculateSpaces(str) {\n    var i;\n\n    for (i = str.length - 1; i >= 0; --i) {\n      if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n        break;\n      }\n    }\n\n    return str.length - 1 - i;\n  }\n\n  function adjustMultilineComment(value, specialBase) {\n    var array, i, len, line, j, spaces, previousBase, sn;\n    array = value.split(/\\r\\n|[\\r\\n]/);\n    spaces = Number.MAX_VALUE; // first line doesn't have indentation\n\n    for (i = 1, len = array.length; i < len; ++i) {\n      line = array[i];\n      j = 0;\n\n      while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n        ++j;\n      }\n\n      if (spaces > j) {\n        spaces = j;\n      }\n    }\n\n    if (typeof specialBase !== \"undefined\") {\n      // pattern like\n      // {\n      //   var t = 20;  /*\n      //                 * this is comment\n      //                 */\n      // }\n      previousBase = base;\n\n      if (array[1][spaces] === \"*\") {\n        specialBase += \" \";\n      }\n\n      base = specialBase;\n    } else {\n      if (spaces & 1) {\n        // /*\n        //  *\n        //  */\n        // If spaces are odd number, above pattern is considered.\n        // We waste 1 space.\n        --spaces;\n      }\n\n      previousBase = base;\n    }\n\n    for (i = 1, len = array.length; i < len; ++i) {\n      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n      array[i] = sourceMap ? sn.join(\"\") : sn;\n    }\n\n    base = previousBase;\n    return array.join(\"\\n\");\n  }\n\n  function generateComment(comment, specialBase) {\n    if (comment.type === \"Line\") {\n      if (endsWithLineTerminator(comment.value)) {\n        return \"//\" + comment.value;\n      } else {\n        // Always use LineTerminator\n        var result = \"//\" + comment.value;\n\n        if (!preserveBlankLines) {\n          result += \"\\n\";\n        }\n\n        return result;\n      }\n    }\n\n    if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n      return adjustMultilineComment(\"/*\" + comment.value + \"*/\", specialBase);\n    }\n\n    return \"/*\" + comment.value + \"*/\";\n  }\n\n  function addComments(stmt, result) {\n    var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;\n\n    if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n      save = result;\n\n      if (preserveBlankLines) {\n        comment = stmt.leadingComments[0];\n        result = [];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n\n        if (count > 0) {\n          result.push(stringRepeat(\"\\n\", count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n\n        prevRange = range;\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n          comment = stmt.leadingComments[i];\n          range = comment.range;\n          infix = sourceCode.substring(prevRange[1], range[0]);\n          count = (infix.match(/\\n/g) || []).length;\n          result.push(stringRepeat(\"\\n\", count));\n          result.push(addIndent(generateComment(comment)));\n          prevRange = range;\n        }\n\n        suffix = sourceCode.substring(range[1], extRange[1]);\n        count = (suffix.match(/\\n/g) || []).length;\n        result.push(stringRepeat(\"\\n\", count));\n      } else {\n        comment = stmt.leadingComments[0];\n        result = [];\n\n        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n          result.push(\"\\n\");\n        }\n\n        result.push(generateComment(comment));\n\n        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push(\"\\n\");\n        }\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n          comment = stmt.leadingComments[i];\n          fragment = [generateComment(comment)];\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            fragment.push(\"\\n\");\n          }\n\n          result.push(addIndent(fragment));\n        }\n      }\n\n      result.push(addIndent(save));\n    }\n\n    if (stmt.trailingComments) {\n      if (preserveBlankLines) {\n        comment = stmt.trailingComments[0];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n\n        if (count > 0) {\n          result.push(stringRepeat(\"\\n\", count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n      } else {\n        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        specialBase = stringRepeat(\" \", calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\n\n        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n          comment = stmt.trailingComments[i];\n\n          if (tailingToStatement) {\n            // We assume target like following script\n            //\n            // var t = 20;  /**\n            //               * This is comment of t\n            //               */\n            if (i === 0) {\n              // first case\n              result = [result, indent];\n            } else {\n              result = [result, specialBase];\n            }\n\n            result.push(generateComment(comment, specialBase));\n          } else {\n            result = [result, addIndent(generateComment(comment))];\n          }\n\n          if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result = [result, \"\\n\"];\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function generateBlankLines(start, end, result) {\n    var j,\n        newlineCount = 0;\n\n    for (j = start; j < end; j++) {\n      if (sourceCode[j] === \"\\n\") {\n        newlineCount++;\n      }\n    }\n\n    for (j = 1; j < newlineCount; j++) {\n      result.push(newline);\n    }\n  }\n\n  function parenthesize(text, current, should) {\n    if (current < should) {\n      return [\"(\", text, \")\"];\n    }\n\n    return text;\n  }\n\n  function generateVerbatimString(string) {\n    var i, iz, result;\n    result = string.split(/\\r\\n|\\n/);\n\n    for (i = 1, iz = result.length; i < iz; i++) {\n      result[i] = newline + base + result[i];\n    }\n\n    return result;\n  }\n\n  function generateVerbatim(expr, precedence) {\n    var verbatim, result, prec;\n    verbatim = expr[extra.verbatim];\n\n    if (typeof verbatim === \"string\") {\n      result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n    } else {\n      // verbatim is object\n      result = generateVerbatimString(verbatim.content);\n      prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n      result = parenthesize(result, prec, precedence);\n    }\n\n    return toSourceNodeWhenNeeded(result, expr);\n  }\n\n  function CodeGenerator() {} // Helpers.\n\n\n  CodeGenerator.prototype.maybeBlock = function (stmt, flags) {\n    var result,\n        noLeadingComment,\n        that = this;\n    noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n      return [space, this.generateStatement(stmt, flags)];\n    }\n\n    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n      return \";\";\n    }\n\n    withIndent(function () {\n      result = [newline, addIndent(that.generateStatement(stmt, flags))];\n    });\n    return result;\n  };\n\n  CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n    var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n\n    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n      return [result, space];\n    }\n\n    if (ends) {\n      return [result, base];\n    }\n\n    return [result, newline, base];\n  };\n\n  function generateIdentifier(node) {\n    return toSourceNodeWhenNeeded(node.name, node);\n  }\n\n  function generateAsyncPrefix(node, spaceRequired) {\n    return node.async ? \"async\" + (spaceRequired ? noEmptySpace() : space) : \"\";\n  }\n\n  function generateStarSuffix(node) {\n    var isGenerator = node.generator && !extra.moz.starlessGenerator;\n    return isGenerator ? \"*\" + space : \"\";\n  }\n\n  function generateMethodPrefix(prop) {\n    var func = prop.value,\n        prefix = \"\";\n\n    if (func.async) {\n      prefix += generateAsyncPrefix(func, !prop.computed);\n    }\n\n    if (func.generator) {\n      // avoid space before method name\n      prefix += generateStarSuffix(func) ? \"*\" : \"\";\n    }\n\n    return prefix;\n  }\n\n  CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n    if (node.type === Syntax.Identifier) {\n      return generateIdentifier(node);\n    }\n\n    return this.generateExpression(node, precedence, flags);\n  };\n\n  CodeGenerator.prototype.generateFunctionParams = function (node) {\n    var i, iz, result, hasDefault;\n    hasDefault = false;\n\n    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n      // arg => { } case\n      result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\n    } else {\n      result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\n      result.push(\"(\");\n\n      if (node.defaults) {\n        hasDefault = true;\n      }\n\n      for (i = 0, iz = node.params.length; i < iz; ++i) {\n        if (hasDefault && node.defaults[i]) {\n          // Handle default values.\n          result.push(this.generateAssignment(node.params[i], node.defaults[i], \"=\", Precedence.Assignment, E_TTT));\n        } else {\n          result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n        }\n\n        if (i + 1 < iz) {\n          result.push(\",\" + space);\n        }\n      }\n\n      if (node.rest) {\n        if (node.params.length) {\n          result.push(\",\" + space);\n        }\n\n        result.push(\"...\");\n        result.push(generateIdentifier(node.rest));\n      }\n\n      result.push(\")\");\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateFunctionBody = function (node) {\n    var result, expr;\n    result = this.generateFunctionParams(node);\n\n    if (node.type === Syntax.ArrowFunctionExpression) {\n      result.push(space);\n      result.push(\"=>\");\n    }\n\n    if (node.expression) {\n      result.push(space);\n      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n\n      if (expr.toString().charAt(0) === \"{\") {\n        expr = [\"(\", expr, \")\"];\n      }\n\n      result.push(expr);\n    } else {\n      result.push(this.maybeBlock(node.body, S_TTFF));\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n    var result = [\"for\" + (stmt.await ? noEmptySpace() + \"await\" : \"\") + space + \"(\"],\n        that = this;\n    withIndent(function () {\n      if (stmt.left.type === Syntax.VariableDeclaration) {\n        withIndent(function () {\n          result.push(stmt.left.kind + noEmptySpace());\n          result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n        });\n      } else {\n        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n      }\n\n      result = join(result, operator);\n      result = [join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), \")\"];\n    });\n    result.push(this.maybeBlock(stmt.body, flags));\n    return result;\n  };\n\n  CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n    var result = [];\n\n    if (computed) {\n      result.push(\"[\");\n    }\n\n    result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));\n\n    if (computed) {\n      result.push(\"]\");\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n    if (Precedence.Assignment < precedence) {\n      flags |= F_ALLOW_IN;\n    }\n\n    return parenthesize([this.generateExpression(left, Precedence.Call, flags), space + operator + space, this.generateExpression(right, Precedence.Assignment, flags)], Precedence.Assignment, precedence);\n  };\n\n  CodeGenerator.prototype.semicolon = function (flags) {\n    if (!semicolons && flags & F_SEMICOLON_OPT) {\n      return \"\";\n    } // return \";\"; // dan\n\n\n    return \"\";\n  }; // Statements.\n\n\n  CodeGenerator.Statement = {\n    BlockStatement: function BlockStatement(stmt, flags) {\n      var range,\n          content,\n          result = [\"{\", newline],\n          that = this;\n      withIndent(function () {\n        // handle functions without any code\n        if (stmt.body.length === 0 && preserveBlankLines) {\n          range = stmt.range;\n\n          if (range[1] - range[0] > 2) {\n            content = sourceCode.substring(range[0] + 1, range[1] - 1);\n\n            if (content[0] === \"\\n\") {\n              result = [\"{\"];\n            }\n\n            result.push(content);\n          }\n        }\n\n        var i, iz, fragment, bodyFlags;\n        bodyFlags = S_TFFF;\n\n        if (flags & F_FUNC_BODY) {\n          bodyFlags |= F_DIRECTIVE_CTX;\n        }\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          if (preserveBlankLines) {\n            // handle spaces before the first line\n            if (i === 0) {\n              if (stmt.body[0].leadingComments) {\n                range = stmt.body[0].leadingComments[0].extendedRange;\n                content = sourceCode.substring(range[0], range[1]);\n\n                if (content[0] === \"\\n\") {\n                  result = [\"{\"];\n                }\n              }\n\n              if (!stmt.body[0].leadingComments) {\n                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n              }\n            } // handle spaces between lines\n\n\n            if (i > 0) {\n              if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n              }\n            }\n          }\n\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          if (stmt.body[i].leadingComments && preserveBlankLines) {\n            fragment = that.generateStatement(stmt.body[i], bodyFlags);\n          } else {\n            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n          }\n\n          result.push(fragment);\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            if (preserveBlankLines && i < iz - 1) {\n              // don't add a new line if there are leading coments\n              // in the next statement\n              if (!stmt.body[i + 1].leadingComments) {\n                result.push(newline);\n              }\n            } else {\n              result.push(newline);\n            }\n          }\n\n          if (preserveBlankLines) {\n            // handle spaces after the last line\n            if (i === iz - 1) {\n              if (!stmt.body[i].trailingComments) {\n                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n              }\n            }\n          }\n        }\n      });\n      result.push(addIndent(\"}\"));\n      return result;\n    },\n    BreakStatement: function BreakStatement(stmt, flags) {\n      if (stmt.label) {\n        return \"break \" + stmt.label.name + this.semicolon(flags);\n      }\n\n      return \"break\" + this.semicolon(flags);\n    },\n    ContinueStatement: function ContinueStatement(stmt, flags) {\n      if (stmt.label) {\n        return \"continue \" + stmt.label.name + this.semicolon(flags);\n      }\n\n      return \"continue\" + this.semicolon(flags);\n    },\n    ClassBody: function ClassBody(stmt, flags) {\n      var result = [\"{\", newline],\n          that = this;\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          result.push(indent);\n          result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(newline);\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(base);\n      result.push(\"}\");\n      return result;\n    },\n    ClassDeclaration: function ClassDeclaration(stmt, flags) {\n      var result, fragment;\n      result = [\"class\"];\n\n      if (stmt.id) {\n        result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n      }\n\n      if (stmt.superClass) {\n        fragment = join(\"extends\", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n\n      result.push(space);\n      result.push(this.generateStatement(stmt.body, S_TFFT));\n      return result;\n    },\n    DirectiveStatement: function DirectiveStatement(stmt, flags) {\n      if (extra.raw && stmt.raw) {\n        return stmt.raw + this.semicolon(flags);\n      }\n\n      return escapeDirective(stmt.directive) + this.semicolon(flags);\n    },\n    DoWhileStatement: function DoWhileStatement(stmt, flags) {\n      // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n      var result = join(\"do\", this.maybeBlock(stmt.body, S_TFFF));\n      result = this.maybeBlockSuffix(stmt.body, result);\n      return join(result, [\"while\" + space + \"(\", this.generateExpression(stmt.test, Precedence.Sequence, E_TTT), \")\" + this.semicolon(flags)]);\n    },\n    CatchClause: function CatchClause(stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        var guard;\n\n        if (stmt.param) {\n          result = [\"catch\" + space + \"(\", that.generateExpression(stmt.param, Precedence.Sequence, E_TTT), \")\"];\n\n          if (stmt.guard) {\n            guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n            result.splice(2, 0, \" if \", guard);\n          }\n        } else {\n          result = [\"catch\"];\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, S_TFFF));\n      return result;\n    },\n    DebuggerStatement: function DebuggerStatement(stmt, flags) {\n      return \"debugger\" + this.semicolon(flags);\n    },\n    EmptyStatement: function EmptyStatement(stmt, flags) {\n      return \";\";\n    },\n    ExportDefaultDeclaration: function ExportDefaultDeclaration(stmt, flags) {\n      var result = [\"export\"],\n          bodyFlags;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export default HoistableDeclaration[Default]\n      // export default AssignmentExpression[In] ;\n\n      result = join(result, \"default\");\n\n      if (isStatement(stmt.declaration)) {\n        result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      } else {\n        result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n      }\n\n      return result;\n    },\n    ExportNamedDeclaration: function ExportNamedDeclaration(stmt, flags) {\n      var result = [\"export\"],\n          bodyFlags,\n          that = this;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export VariableStatement\n      // export Declaration[Default]\n\n      if (stmt.declaration) {\n        return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      } // export ExportClause[NoReference] FromClause ;\n      // export ExportClause ;\n\n\n      if (stmt.specifiers) {\n        if (stmt.specifiers.length === 0) {\n          result = join(result, \"{\" + space + \"}\");\n        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n          result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n        } else {\n          result = join(result, \"{\");\n          withIndent(function (indent) {\n            var i, iz;\n            result.push(newline);\n\n            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n              result.push(indent);\n              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n\n              if (i + 1 < iz) {\n                result.push(\",\" + newline);\n              }\n            }\n          });\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n\n          result.push(base + \"}\");\n        }\n\n        if (stmt.source) {\n          result = join(result, [\"from\" + space, // ModuleSpecifier\n          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n        } else {\n          result.push(this.semicolon(flags));\n        }\n      }\n\n      return result;\n    },\n    ExportAllDeclaration: function ExportAllDeclaration(stmt, flags) {\n      // export * FromClause ;\n      return [\"export\" + space, \"*\" + space, \"from\" + space, // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n    },\n    ExpressionStatement: function ExpressionStatement(stmt, flags) {\n      var result, fragment;\n\n      function isClassPrefixed(fragment) {\n        var code;\n\n        if (fragment.slice(0, 5) !== \"class\") {\n          return false;\n        }\n\n        code = fragment.charCodeAt(5);\n        return code === 0x7b\n        /* '{' */\n        || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n      }\n\n      function isFunctionPrefixed(fragment) {\n        var code;\n\n        if (fragment.slice(0, 8) !== \"function\") {\n          return false;\n        }\n\n        code = fragment.charCodeAt(8);\n        return code === 0x28\n        /* '(' */\n        || esutils.code.isWhiteSpace(code) || code === 0x2a\n        /* '*' */\n        || esutils.code.isLineTerminator(code);\n      }\n\n      function isAsyncPrefixed(fragment) {\n        var code, i, iz;\n\n        if (fragment.slice(0, 5) !== \"async\") {\n          return false;\n        }\n\n        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n          return false;\n        }\n\n        for (i = 6, iz = fragment.length; i < iz; ++i) {\n          if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n            break;\n          }\n        }\n\n        if (i === iz) {\n          return false;\n        }\n\n        if (fragment.slice(i, i + 8) !== \"function\") {\n          return false;\n        }\n\n        code = fragment.charCodeAt(i + 8);\n        return code === 0x28\n        /* '(' */\n        || esutils.code.isWhiteSpace(code) || code === 0x2a\n        /* '*' */\n        || esutils.code.isLineTerminator(code);\n      }\n\n      result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)]; // 12.4 '{', 'function', 'class' is not allowed in this position.\n      // wrap expression with parentheses\n\n      fragment = toSourceNodeWhenNeeded(result).toString();\n\n      if (fragment.charCodeAt(0) === 0x7b\n      /* '{' */\n      || // ObjectExpression\n      isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === \"string\") {\n        result = [\"(\", result, \")\" + this.semicolon(flags)];\n      } else {\n        result.push(this.semicolon(flags));\n      }\n\n      return result;\n    },\n    ImportDeclaration: function ImportDeclaration(stmt, flags) {\n      // ES6: 15.2.1 valid import declarations:\n      //     - import ImportClause FromClause ;\n      //     - import ModuleSpecifier ;\n      var result,\n          cursor,\n          that = this; // If no ImportClause is present,\n      // this should be `import ModuleSpecifier` so skip `from`\n      // ModuleSpecifier is StringLiteral.\n\n      if (stmt.specifiers.length === 0) {\n        // import ModuleSpecifier ;\n        return [\"import\", space, // ModuleSpecifier\n        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n      } // import ImportClause FromClause ;\n\n\n      result = [\"import\"];\n      cursor = 0; // ImportedBinding\n\n      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n        result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        ++cursor;\n      }\n\n      if (stmt.specifiers[cursor]) {\n        if (cursor !== 0) {\n          result.push(\",\");\n        }\n\n        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n          // NameSpaceImport\n          result = join(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        } else {\n          // NamedImports\n          result.push(space + \"{\");\n\n          if (stmt.specifiers.length - cursor === 1) {\n            // import { ... } from \"...\";\n            result.push(space);\n            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n            result.push(space + \"}\" + space);\n          } else {\n            // import {\n            //    ...,\n            //    ...,\n            // } from \"...\";\n            withIndent(function (indent) {\n              var i, iz;\n              result.push(newline);\n\n              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                result.push(indent);\n                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n\n                if (i + 1 < iz) {\n                  result.push(\",\" + newline);\n                }\n              }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n              result.push(newline);\n            }\n\n            result.push(base + \"}\" + space);\n          }\n        }\n      }\n\n      result = join(result, [\"from\" + space, // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n      return result;\n    },\n    VariableDeclarator: function VariableDeclarator(stmt, flags) {\n      var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n\n      if (stmt.init) {\n        return [this.generateExpression(stmt.id, Precedence.Assignment, itemFlags), space, \"=\", space, this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)];\n      }\n\n      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n    },\n    VariableDeclaration: function VariableDeclaration(stmt, flags) {\n      // VariableDeclarator is typed as Statement,\n      // but joined with comma (not LineTerminator).\n      // So if comment is attached to target node, we should specialize.\n      var result,\n          i,\n          iz,\n          node,\n          bodyFlags,\n          that = this;\n      result = [stmt.kind];\n      bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n\n      function block() {\n        node = stmt.declarations[0];\n\n        if (extra.comment && node.leadingComments) {\n          result.push(\"\\n\");\n          result.push(addIndent(that.generateStatement(node, bodyFlags)));\n        } else {\n          result.push(noEmptySpace());\n          result.push(that.generateStatement(node, bodyFlags));\n        }\n\n        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n          node = stmt.declarations[i];\n\n          if (extra.comment && node.leadingComments) {\n            result.push(\",\" + newline);\n            result.push(addIndent(that.generateStatement(node, bodyFlags)));\n          } else {\n            result.push(\",\" + space);\n            result.push(that.generateStatement(node, bodyFlags));\n          }\n        }\n      }\n\n      if (stmt.declarations.length > 1) {\n        withIndent(block);\n      } else {\n        block();\n      }\n\n      result.push(this.semicolon(flags));\n      return result;\n    },\n    ThrowStatement: function ThrowStatement(stmt, flags) {\n      return [join(\"throw\", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n    },\n    TryStatement: function TryStatement(stmt, flags) {\n      var result, i, iz, guardedHandlers;\n      result = [\"try\", this.maybeBlock(stmt.block, S_TFFF)];\n      result = this.maybeBlockSuffix(stmt.block, result);\n\n      if (stmt.handlers) {\n        // old interface\n        for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n          }\n        }\n      } else {\n        guardedHandlers = stmt.guardedHandlers || [];\n\n        for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n          }\n        } // new interface\n\n\n        if (stmt.handler) {\n          if (Array.isArray(stmt.handler)) {\n            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n\n              if (stmt.finalizer || i + 1 !== iz) {\n                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n              }\n            }\n          } else {\n            result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n\n            if (stmt.finalizer) {\n              result = this.maybeBlockSuffix(stmt.handler.body, result);\n            }\n          }\n        }\n      }\n\n      if (stmt.finalizer) {\n        result = join(result, [\"finally\", this.maybeBlock(stmt.finalizer, S_TFFF)]);\n      }\n\n      return result;\n    },\n    SwitchStatement: function SwitchStatement(stmt, flags) {\n      var result,\n          fragment,\n          i,\n          iz,\n          bodyFlags,\n          that = this;\n      withIndent(function () {\n        result = [\"switch\" + space + \"(\", that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT), \")\" + space + \"{\" + newline];\n      });\n\n      if (stmt.cases) {\n        bodyFlags = S_TFFF;\n\n        for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n          result.push(fragment);\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      }\n\n      result.push(addIndent(\"}\"));\n      return result;\n    },\n    SwitchCase: function SwitchCase(stmt, flags) {\n      var result,\n          fragment,\n          i,\n          iz,\n          bodyFlags,\n          that = this;\n      withIndent(function () {\n        if (stmt.test) {\n          result = [addIndent(join(\"case \", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT))), \" :\"];\n        } else {\n          result = [addIndent(\"default :\")];\n        }\n\n        i = 0;\n        iz = stmt.consequent.length;\n\n        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n          result.push(fragment);\n          i = 1;\n        }\n\n        if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push(newline);\n        }\n\n        bodyFlags = S_TFFF;\n\n        for (; i < iz; ++i) {\n          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          fragment = addIndent(addIndent(join(that.generateStatement(stmt.consequent[i], bodyFlags), \";\")));\n          result.push(fragment);\n\n          if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      });\n      return result;\n    },\n    IfStatement: function IfStatement(stmt, flags) {\n      var result,\n          bodyFlags,\n          semicolonOptional,\n          that = this;\n      withIndent(function () {\n        result = [\"if\" + space + \"(\", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), \")\"];\n      });\n      semicolonOptional = flags & F_SEMICOLON_OPT;\n      bodyFlags = S_TFFF;\n\n      if (semicolonOptional) {\n        bodyFlags |= F_SEMICOLON_OPT;\n      }\n\n      if (stmt.alternate) {\n        result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n        result = this.maybeBlockSuffix(stmt.consequent, result);\n\n        if (stmt.alternate.type === Syntax.IfStatement) {\n          result = join(result, [\"else \", this.generateStatement(stmt.alternate, bodyFlags)]);\n        } else {\n          result = join(result, join(\"else\", this.maybeBlock(stmt.alternate, bodyFlags)));\n        }\n      } else {\n        result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n      }\n\n      return result;\n    },\n    ForStatement: function ForStatement(stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = [\"for\" + space + \"(\"];\n\n        if (stmt.init) {\n          // console.log(stmt.init.type);\n          if (stmt.init.type === Syntax.VariableDeclaration) {\n            result.push(that.generateStatement(stmt.init, S_FFFF));\n            result.push(\";\");\n          } else {\n            // F_ALLOW_IN becomes false.\n            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n            result.push(\";\");\n          }\n        } else {\n          result.push(\";\");\n        }\n\n        if (stmt.test) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n          result.push(\";\");\n        } else {\n          result.push(\";\");\n        }\n\n        if (stmt.update) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n          result.push(\")\");\n        } else {\n          result.push(\")\");\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    ForInStatement: function ForInStatement(stmt, flags) {\n      return this.generateIterationForStatement(\"in\", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    ForOfStatement: function ForOfStatement(stmt, flags) {\n      return this.generateIterationForStatement(\"of\", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    LabeledStatement: function LabeledStatement(stmt, flags) {\n      return [stmt.label.name + \":\", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\n    },\n    Program: function Program(stmt, flags) {\n      var result, fragment, i, iz, bodyFlags;\n      iz = stmt.body.length;\n      result = [safeConcatenation && iz > 0 ? \"\\n\" : \"\"];\n      bodyFlags = S_TFTF;\n\n      for (i = 0; i < iz; ++i) {\n        if (!safeConcatenation && i === iz - 1) {\n          bodyFlags |= F_SEMICOLON_OPT;\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces before the first line\n          if (i === 0) {\n            if (!stmt.body[0].leadingComments) {\n              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n            }\n          } // handle spaces between lines\n\n\n          if (i > 0) {\n            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n            }\n          }\n        }\n\n        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n        result.push(fragment);\n\n        if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          if (preserveBlankLines) {\n            if (!stmt.body[i + 1].leadingComments) {\n              result.push(newline);\n            }\n          } else {\n            result.push(newline);\n          }\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces after the last line\n          if (i === iz - 1) {\n            if (!stmt.body[i].trailingComments) {\n              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n            }\n          }\n        }\n      }\n\n      return result;\n    },\n    //dan\n    FunctionDeclaration: function FunctionDeclaration(stmt, flags) {\n      return [generateAsyncPrefix(stmt, true), \"function\", generateStarSuffix(stmt) || noEmptySpace(), stmt.id ? generateIdentifier(stmt.id) : \"\", this.generateFunctionBody(stmt)];\n    },\n    ReturnStatement: function ReturnStatement(stmt, flags) {\n      if (stmt.argument) {\n        return [join(\"return\", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n      }\n\n      return [\"return\" + this.semicolon(flags)];\n    },\n    WhileStatement: function WhileStatement(stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = [\"while\" + space + \"(\", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), \")\"];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    WithStatement: function WithStatement(stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = [\"with\" + space + \"(\", that.generateExpression(stmt.object, Precedence.Sequence, E_TTT), \")\"];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Statement); // Expressions.\n\n  CodeGenerator.Expression = {\n    SequenceExpression: function SequenceExpression(expr, precedence, flags) {\n      var result, i, iz;\n\n      if (Precedence.Sequence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      result = [];\n\n      for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n\n        if (i + 1 < iz) {\n          result.push(\",\" + space);\n        }\n      }\n\n      return parenthesize(result, Precedence.Sequence, precedence);\n    },\n    AssignmentExpression: function AssignmentExpression(expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n    },\n    ArrowFunctionExpression: function ArrowFunctionExpression(expr, precedence, flags) {\n      return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n    },\n    ConditionalExpression: function ConditionalExpression(expr, precedence, flags) {\n      if (Precedence.Conditional < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      return parenthesize([this.generateExpression(expr.test, Precedence.LogicalOR, flags), space + \"?\" + space, this.generateExpression(expr.consequent, Precedence.Assignment, flags), space + \":\" + space, this.generateExpression(expr.alternate, Precedence.Assignment, flags)], Precedence.Conditional, precedence);\n    },\n    LogicalExpression: function LogicalExpression(expr, precedence, flags) {\n      return this.BinaryExpression(expr, precedence, flags);\n    },\n    BinaryExpression: function BinaryExpression(expr, precedence, flags) {\n      var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n      currentPrecedence = BinaryPrecedence[expr.operator];\n      leftPrecedence = expr.operator === \"**\" ? Precedence.Postfix : currentPrecedence;\n      rightPrecedence = expr.operator === \"**\" ? currentPrecedence : currentPrecedence + 1;\n\n      if (currentPrecedence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n      leftSource = fragment.toString();\n\n      if (leftSource.charCodeAt(leftSource.length - 1) === 0x2f\n      /* / */\n      && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n        result = [fragment, noEmptySpace(), expr.operator];\n      } else {\n        result = join(fragment, expr.operator);\n      }\n\n      fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n\n      if (expr.operator === \"/\" && fragment.toString().charAt(0) === \"/\" || expr.operator.slice(-1) === \"<\" && fragment.toString().slice(0, 3) === \"!--\") {\n        // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n        result.push(noEmptySpace());\n        result.push(fragment);\n      } else {\n        result = join(result, fragment);\n      }\n\n      if (expr.operator === \"in\" && !(flags & F_ALLOW_IN)) {\n        return [\"(\", result, \")\"];\n      }\n\n      return parenthesize(result, currentPrecedence, precedence);\n    },\n    CallExpression: function CallExpression(expr, precedence, flags) {\n      var result, i, iz; // F_ALLOW_UNPARATH_NEW becomes false.\n\n      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n      result.push(\"(\");\n\n      for (i = 0, iz = expr[\"arguments\"].length; i < iz; ++i) {\n        result.push(this.generateExpression(expr[\"arguments\"][i], Precedence.Assignment, E_TTT));\n\n        if (i + 1 < iz) {\n          result.push(\",\" + space);\n        }\n      }\n\n      result.push(\")\");\n\n      if (!(flags & F_ALLOW_CALL)) {\n        return [\"(\", result, \")\"];\n      }\n\n      return parenthesize(result, Precedence.Call, precedence);\n    },\n    NewExpression: function NewExpression(expr, precedence, flags) {\n      var result, length, i, iz, itemFlags;\n      length = expr[\"arguments\"].length; // F_ALLOW_CALL becomes false.\n      // F_ALLOW_UNPARATH_NEW may become false.\n\n      itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;\n      result = join(\"new\", this.generateExpression(expr.callee, Precedence.New, itemFlags));\n\n      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n        result.push(\"(\");\n\n        for (i = 0, iz = length; i < iz; ++i) {\n          result.push(this.generateExpression(expr[\"arguments\"][i], Precedence.Assignment, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(\",\" + space);\n          }\n        }\n\n        result.push(\")\");\n      }\n\n      return parenthesize(result, Precedence.New, precedence);\n    },\n    MemberExpression: function MemberExpression(expr, precedence, flags) {\n      var result, fragment; // F_ALLOW_UNPARATH_NEW becomes false.\n\n      result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];\n\n      if (expr.computed) {\n        result.push(\"[\");\n        result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n        result.push(\"]\");\n      } else {\n        if (expr.object.type === Syntax.Literal && typeof expr.object.value === \"number\") {\n          fragment = toSourceNodeWhenNeeded(result).toString(); // When the following conditions are all true,\n          //   1. No floating point\n          //   2. Don't have exponents\n          //   3. The last character is a decimal digit\n          //   4. Not hexadecimal OR octal number literal\n          // we should add a floating point.\n\n          if (fragment.indexOf(\".\") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48) // '0'\n          ) {\n            result.push(\" \");\n          }\n        }\n\n        result.push(\".\");\n        result.push(generateIdentifier(expr.property));\n      }\n\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    MetaProperty: function MetaProperty(expr, precedence, flags) {\n      var result;\n      result = [];\n      result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n      result.push(\".\");\n      result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    UnaryExpression: function UnaryExpression(expr, precedence, flags) {\n      var result, fragment, rightCharCode, leftSource, leftCharCode;\n      fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n\n      if (space === \"\") {\n        result = join(expr.operator, fragment);\n      } else {\n        result = [expr.operator];\n\n        if (expr.operator.length > 2) {\n          // delete, void, typeof\n          // get `typeof []`, not `typeof[]`\n          result = join(result, fragment);\n        } else {\n          // Prevent inserting spaces between operator and argument if it is unnecessary\n          // like, `!cond`\n          leftSource = toSourceNodeWhenNeeded(result).toString();\n          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n          rightCharCode = fragment.toString().charCodeAt(0);\n\n          if ((leftCharCode === 0x2b\n          /* + */\n          || leftCharCode === 0x2d\n          /* - */\n          ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {\n            result.push(noEmptySpace());\n            result.push(fragment);\n          } else {\n            result.push(fragment);\n          }\n        }\n      }\n\n      return parenthesize(result, Precedence.Unary, precedence);\n    },\n    YieldExpression: function YieldExpression(expr, precedence, flags) {\n      var result;\n\n      if (expr.delegate) {\n        result = \"yield*\";\n      } else {\n        result = \"yield\";\n      }\n\n      if (expr.argument) {\n        result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));\n      }\n\n      return parenthesize(result, Precedence.Yield, precedence);\n    },\n    AwaitExpression: function AwaitExpression(expr, precedence, flags) {\n      var result = join(expr.all ? \"await*\" : \"await\", this.generateExpression(expr.argument, Precedence.Await, E_TTT));\n      return parenthesize(result, Precedence.Await, precedence);\n    },\n    UpdateExpression: function UpdateExpression(expr, precedence, flags) {\n      if (expr.prefix) {\n        return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);\n      }\n\n      return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);\n    },\n    FunctionExpression: function FunctionExpression(expr, precedence, flags) {\n      var result = [generateAsyncPrefix(expr, true), \"function\"];\n\n      if (expr.id) {\n        result.push(generateStarSuffix(expr) || noEmptySpace());\n        result.push(generateIdentifier(expr.id));\n      } else {\n        result.push(generateStarSuffix(expr) || space);\n      }\n\n      result.push(this.generateFunctionBody(expr));\n      return result;\n    },\n    ArrayPattern: function ArrayPattern(expr, precedence, flags) {\n      return this.ArrayExpression(expr, precedence, flags, true);\n    },\n    ArrayExpression: function ArrayExpression(expr, precedence, flags, isPattern) {\n      var result,\n          multiline,\n          that = this;\n\n      if (!expr.elements.length) {\n        return \"[]\";\n      }\n\n      multiline = isPattern ? false : expr.elements.length > 1;\n      result = [\"[\", multiline ? newline : \"\"];\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n          if (!expr.elements[i]) {\n            if (multiline) {\n              result.push(indent);\n            }\n\n            if (i + 1 === iz) {\n              result.push(\",\");\n            }\n          } else {\n            result.push(multiline ? indent : \"\");\n            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n          }\n\n          if (i + 1 < iz) {\n            result.push(\",\" + (multiline ? newline : space));\n          }\n        }\n      });\n\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(multiline ? base : \"\");\n      result.push(\"]\");\n      return result;\n    },\n    RestElement: function RestElement(expr, precedence, flags) {\n      return \"...\" + this.generatePattern(expr.argument);\n    },\n    ClassExpression: function ClassExpression(expr, precedence, flags) {\n      var result, fragment;\n      result = [\"class\"];\n\n      if (expr.id) {\n        result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n      }\n\n      if (expr.superClass) {\n        fragment = join(\"extends\", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n\n      result.push(space);\n      result.push(this.generateStatement(expr.body, S_TFFT));\n      return result;\n    },\n    MethodDefinition: function MethodDefinition(expr, precedence, flags) {\n      var result, fragment;\n\n      if (expr[\"static\"]) {\n        result = [\"static\" + space];\n      } else {\n        result = [];\n      }\n\n      if (expr.kind === \"get\" || expr.kind === \"set\") {\n        fragment = [join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];\n      } else {\n        fragment = [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      return join(result, fragment);\n    },\n    Property: function Property(expr, precedence, flags) {\n      if (expr.kind === \"get\" || expr.kind === \"set\") {\n        return [expr.kind, noEmptySpace(), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      if (expr.shorthand) {\n        if (expr.value.type === \"AssignmentPattern\") {\n          return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n        }\n\n        return this.generatePropertyKey(expr.key, expr.computed);\n      }\n\n      if (expr.method) {\n        return [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      return [this.generatePropertyKey(expr.key, expr.computed), \":\" + space, this.generateExpression(expr.value, Precedence.Assignment, E_TTT)];\n    },\n    ObjectExpression: function ObjectExpression(expr, precedence, flags) {\n      var multiline,\n          result,\n          fragment,\n          that = this;\n\n      if (!expr.properties.length) {\n        return \"{}\";\n      }\n\n      multiline = expr.properties.length > 1;\n      withIndent(function () {\n        fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n      });\n\n      if (!multiline) {\n        // issues 4\n        // Do not transform from\n        //   dejavu.Class.declare({\n        //       method2: function () {}\n        //   });\n        // to\n        //   dejavu.Class.declare({method2: function () {\n        //       }});\n        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          return [\"{\", space, fragment, space, \"}\"];\n        }\n      }\n\n      withIndent(function (indent) {\n        var i, iz;\n        result = [\"{\", newline, indent, fragment];\n\n        if (multiline) {\n          result.push(\",\" + newline);\n\n          for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n            result.push(indent);\n            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n\n            if (i + 1 < iz) {\n              result.push(\",\" + newline);\n            }\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(base);\n      result.push(\"}\");\n      return result;\n    },\n    AssignmentPattern: function AssignmentPattern(expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, \"=\", precedence, flags);\n    },\n    ObjectPattern: function ObjectPattern(expr, precedence, flags) {\n      var result,\n          i,\n          iz,\n          multiline,\n          property,\n          that = this;\n\n      if (!expr.properties.length) {\n        return \"{}\";\n      }\n\n      multiline = false;\n\n      if (expr.properties.length === 1) {\n        property = expr.properties[0];\n\n        if (property.value.type !== Syntax.Identifier) {\n          multiline = true;\n        }\n      } else {\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          property = expr.properties[i];\n\n          if (!property.shorthand) {\n            multiline = true;\n            break;\n          }\n        }\n      }\n\n      result = [\"{\", multiline ? newline : \"\"];\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          result.push(multiline ? indent : \"\");\n          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(\",\" + (multiline ? newline : space));\n          }\n        }\n      });\n\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(multiline ? base : \"\");\n      result.push(\"}\");\n      return result;\n    },\n    ThisExpression: function ThisExpression(expr, precedence, flags) {\n      return \"this\";\n    },\n    Super: function Super(expr, precedence, flags) {\n      return \"super\";\n    },\n    Identifier: function Identifier(expr, precedence, flags) {\n      return generateIdentifier(expr);\n    },\n    ImportDefaultSpecifier: function ImportDefaultSpecifier(expr, precedence, flags) {\n      return generateIdentifier(expr.id || expr.local);\n    },\n    ImportNamespaceSpecifier: function ImportNamespaceSpecifier(expr, precedence, flags) {\n      var result = [\"*\"];\n      var id = expr.id || expr.local;\n\n      if (id) {\n        result.push(space + \"as\" + noEmptySpace() + generateIdentifier(id));\n      }\n\n      return result;\n    },\n    ImportSpecifier: function ImportSpecifier(expr, precedence, flags) {\n      var imported = expr.imported;\n      var result = [imported.name];\n      var local = expr.local;\n\n      if (local && local.name !== imported.name) {\n        result.push(noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(local));\n      }\n\n      return result;\n    },\n    ExportSpecifier: function ExportSpecifier(expr, precedence, flags) {\n      var local = expr.local;\n      var result = [local.name];\n      var exported = expr.exported;\n\n      if (exported && exported.name !== local.name) {\n        result.push(noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(exported));\n      }\n\n      return result;\n    },\n    Literal: function Literal(expr, precedence, flags) {\n      var raw;\n\n      if (expr.hasOwnProperty(\"raw\") && parse && extra.raw) {\n        try {\n          raw = parse(expr.raw).body[0].expression;\n\n          if (raw.type === Syntax.Literal) {\n            if (raw.value === expr.value) {\n              return expr.raw;\n            }\n          }\n        } catch (e) {// not use raw property\n        }\n      }\n\n      if (expr.regex) {\n        return \"/\" + expr.regex.pattern + \"/\" + expr.regex.flags;\n      }\n\n      if (expr.value === null) {\n        return \"null\";\n      }\n\n      if (typeof expr.value === \"string\") {\n        return escapeString(expr.value);\n      }\n\n      if (typeof expr.value === \"number\") {\n        return generateNumber(expr.value);\n      }\n\n      if (typeof expr.value === \"boolean\") {\n        return expr.value ? \"true\" : \"false\";\n      }\n\n      return generateRegExp(expr.value);\n    },\n    GeneratorExpression: function GeneratorExpression(expr, precedence, flags) {\n      return this.ComprehensionExpression(expr, precedence, flags);\n    },\n    ComprehensionExpression: function ComprehensionExpression(expr, precedence, flags) {\n      // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n      // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n      var result,\n          i,\n          iz,\n          fragment,\n          that = this;\n      result = expr.type === Syntax.GeneratorExpression ? [\"(\"] : [\"[\"];\n\n      if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result.push(fragment);\n      }\n\n      if (expr.blocks) {\n        withIndent(function () {\n          for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n\n            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n              result = join(result, fragment);\n            } else {\n              result.push(fragment);\n            }\n          }\n        });\n      }\n\n      if (expr.filter) {\n        result = join(result, \"if\" + space);\n        fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n        result = join(result, [\"(\", fragment, \")\"]);\n      }\n\n      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result = join(result, fragment);\n      }\n\n      result.push(expr.type === Syntax.GeneratorExpression ? \")\" : \"]\");\n      return result;\n    },\n    ComprehensionBlock: function ComprehensionBlock(expr, precedence, flags) {\n      var fragment;\n\n      if (expr.left.type === Syntax.VariableDeclaration) {\n        fragment = [expr.left.kind, noEmptySpace(), this.generateStatement(expr.left.declarations[0], S_FFFF)];\n      } else {\n        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n      }\n\n      fragment = join(fragment, expr.of ? \"of\" : \"in\");\n      fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n      return [\"for\" + space + \"(\", fragment, \")\"];\n    },\n    SpreadElement: function SpreadElement(expr, precedence, flags) {\n      return [\"...\", this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];\n    },\n    TaggedTemplateExpression: function TaggedTemplateExpression(expr, precedence, flags) {\n      var itemFlags = E_TTF;\n\n      if (!(flags & F_ALLOW_CALL)) {\n        itemFlags = E_TFF;\n      }\n\n      var result = [this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)];\n      return parenthesize(result, Precedence.TaggedTemplate, precedence);\n    },\n    TemplateElement: function TemplateElement(expr, precedence, flags) {\n      // Don't use \"cooked\". Since tagged template can use raw template\n      // representation. So if we do so, it breaks the script semantics.\n      return expr.value.raw;\n    },\n    TemplateLiteral: function TemplateLiteral(expr, precedence, flags) {\n      var result, i, iz;\n      result = [\"`\"];\n\n      for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n\n        if (i + 1 < iz) {\n          result.push(\"${\" + space);\n          result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n          result.push(space + \"}\");\n        }\n      }\n\n      result.push(\"`\");\n      return result;\n    },\n    ModuleSpecifier: function ModuleSpecifier(expr, precedence, flags) {\n      return this.Literal(expr, precedence, flags);\n    },\n    ImportExpression: function ImportExpression(expr, precedence, flag) {\n      return parenthesize([\"import(\", this.generateExpression(expr.source, Precedence.Assignment, E_TTT), \")\"], Precedence.Call, precedence);\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Expression);\n\n  CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n    var result, type;\n    type = expr.type || Syntax.Property;\n\n    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n      return generateVerbatim(expr, precedence);\n    }\n\n    result = this[type](expr, precedence, flags);\n\n    if (extra.comment) {\n      result = addComments(expr, result);\n    }\n\n    return toSourceNodeWhenNeeded(result, expr);\n  };\n\n  CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n    var result, fragment;\n    result = this[stmt.type](stmt, flags); // Attach comments\n\n    if (extra.comment) {\n      result = addComments(stmt, result);\n    }\n\n    fragment = toSourceNodeWhenNeeded(result).toString();\n\n    if (stmt.type === Syntax.Program && !safeConcatenation && newline === \"\" && fragment.charAt(fragment.length - 1) === \"\\n\") {\n      result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, \"\") : fragment.replace(/\\s+$/, \"\");\n    }\n\n    return toSourceNodeWhenNeeded(result, stmt);\n  };\n\n  function generateInternal(node) {\n    var codegen;\n    codegen = new CodeGenerator();\n\n    if (isStatement(node)) {\n      return codegen.generateStatement(node, S_TFFF);\n    }\n\n    if (isExpression(node)) {\n      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n    }\n\n    throw new Error(\"Unknown node type: \" + node.type);\n  }\n\n  function generate(node, options) {\n    var defaultOptions = getDefaultOptions(),\n        result,\n        pair;\n\n    if (options != null) {\n      // Obsolete options\n      //\n      //   `options.indent`\n      //   `options.base`\n      //\n      // Instead of them, we can use `option.format.indent`.\n      if (typeof options.indent === \"string\") {\n        defaultOptions.format.indent.style = options.indent;\n      }\n\n      if (typeof options.base === \"number\") {\n        defaultOptions.format.indent.base = options.base;\n      }\n\n      options = updateDeeply(defaultOptions, options);\n      indent = options.format.indent.style;\n\n      if (typeof options.base === \"string\") {\n        base = options.base;\n      } else {\n        base = stringRepeat(indent, options.format.indent.base);\n      }\n    } else {\n      options = defaultOptions;\n      indent = options.format.indent.style;\n      base = stringRepeat(indent, options.format.indent.base);\n    }\n\n    json = options.format.json;\n    renumber = options.format.renumber;\n    hexadecimal = json ? false : options.format.hexadecimal;\n    quotes = json ? \"double\" : options.format.quotes;\n    escapeless = options.format.escapeless;\n    newline = options.format.newline;\n    space = options.format.space;\n\n    if (options.format.compact) {\n      newline = space = indent = base = \"\";\n    }\n\n    parentheses = options.format.parentheses;\n    semicolons = options.format.semicolons;\n    safeConcatenation = options.format.safeConcatenation;\n    directive = options.directive;\n    parse = json ? null : options.parse;\n    sourceMap = options.sourceMap;\n    sourceCode = options.sourceCode;\n    preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n    extra = options;\n\n    if (sourceMap) {\n      if (!exports.browser) {\n        // We assume environment is node.js\n        // And prevent from including source-map by browserify\n        SourceNode = require(\"source-map\").SourceNode;\n      } else {\n        SourceNode = global.sourceMap.SourceNode;\n      }\n    }\n\n    result = generateInternal(node);\n\n    if (!sourceMap) {\n      pair = {\n        code: result.toString(),\n        map: null\n      };\n      return options.sourceMapWithCode ? pair : pair.code;\n    }\n\n    pair = result.toStringWithSourceMap({\n      file: options.file,\n      sourceRoot: options.sourceMapRoot\n    });\n\n    if (options.sourceContent) {\n      pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n    }\n\n    if (options.sourceMapWithCode) {\n      return pair;\n    }\n\n    return pair.map.toString();\n  }\n\n  FORMAT_MINIFY = {\n    indent: {\n      style: \"\",\n      base: 0\n    },\n    renumber: true,\n    hexadecimal: true,\n    quotes: \"auto\",\n    escapeless: true,\n    compact: true,\n    parentheses: false,\n    semicolons: false\n  };\n  FORMAT_DEFAULTS = getDefaultOptions().format;\n  exports.generate = generate;\n  exports.attachComments = estraverse.attachComments;\n  exports.Precedence = updateDeeply({}, Precedence);\n  exports.browser = false;\n  exports.FORMAT_MINIFY = FORMAT_MINIFY;\n  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["/Users/jimmy/Documents/Wizschool/wizlab_web2/src/Page/Builder/utils/escodegen.js"],"names":["Syntax","Precedence","BinaryPrecedence","SourceNode","estraverse","esutils","base","indent","json","renumber","hexadecimal","quotes","escapeless","newline","space","parentheses","semicolons","safeConcatenation","directive","extra","parse","sourceMap","sourceCode","preserveBlankLines","FORMAT_MINIFY","FORMAT_DEFAULTS","require","isExpression","node","CodeGenerator","Expression","hasOwnProperty","type","isStatement","Statement","Sequence","Yield","Assignment","Conditional","ArrowFunction","LogicalOR","LogicalAND","BitwiseOR","BitwiseXOR","BitwiseAND","Equality","Relational","BitwiseSHIFT","Additive","Multiplicative","Exponentiation","Await","Unary","Postfix","Call","New","TaggedTemplate","Member","Primary","is","isnt","in","instanceof","F_ALLOW_IN","F_ALLOW_CALL","F_ALLOW_UNPARATH_NEW","F_FUNC_BODY","F_DIRECTIVE_CTX","F_SEMICOLON_OPT","E_FTT","E_TTF","E_TTT","E_TFF","E_FFT","E_TFT","S_TFFF","S_TFFT","S_FFFF","S_TFTF","S_TTFF","getDefaultOptions","comment","format","style","adjustMultilineComment","compact","moz","comprehensionExpressionStartsWithAssignment","starlessGenerator","sourceMapRoot","sourceMapWithCode","raw","verbatim","stringRepeat","str","num","result","hasLineTerminator","test","endsWithLineTerminator","len","length","code","isLineTerminator","charCodeAt","merge","target","override","key","updateDeeply","val","isHashObject","Object","RegExp","generateNumber","value","point","temp","exponent","pos","Error","indexOf","slice","replace","Math","floor","toString","escapeRegExpCharacter","ch","previousIsBackslash","String","fromCharCode","generateRegExp","reg","match","flags","i","iz","characterInBrack","source","escapeAllowedCharacter","next","hex","toUpperCase","isDecimalDigit","escapeDisallowedCharacter","escapeDirective","quote","escapeString","singleQuotes","doubleQuotes","single","isIdentifierPartES5","flattenToString","arr","elem","Array","isArray","toSourceNodeWhenNeeded","generated","loc","name","start","line","column","noEmptySpace","join","left","right","leftSource","rightSource","leftCharCode","rightCharCode","isWhiteSpace","addIndent","stmt","withIndent","fn","previousBase","calculateSpaces","specialBase","array","j","spaces","sn","split","Number","MAX_VALUE","generateComment","addComments","save","tailingToStatement","fragment","extRange","range","prevRange","prefix","infix","suffix","count","leadingComments","extendedRange","substring","push","Program","body","trailingComments","generateBlankLines","end","newlineCount","parenthesize","text","current","should","generateVerbatimString","string","generateVerbatim","expr","precedence","prec","content","prototype","maybeBlock","noLeadingComment","that","BlockStatement","generateStatement","EmptyStatement","maybeBlockSuffix","ends","generateIdentifier","generateAsyncPrefix","spaceRequired","async","generateStarSuffix","isGenerator","generator","generateMethodPrefix","prop","func","computed","generatePattern","Identifier","generateExpression","generateFunctionParams","hasDefault","ArrowFunctionExpression","rest","defaults","params","generateAssignment","generateFunctionBody","expression","charAt","generateIterationForStatement","operator","await","VariableDeclaration","kind","declarations","generatePropertyKey","semicolon","bodyFlags","BreakStatement","label","ContinueStatement","ClassBody","ClassDeclaration","id","superClass","DirectiveStatement","DoWhileStatement","CatchClause","guard","param","splice","DebuggerStatement","ExportDefaultDeclaration","declaration","ExportNamedDeclaration","specifiers","ExportBatchSpecifier","ExportAllDeclaration","ExpressionStatement","isClassPrefixed","isFunctionPrefixed","isAsyncPrefixed","Literal","ImportDeclaration","cursor","ImportDefaultSpecifier","ImportNamespaceSpecifier","VariableDeclarator","itemFlags","init","block","ThrowStatement","argument","TryStatement","guardedHandlers","handlers","finalizer","handler","SwitchStatement","discriminant","cases","SwitchCase","consequent","IfStatement","semicolonOptional","alternate","ForStatement","update","ForInStatement","ForOfStatement","LabeledStatement","FunctionDeclaration","ReturnStatement","WhileStatement","WithStatement","object","SequenceExpression","expressions","AssignmentExpression","ConditionalExpression","LogicalExpression","BinaryExpression","leftPrecedence","rightPrecedence","currentPrecedence","CallExpression","callee","NewExpression","MemberExpression","property","MetaProperty","meta","UnaryExpression","YieldExpression","delegate","AwaitExpression","all","UpdateExpression","FunctionExpression","ArrayPattern","ArrayExpression","isPattern","multiline","elements","RestElement","ClassExpression","MethodDefinition","Property","shorthand","AssignmentPattern","method","ObjectExpression","properties","ObjectPattern","ThisExpression","Super","local","ImportSpecifier","imported","ExportSpecifier","exported","e","regex","pattern","GeneratorExpression","ComprehensionExpression","blocks","filter","ComprehensionBlock","of","SpreadElement","TaggedTemplateExpression","tag","quasi","TemplateElement","TemplateLiteral","quasis","ModuleSpecifier","ImportExpression","flag","replaceRight","generateInternal","codegen","generate","options","defaultOptions","pair","exports","browser","global","map","toStringWithSourceMap","file","sourceRoot","sourceContent","setSourceContent","attachComments"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,YAAW;AACV;AAEA,MAAIA,MAAJ,EACEC,UADF,EAEEC,gBAFF,EAGEC,UAHF,EAIEC,UAJF,EAKEC,OALF,EAMEC,IANF,EAOEC,MAPF,EAQEC,IARF,EASEC,QATF,EAUEC,WAVF,EAWEC,MAXF,EAYEC,UAZF,EAaEC,OAbF,EAcEC,KAdF,EAeEC,WAfF,EAgBEC,UAhBF,EAiBEC,iBAjBF,EAkBEC,SAlBF,EAmBEC,KAnBF,EAoBEC,KApBF,EAqBEC,SArBF,EAsBEC,UAtBF,EAuBEC,kBAvBF,EAwBEC,aAxBF,EAyBEC,eAzBF;AA2BArB,EAAAA,UAAU,GAAGsB,OAAO,CAAC,YAAD,CAApB;AACArB,EAAAA,OAAO,GAAGqB,OAAO,CAAC,SAAD,CAAjB;AAEA1B,EAAAA,MAAM,GAAGI,UAAU,CAACJ,MAApB,CAjCU,CAmCV;;AACA,WAAS2B,YAAT,CAAsBC,IAAtB,EAA4B;AAC1B,WAAOC,aAAa,CAACC,UAAd,CAAyBC,cAAzB,CAAwCH,IAAI,CAACI,IAA7C,CAAP;AACD,GAtCS,CAwCV;;;AACA,WAASC,WAAT,CAAqBL,IAArB,EAA2B;AACzB,WAAOC,aAAa,CAACK,SAAd,CAAwBH,cAAxB,CAAuCH,IAAI,CAACI,IAA5C,CAAP;AACD;;AAED/B,EAAAA,UAAU,GAAG;AACXkC,IAAAA,QAAQ,EAAE,CADC;AAEXC,IAAAA,KAAK,EAAE,CAFI;AAGXC,IAAAA,UAAU,EAAE,CAHD;AAIXC,IAAAA,WAAW,EAAE,CAJF;AAKXC,IAAAA,aAAa,EAAE,CALJ;AAMXC,IAAAA,SAAS,EAAE,CANA;AAOXC,IAAAA,UAAU,EAAE,CAPD;AAQXC,IAAAA,SAAS,EAAE,CARA;AASXC,IAAAA,UAAU,EAAE,CATD;AAUXC,IAAAA,UAAU,EAAE,CAVD;AAWXC,IAAAA,QAAQ,EAAE,CAXC;AAYXC,IAAAA,UAAU,EAAE,CAZD;AAaXC,IAAAA,YAAY,EAAE,EAbH;AAcXC,IAAAA,QAAQ,EAAE,EAdC;AAeXC,IAAAA,cAAc,EAAE,EAfL;AAgBXC,IAAAA,cAAc,EAAE,EAhBL;AAiBXC,IAAAA,KAAK,EAAE,EAjBI;AAkBXC,IAAAA,KAAK,EAAE,EAlBI;AAmBXC,IAAAA,OAAO,EAAE,EAnBE;AAoBXC,IAAAA,IAAI,EAAE,EApBK;AAqBXC,IAAAA,GAAG,EAAE,EArBM;AAsBXC,IAAAA,cAAc,EAAE,EAtBL;AAuBXC,IAAAA,MAAM,EAAE,EAvBG;AAwBXC,IAAAA,OAAO,EAAE;AAxBE,GAAb;AA2BAxD,EAAAA,gBAAgB,GAAG;AACjB,UAAMD,UAAU,CAACuC,SADA;AAEjB,UAAMvC,UAAU,CAACwC,UAFA;AAGjB,SAAKxC,UAAU,CAACyC,SAHC;AAIjB,SAAKzC,UAAU,CAAC0C,UAJC;AAKjB,SAAK1C,UAAU,CAAC2C,UALC;AAMjB,UAAM3C,UAAU,CAAC4C,QANA;AAOjB,UAAM5C,UAAU,CAAC4C,QAPA;AAQjB,WAAO5C,UAAU,CAAC4C,QARD;AASjB,WAAO5C,UAAU,CAAC4C,QATD;AAUjBc,IAAAA,EAAE,EAAE1D,UAAU,CAAC4C,QAVE;AAWjBe,IAAAA,IAAI,EAAE3D,UAAU,CAAC4C,QAXA;AAYjB,SAAK5C,UAAU,CAAC6C,UAZC;AAajB,SAAK7C,UAAU,CAAC6C,UAbC;AAcjB,UAAM7C,UAAU,CAAC6C,UAdA;AAejB,UAAM7C,UAAU,CAAC6C,UAfA;AAgBjBe,IAAAA,EAAE,EAAE5D,UAAU,CAAC6C,UAhBE;AAiBjBgB,IAAAA,UAAU,EAAE7D,UAAU,CAAC6C,UAjBN;AAkBjB,UAAM7C,UAAU,CAAC8C,YAlBA;AAmBjB,UAAM9C,UAAU,CAAC8C,YAnBA;AAoBjB,WAAO9C,UAAU,CAAC8C,YApBD;AAqBjB,SAAK9C,UAAU,CAAC+C,QArBC;AAsBjB,SAAK/C,UAAU,CAAC+C,QAtBC;AAuBjB,SAAK/C,UAAU,CAACgD,cAvBC;AAwBjB,SAAKhD,UAAU,CAACgD,cAxBC;AAyBjB,SAAKhD,UAAU,CAACgD,cAzBC;AA0BjB,UAAMhD,UAAU,CAACiD;AA1BA,GAAnB,CAxEU,CAqGV;;AACA,MAAIa,UAAU,GAAG,CAAjB;AAAA,MACEC,YAAY,GAAG,KAAK,CADtB;AAAA,MAEEC,oBAAoB,GAAG,KAAK,CAF9B;AAAA,MAGEC,WAAW,GAAG,KAAK,CAHrB;AAAA,MAIEC,eAAe,GAAG,KAAK,CAJzB;AAAA,MAKEC,eAAe,GAAG,KAAK,CALzB,CAtGU,CA6GV;AACA;AACA;AACA;AACA;;AACA,MAAIC,KAAK,GAAGL,YAAY,GAAGC,oBAA3B;AAAA,MACEK,KAAK,GAAGP,UAAU,GAAGC,YADvB;AAAA,MAEEO,KAAK,GAAGR,UAAU,GAAGC,YAAb,GAA4BC,oBAFtC;AAAA,MAGEO,KAAK,GAAGT,UAHV;AAAA,MAIEU,KAAK,GAAGR,oBAJV;AAAA,MAKES,KAAK,GAAGX,UAAU,GAAGE,oBALvB,CAlHU,CAyHV;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIU,MAAM,GAAGZ,UAAb;AAAA,MACEa,MAAM,GAAGb,UAAU,GAAGK,eADxB;AAAA,MAEES,MAAM,GAAG,IAFX;AAAA,MAGEC,MAAM,GAAGf,UAAU,GAAGI,eAHxB;AAAA,MAIEY,MAAM,GAAGhB,UAAU,GAAGG,WAJxB;;AAMA,WAASc,iBAAT,GAA6B;AAC3B;AACA,WAAO;AACLzE,MAAAA,MAAM,EAAE,IADH;AAELD,MAAAA,IAAI,EAAE,IAFD;AAGLc,MAAAA,KAAK,EAAE,IAHF;AAIL6D,MAAAA,OAAO,EAAE,KAJJ;AAKLC,MAAAA,MAAM,EAAE;AACN3E,QAAAA,MAAM,EAAE;AACN4E,UAAAA,KAAK,EAAE,MADD;AAEN7E,UAAAA,IAAI,EAAE,CAFA;AAGN8E,UAAAA,sBAAsB,EAAE;AAHlB,SADF;AAMNvE,QAAAA,OAAO,EAAE,IANH;AAONC,QAAAA,KAAK,EAAE,GAPD;AAQNN,QAAAA,IAAI,EAAE,KARA;AASNC,QAAAA,QAAQ,EAAE,KATJ;AAUNC,QAAAA,WAAW,EAAE,KAVP;AAWNC,QAAAA,MAAM,EAAE,QAXF;AAYNC,QAAAA,UAAU,EAAE,KAZN;AAaNyE,QAAAA,OAAO,EAAE,KAbH;AAcNtE,QAAAA,WAAW,EAAE,IAdP;AAeNC,QAAAA,UAAU,EAAE,IAfN;AAgBNC,QAAAA,iBAAiB,EAAE,KAhBb;AAiBNM,QAAAA,kBAAkB,EAAE;AAjBd,OALH;AAwBL+D,MAAAA,GAAG,EAAE;AACHC,QAAAA,2CAA2C,EAAE,KAD1C;AAEHC,QAAAA,iBAAiB,EAAE;AAFhB,OAxBA;AA4BLnE,MAAAA,SAAS,EAAE,IA5BN;AA6BLoE,MAAAA,aAAa,EAAE,IA7BV;AA8BLC,MAAAA,iBAAiB,EAAE,KA9Bd;AA+BLxE,MAAAA,SAAS,EAAE,KA/BN;AAgCLyE,MAAAA,GAAG,EAAE,IAhCA;AAiCLC,MAAAA,QAAQ,EAAE,IAjCL;AAkCLtE,MAAAA,UAAU,EAAE;AAlCP,KAAP;AAoCD;;AAED,WAASuE,YAAT,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;AAC9B,QAAIC,MAAM,GAAG,EAAb;;AAEA,SAAKD,GAAG,IAAI,CAAZ,EAAeA,GAAG,GAAG,CAArB,EAAwBA,GAAG,MAAM,CAAT,EAAYD,GAAG,IAAIA,GAA3C,EAAgD;AAC9C,UAAIC,GAAG,GAAG,CAAV,EAAa;AACXC,QAAAA,MAAM,IAAIF,GAAV;AACD;AACF;;AAED,WAAOE,MAAP;AACD;;AAED,WAASC,iBAAT,CAA2BH,GAA3B,EAAgC;AAC9B,WAAO,UAAUI,IAAV,CAAeJ,GAAf,CAAP;AACD;;AAED,WAASK,sBAAT,CAAgCL,GAAhC,EAAqC;AACnC,QAAIM,GAAG,GAAGN,GAAG,CAACO,MAAd;AACA,WAAOD,GAAG,IAAI/F,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BT,GAAG,CAACU,UAAJ,CAAeJ,GAAG,GAAG,CAArB,CAA9B,CAAd;AACD;;AAED,WAASK,KAAT,CAAeC,MAAf,EAAuBC,QAAvB,EAAiC;AAC/B,QAAIC,GAAJ;;AACA,SAAKA,GAAL,IAAYD,QAAZ,EAAsB;AACpB,UAAIA,QAAQ,CAAC5E,cAAT,CAAwB6E,GAAxB,CAAJ,EAAkC;AAChCF,QAAAA,MAAM,CAACE,GAAD,CAAN,GAAcD,QAAQ,CAACC,GAAD,CAAtB;AACD;AACF;;AACD,WAAOF,MAAP;AACD;;AAED,WAASG,YAAT,CAAsBH,MAAtB,EAA8BC,QAA9B,EAAwC;AACtC,QAAIC,GAAJ,EAASE,GAAT;;AAEA,aAASC,YAAT,CAAsBL,MAAtB,EAA8B;AAC5B,aACE,OAAOA,MAAP,KAAkB,QAAlB,IACAA,MAAM,YAAYM,MADlB,IAEA,EAAEN,MAAM,YAAYO,MAApB,CAHF;AAKD;;AAED,SAAKL,GAAL,IAAYD,QAAZ,EAAsB;AACpB,UAAIA,QAAQ,CAAC5E,cAAT,CAAwB6E,GAAxB,CAAJ,EAAkC;AAChCE,QAAAA,GAAG,GAAGH,QAAQ,CAACC,GAAD,CAAd;;AACA,YAAIG,YAAY,CAACD,GAAD,CAAhB,EAAuB;AACrB,cAAIC,YAAY,CAACL,MAAM,CAACE,GAAD,CAAP,CAAhB,EAA+B;AAC7BC,YAAAA,YAAY,CAACH,MAAM,CAACE,GAAD,CAAP,EAAcE,GAAd,CAAZ;AACD,WAFD,MAEO;AACLJ,YAAAA,MAAM,CAACE,GAAD,CAAN,GAAcC,YAAY,CAAC,EAAD,EAAKC,GAAL,CAA1B;AACD;AACF,SAND,MAMO;AACLJ,UAAAA,MAAM,CAACE,GAAD,CAAN,GAAcE,GAAd;AACD;AACF;AACF;;AACD,WAAOJ,MAAP;AACD;;AAED,WAASQ,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,QAAInB,MAAJ,EAAYoB,KAAZ,EAAmBC,IAAnB,EAAyBC,QAAzB,EAAmCC,GAAnC,CAD6B,CAG7B;;AACA,QAAIJ,KAAK,KAAKA,KAAd,EAAqB;AACnB,YAAM,IAAIK,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,QAAIL,KAAK,GAAG,CAAR,IAAcA,KAAK,KAAK,CAAV,IAAe,IAAIA,KAAJ,GAAY,CAA7C,EAAiD;AAC/C,YAAM,IAAIK,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,QAAIL,KAAK,KAAK,IAAI,CAAlB,EAAqB;AACnB,aAAO3G,IAAI,GAAG,MAAH,GAAYC,QAAQ,GAAG,OAAH,GAAa,QAA5C;AACD;;AAEDuF,IAAAA,MAAM,GAAG,KAAKmB,KAAd;;AACA,QAAI,CAAC1G,QAAD,IAAauF,MAAM,CAACK,MAAP,GAAgB,CAAjC,EAAoC;AAClC,aAAOL,MAAP;AACD;;AAEDoB,IAAAA,KAAK,GAAGpB,MAAM,CAACyB,OAAP,CAAe,GAAf,CAAR;;AACA,QAAI,CAACjH,IAAD,IAASwF,MAAM,CAACQ,UAAP,CAAkB,CAAlB,MAAyB;AAAK;AAAvC,OAAkDY,KAAK,KAAK,CAAhE,EAAmE;AACjEA,MAAAA,KAAK,GAAG,CAAR;AACApB,MAAAA,MAAM,GAAGA,MAAM,CAAC0B,KAAP,CAAa,CAAb,CAAT;AACD;;AACDL,IAAAA,IAAI,GAAGrB,MAAP;AACAA,IAAAA,MAAM,GAAGA,MAAM,CAAC2B,OAAP,CAAe,IAAf,EAAqB,GAArB,CAAT;AACAL,IAAAA,QAAQ,GAAG,CAAX;;AACA,QAAI,CAACC,GAAG,GAAGF,IAAI,CAACI,OAAL,CAAa,GAAb,CAAP,IAA4B,CAAhC,EAAmC;AACjCH,MAAAA,QAAQ,GAAG,CAACD,IAAI,CAACK,KAAL,CAAWH,GAAG,GAAG,CAAjB,CAAZ;AACAF,MAAAA,IAAI,GAAGA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcH,GAAd,CAAP;AACD;;AACD,QAAIH,KAAK,IAAI,CAAb,EAAgB;AACdE,MAAAA,QAAQ,IAAID,IAAI,CAAChB,MAAL,GAAce,KAAd,GAAsB,CAAlC;AACAC,MAAAA,IAAI,GAAG,EAAEA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcN,KAAd,IAAuBC,IAAI,CAACK,KAAL,CAAWN,KAAK,GAAG,CAAnB,CAAzB,IAAkD,EAAzD;AACD;;AACDG,IAAAA,GAAG,GAAG,CAAN;;AACA,WAAOF,IAAI,CAACb,UAAL,CAAgBa,IAAI,CAAChB,MAAL,GAAckB,GAAd,GAAoB,CAApC,MAA2C;AAAK;AAAvD,MAAgE;AAC9D,QAAEA,GAAF;AACD;;AACD,QAAIA,GAAG,KAAK,CAAZ,EAAe;AACbD,MAAAA,QAAQ,IAAIC,GAAZ;AACAF,MAAAA,IAAI,GAAGA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcH,GAAd,CAAP;AACD;;AACD,QAAID,QAAQ,KAAK,CAAjB,EAAoB;AAClBD,MAAAA,IAAI,IAAI,MAAMC,QAAd;AACD;;AACD,QACE,CAACD,IAAI,CAAChB,MAAL,GAAcL,MAAM,CAACK,MAArB,IACE3F,WAAW,IACVyG,KAAK,GAAG,IADT,IAECS,IAAI,CAACC,KAAL,CAAWV,KAAX,MAAsBA,KAFvB,IAGC,CAACE,IAAI,GAAG,OAAOF,KAAK,CAACW,QAAN,CAAe,EAAf,CAAf,EAAmCzB,MAAnC,GAA4CL,MAAM,CAACK,MAJvD,KAKA,CAACgB,IAAD,KAAUF,KANZ,EAOE;AACAnB,MAAAA,MAAM,GAAGqB,IAAT;AACD;;AAED,WAAOrB,MAAP;AACD,GAnSS,CAqSV;AACA;;;AAEA,WAAS+B,qBAAT,CAA+BC,EAA/B,EAAmCC,mBAAnC,EAAwD;AACtD;AACA,QAAI,CAACD,EAAE,GAAG,CAAC,CAAP,MAAc,MAAlB,EAA0B;AACxB,aACE,CAACC,mBAAmB,GAAG,GAAH,GAAS,KAA7B,KAAuCD,EAAE,KAAK,MAAP,GAAgB,MAAhB,GAAyB,MAAhE,CADF;AAGD,KAJD,MAIO,IAAIA,EAAE,KAAK,EAAP,IAAaA,EAAE,KAAK,EAAxB,EAA4B;AACjC;AACA,aAAO,CAACC,mBAAmB,GAAG,EAAH,GAAQ,IAA5B,KAAqCD,EAAE,KAAK,EAAP,GAAY,GAAZ,GAAkB,GAAvD,CAAP;AACD;;AACD,WAAOE,MAAM,CAACC,YAAP,CAAoBH,EAApB,CAAP;AACD;;AAED,WAASI,cAAT,CAAwBC,GAAxB,EAA6B;AAC3B,QAAIC,KAAJ,EAAWtC,MAAX,EAAmBuC,KAAnB,EAA0BC,CAA1B,EAA6BC,EAA7B,EAAiCT,EAAjC,EAAqCU,gBAArC,EAAuDT,mBAAvD;AAEAjC,IAAAA,MAAM,GAAGqC,GAAG,CAACP,QAAJ,EAAT;;AAEA,QAAIO,GAAG,CAACM,MAAR,EAAgB;AACd;AACAL,MAAAA,KAAK,GAAGtC,MAAM,CAACsC,KAAP,CAAa,YAAb,CAAR;;AACA,UAAI,CAACA,KAAL,EAAY;AACV,eAAOtC,MAAP;AACD;;AAEDuC,MAAAA,KAAK,GAAGD,KAAK,CAAC,CAAD,CAAb;AACAtC,MAAAA,MAAM,GAAG,EAAT;AAEA0C,MAAAA,gBAAgB,GAAG,KAAnB;AACAT,MAAAA,mBAAmB,GAAG,KAAtB;;AACA,WAAKO,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGJ,GAAG,CAACM,MAAJ,CAAWtC,MAA5B,EAAoCmC,CAAC,GAAGC,EAAxC,EAA4C,EAAED,CAA9C,EAAiD;AAC/CR,QAAAA,EAAE,GAAGK,GAAG,CAACM,MAAJ,CAAWnC,UAAX,CAAsBgC,CAAtB,CAAL;;AAEA,YAAI,CAACP,mBAAL,EAA0B;AACxB,cAAIS,gBAAJ,EAAsB;AACpB,gBAAIV,EAAE,KAAK,EAAX,EAAe;AACb;AACAU,cAAAA,gBAAgB,GAAG,KAAnB;AACD;AACF,WALD,MAKO;AACL,gBAAIV,EAAE,KAAK,EAAX,EAAe;AACb;AACAhC,cAAAA,MAAM,IAAI,IAAV;AACD,aAHD,MAGO,IAAIgC,EAAE,KAAK,EAAX,EAAe;AACpB;AACAU,cAAAA,gBAAgB,GAAG,IAAnB;AACD;AACF;;AACD1C,UAAAA,MAAM,IAAI+B,qBAAqB,CAACC,EAAD,EAAKC,mBAAL,CAA/B;AACAA,UAAAA,mBAAmB,GAAGD,EAAE,KAAK,EAA7B,CAhBwB,CAgBS;AAClC,SAjBD,MAiBO;AACL;AACAhC,UAAAA,MAAM,IAAI+B,qBAAqB,CAACC,EAAD,EAAKC,mBAAL,CAA/B,CAFK,CAGL;;AACAA,UAAAA,mBAAmB,GAAG,KAAtB;AACD;AACF;;AAED,aAAO,MAAMjC,MAAN,GAAe,GAAf,GAAqBuC,KAA5B;AACD;;AAED,WAAOvC,MAAP;AACD;;AAED,WAAS4C,sBAAT,CAAgCtC,IAAhC,EAAsCuC,IAAtC,EAA4C;AAC1C,QAAIC,GAAJ;;AAEA,QAAIxC,IAAI,KAAK;AAAK;AAAlB,MAA4B;AAC1B,aAAO,KAAP;AACD;;AAED,QAAIA,IAAI,KAAK;AAAK;AAAlB,MAA4B;AAC1B,aAAO,KAAP;AACD;;AAED,QAAIA,IAAI,KAAK;AAAK;AAAlB,MAA4B;AAC1B,aAAO,KAAP;AACD;;AAEDwC,IAAAA,GAAG,GAAGxC,IAAI,CAACwB,QAAL,CAAc,EAAd,EAAkBiB,WAAlB,EAAN;;AACA,QAAIvI,IAAI,IAAI8F,IAAI,GAAG,IAAnB,EAAyB;AACvB,aAAO,QAAQ,OAAOoB,KAAP,CAAaoB,GAAG,CAACzC,MAAjB,CAAR,GAAmCyC,GAA1C;AACD,KAFD,MAEO,IAAIxC,IAAI,KAAK,MAAT,IAAmB,CAACjG,OAAO,CAACiG,IAAR,CAAa0C,cAAb,CAA4BH,IAA5B,CAAxB,EAA2D;AAChE,aAAO,KAAP;AACD,KAFM,MAEA,IAAIvC,IAAI,KAAK;AAAO;AAApB,MAA8B;AACnC;AACA,aAAO,OAAP;AACD,KAHM,MAGA;AACL,aAAO,QAAQ,KAAKoB,KAAL,CAAWoB,GAAG,CAACzC,MAAf,CAAR,GAAiCyC,GAAxC;AACD;AACF;;AAED,WAASG,yBAAT,CAAmC3C,IAAnC,EAAyC;AACvC,QAAIA,IAAI,KAAK;AAAK;AAAlB,MAA2B;AACzB,aAAO,MAAP;AACD;;AAED,QAAIA,IAAI,KAAK;AAAK;AAAlB,MAA4B;AAC1B,aAAO,KAAP;AACD;;AAED,QAAIA,IAAI,KAAK;AAAK;AAAlB,MAA4B;AAC1B,aAAO,KAAP;AACD;;AAED,QAAIA,IAAI,KAAK,MAAb,EAAqB;AACnB,aAAO,SAAP;AACD;;AAED,QAAIA,IAAI,KAAK,MAAb,EAAqB;AACnB,aAAO,SAAP;AACD;;AAED,UAAM,IAAIkB,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAED,WAAS0B,eAAT,CAAyBpD,GAAzB,EAA8B;AAC5B,QAAI0C,CAAJ,EAAOC,EAAP,EAAWnC,IAAX,EAAiB6C,KAAjB;AAEAA,IAAAA,KAAK,GAAGxI,MAAM,KAAK,QAAX,GAAsB,GAAtB,GAA4B,GAApC;;AACA,SAAK6H,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAG3C,GAAG,CAACO,MAArB,EAA6BmC,CAAC,GAAGC,EAAjC,EAAqC,EAAED,CAAvC,EAA0C;AACxClC,MAAAA,IAAI,GAAGR,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAAP;;AACA,UAAIlC,IAAI,KAAK;AAAK;AAAlB,QAA2B;AACzB6C,QAAAA,KAAK,GAAG,GAAR;AACA;AACD,OAHD,MAGO,IAAI7C,IAAI,KAAK;AAAK;AAAlB,QAA2B;AAChC6C,QAAAA,KAAK,GAAG,GAAR;AACA;AACD,OAHM,MAGA,IAAI7C,IAAI,KAAK;AAAK;AAAlB,QAA2B;AAChC,UAAEkC,CAAF;AACD;AACF;;AAED,WAAOW,KAAK,GAAGrD,GAAR,GAAcqD,KAArB;AACD;;AAED,WAASC,YAAT,CAAsBtD,GAAtB,EAA2B;AACzB,QAAIE,MAAM,GAAG,EAAb;AAAA,QACEwC,CADF;AAAA,QAEEpC,GAFF;AAAA,QAGEE,IAHF;AAAA,QAIE+C,YAAY,GAAG,CAJjB;AAAA,QAKEC,YAAY,GAAG,CALjB;AAAA,QAMEC,MANF;AAAA,QAOEJ,KAPF;;AASA,SAAKX,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGN,GAAG,CAACO,MAAtB,EAA8BmC,CAAC,GAAGpC,GAAlC,EAAuC,EAAEoC,CAAzC,EAA4C;AAC1ClC,MAAAA,IAAI,GAAGR,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAAP;;AACA,UAAIlC,IAAI,KAAK;AAAK;AAAlB,QAA2B;AACzB,UAAE+C,YAAF;AACD,OAFD,MAEO,IAAI/C,IAAI,KAAK;AAAK;AAAlB,QAA2B;AAChC,UAAEgD,YAAF;AACD,OAFM,MAEA,IAAIhD,IAAI,KAAK;AAAK;AAAd,SAAyB9F,IAA7B,EAAmC;AACxCwF,QAAAA,MAAM,IAAI,IAAV;AACD,OAFM,MAEA,IAAI3F,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,KAAuCA,IAAI,KAAK;AAAK;AAAzD,QAAkE;AACvEN,QAAAA,MAAM,IAAIiD,yBAAyB,CAAC3C,IAAD,CAAnC;AACA;AACD,OAHM,MAGA,IACL,CAACjG,OAAO,CAACiG,IAAR,CAAakD,mBAAb,CAAiClD,IAAjC,CAAD,KACE9F,IAAI,IAAI8F,IAAI,GAAG;AAAM;AAAtB,SACE,CAAC9F,IAAD,IACC,CAACI,UADF,KAEE0F,IAAI,GAAG;AAAK;AAAZ,SAAwBA,IAAI,GAAG,IAFjC,CAFH;AAI4C;AALvC,QAML;AACAN,QAAAA,MAAM,IAAI4C,sBAAsB,CAACtC,IAAD,EAAOR,GAAG,CAACU,UAAJ,CAAegC,CAAC,GAAG,CAAnB,CAAP,CAAhC;AACA;AACD;;AACDxC,MAAAA,MAAM,IAAIkC,MAAM,CAACC,YAAP,CAAoB7B,IAApB,CAAV;AACD;;AAEDiD,IAAAA,MAAM,GAAG,EACP5I,MAAM,KAAK,QAAX,IACCA,MAAM,KAAK,MAAX,IAAqB2I,YAAY,GAAGD,YAF9B,CAAT;AAIAF,IAAAA,KAAK,GAAGI,MAAM,GAAG,GAAH,GAAS,GAAvB;;AAEA,QAAI,EAAEA,MAAM,GAAGF,YAAH,GAAkBC,YAA1B,CAAJ,EAA6C;AAC3C,aAAOH,KAAK,GAAGnD,MAAR,GAAiBmD,KAAxB;AACD;;AAEDrD,IAAAA,GAAG,GAAGE,MAAN;AACAA,IAAAA,MAAM,GAAGmD,KAAT;;AAEA,SAAKX,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGN,GAAG,CAACO,MAAtB,EAA8BmC,CAAC,GAAGpC,GAAlC,EAAuC,EAAEoC,CAAzC,EAA4C;AAC1ClC,MAAAA,IAAI,GAAGR,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAAP;;AACA,UACGlC,IAAI,KAAK;AAAK;AAAd,SAAyBiD,MAA1B,IACCjD,IAAI,KAAK;AAAK;AAAd,SAAyB,CAACiD,MAF7B,EAGE;AACAvD,QAAAA,MAAM,IAAI,IAAV;AACD;;AACDA,MAAAA,MAAM,IAAIkC,MAAM,CAACC,YAAP,CAAoB7B,IAApB,CAAV;AACD;;AAED,WAAON,MAAM,GAAGmD,KAAhB;AACD;AAED;AACF;AACA;AACA;;;AACE,WAASM,eAAT,CAAyBC,GAAzB,EAA8B;AAC5B,QAAIlB,CAAJ;AAAA,QACEC,EADF;AAAA,QAEEkB,IAFF;AAAA,QAGE3D,MAAM,GAAG,EAHX;;AAIA,SAAKwC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGiB,GAAG,CAACrD,MAArB,EAA6BmC,CAAC,GAAGC,EAAjC,EAAqC,EAAED,CAAvC,EAA0C;AACxCmB,MAAAA,IAAI,GAAGD,GAAG,CAAClB,CAAD,CAAV;AACAxC,MAAAA,MAAM,IAAI4D,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBF,eAAe,CAACE,IAAD,CAArC,GAA8CA,IAAxD;AACD;;AACD,WAAO3D,MAAP;AACD;AAED;AACF;AACA;;;AACE,WAAS8D,sBAAT,CAAgCC,SAAhC,EAA2CnI,IAA3C,EAAiD;AAC/C,QAAI,CAACP,SAAL,EAAgB;AACd;AACA;AACA;AACA,UAAIuI,KAAK,CAACC,OAAN,CAAcE,SAAd,CAAJ,EAA8B;AAC5B,eAAON,eAAe,CAACM,SAAD,CAAtB;AACD,OAFD,MAEO;AACL,eAAOA,SAAP;AACD;AACF;;AACD,QAAInI,IAAI,IAAI,IAAZ,EAAkB;AAChB,UAAImI,SAAS,YAAY5J,UAAzB,EAAqC;AACnC,eAAO4J,SAAP;AACD,OAFD,MAEO;AACLnI,QAAAA,IAAI,GAAG,EAAP;AACD;AACF;;AACD,QAAIA,IAAI,CAACoI,GAAL,IAAY,IAAhB,EAAsB;AACpB,aAAO,IAAI7J,UAAJ,CACL,IADK,EAEL,IAFK,EAGLkB,SAHK,EAIL0I,SAJK,EAKLnI,IAAI,CAACqI,IAAL,IAAa,IALR,CAAP;AAOD;;AACD,WAAO,IAAI9J,UAAJ,CACLyB,IAAI,CAACoI,GAAL,CAASE,KAAT,CAAeC,IADV,EAELvI,IAAI,CAACoI,GAAL,CAASE,KAAT,CAAeE,MAFV,EAGL/I,SAAS,KAAK,IAAd,GAAqBO,IAAI,CAACoI,GAAL,CAASrB,MAAT,IAAmB,IAAxC,GAA+CtH,SAH1C,EAIL0I,SAJK,EAKLnI,IAAI,CAACqI,IAAL,IAAa,IALR,CAAP;AAOD;;AAED,WAASI,YAAT,GAAwB;AACtB,WAAOvJ,KAAK,GAAGA,KAAH,GAAW,GAAvB;AACD;;AAED,WAASwJ,IAAT,CAAcC,IAAd,EAAoBC,KAApB,EAA2B;AACzB,QAAIC,UAAJ,EAAgBC,WAAhB,EAA6BC,YAA7B,EAA2CC,aAA3C;AAEAH,IAAAA,UAAU,GAAGX,sBAAsB,CAACS,IAAD,CAAtB,CAA6BzC,QAA7B,EAAb;;AACA,QAAI2C,UAAU,CAACpE,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,aAAO,CAACmE,KAAD,CAAP;AACD;;AAEDE,IAAAA,WAAW,GAAGZ,sBAAsB,CAACU,KAAD,CAAtB,CAA8B1C,QAA9B,EAAd;;AACA,QAAI4C,WAAW,CAACrE,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,aAAO,CAACkE,IAAD,CAAP;AACD;;AAEDI,IAAAA,YAAY,GAAGF,UAAU,CAACjE,UAAX,CAAsBiE,UAAU,CAACpE,MAAX,GAAoB,CAA1C,CAAf;AACAuE,IAAAA,aAAa,GAAGF,WAAW,CAAClE,UAAZ,CAAuB,CAAvB,CAAhB;;AAEA,QACG,CAACmE,YAAY,KAAK;AAAK;AAAtB,OAAiCA,YAAY,KAAK;AAAM;AAAzD,SACCA,YAAY,KAAKC,aADnB,IAECvK,OAAO,CAACiG,IAAR,CAAakD,mBAAb,CAAiCmB,YAAjC,KACCtK,OAAO,CAACiG,IAAR,CAAakD,mBAAb,CAAiCoB,aAAjC,CAHF,IAICD,YAAY,KAAK;AAAK;AAAtB,OAAiCC,aAAa,KAAK;AAAM;AAL5D,MAME;AACA;AACA,aAAO,CAACL,IAAD,EAAOF,YAAY,EAAnB,EAAuBG,KAAvB,CAAP;AACD,KATD,MASO,IACLnK,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BF,YAA1B,KACAtK,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BoE,YAA9B,CADA,IAEAtK,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BD,aAA1B,CAFA,IAGAvK,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BqE,aAA9B,CAJK,EAKL;AACA,aAAO,CAACL,IAAD,EAAOC,KAAP,CAAP;AACD;;AACD,WAAO,CAACD,IAAD,EAAOzJ,KAAP,EAAc0J,KAAd,CAAP;AACD;;AAED,WAASM,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,WAAO,CAACzK,IAAD,EAAOyK,IAAP,CAAP;AACD;;AAED,WAASC,UAAT,CAAoBC,EAApB,EAAwB;AACtB,QAAIC,YAAJ;AACAA,IAAAA,YAAY,GAAG5K,IAAf;AACAA,IAAAA,IAAI,IAAIC,MAAR;AACA0K,IAAAA,EAAE,CAAC3K,IAAD,CAAF;AACAA,IAAAA,IAAI,GAAG4K,YAAP;AACD;;AAED,WAASC,eAAT,CAAyBrF,GAAzB,EAA8B;AAC5B,QAAI0C,CAAJ;;AACA,SAAKA,CAAC,GAAG1C,GAAG,CAACO,MAAJ,GAAa,CAAtB,EAAyBmC,CAAC,IAAI,CAA9B,EAAiC,EAAEA,CAAnC,EAAsC;AACpC,UAAInI,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BT,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAA9B,CAAJ,EAAsD;AACpD;AACD;AACF;;AACD,WAAO1C,GAAG,CAACO,MAAJ,GAAa,CAAb,GAAiBmC,CAAxB;AACD;;AAED,WAASpD,sBAAT,CAAgC+B,KAAhC,EAAuCiE,WAAvC,EAAoD;AAClD,QAAIC,KAAJ,EAAW7C,CAAX,EAAcpC,GAAd,EAAmB+D,IAAnB,EAAyBmB,CAAzB,EAA4BC,MAA5B,EAAoCL,YAApC,EAAkDM,EAAlD;AAEAH,IAAAA,KAAK,GAAGlE,KAAK,CAACsE,KAAN,CAAY,aAAZ,CAAR;AACAF,IAAAA,MAAM,GAAGG,MAAM,CAACC,SAAhB,CAJkD,CAMlD;;AACA,SAAKnD,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGiF,KAAK,CAAChF,MAAxB,EAAgCmC,CAAC,GAAGpC,GAApC,EAAyC,EAAEoC,CAA3C,EAA8C;AAC5C2B,MAAAA,IAAI,GAAGkB,KAAK,CAAC7C,CAAD,CAAZ;AACA8C,MAAAA,CAAC,GAAG,CAAJ;;AACA,aAAOA,CAAC,GAAGnB,IAAI,CAAC9D,MAAT,IAAmBhG,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BV,IAAI,CAAC3D,UAAL,CAAgB8E,CAAhB,CAA1B,CAA1B,EAAyE;AACvE,UAAEA,CAAF;AACD;;AACD,UAAIC,MAAM,GAAGD,CAAb,EAAgB;AACdC,QAAAA,MAAM,GAAGD,CAAT;AACD;AACF;;AAED,QAAI,OAAOF,WAAP,KAAuB,WAA3B,EAAwC;AACtC;AACA;AACA;AACA;AACA;AACA;AACAF,MAAAA,YAAY,GAAG5K,IAAf;;AACA,UAAI+K,KAAK,CAAC,CAAD,CAAL,CAASE,MAAT,MAAqB,GAAzB,EAA8B;AAC5BH,QAAAA,WAAW,IAAI,GAAf;AACD;;AACD9K,MAAAA,IAAI,GAAG8K,WAAP;AACD,KAZD,MAYO;AACL,UAAIG,MAAM,GAAG,CAAb,EAAgB;AACd;AACA;AACA;AACA;AACA;AACA,UAAEA,MAAF;AACD;;AACDL,MAAAA,YAAY,GAAG5K,IAAf;AACD;;AAED,SAAKkI,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGiF,KAAK,CAAChF,MAAxB,EAAgCmC,CAAC,GAAGpC,GAApC,EAAyC,EAAEoC,CAA3C,EAA8C;AAC5CgD,MAAAA,EAAE,GAAG1B,sBAAsB,CAACgB,SAAS,CAACO,KAAK,CAAC7C,CAAD,CAAL,CAASd,KAAT,CAAe6D,MAAf,CAAD,CAAV,CAA3B;AACAF,MAAAA,KAAK,CAAC7C,CAAD,CAAL,GAAWnH,SAAS,GAAGmK,EAAE,CAAClB,IAAH,CAAQ,EAAR,CAAH,GAAiBkB,EAArC;AACD;;AAEDlL,IAAAA,IAAI,GAAG4K,YAAP;AAEA,WAAOG,KAAK,CAACf,IAAN,CAAW,IAAX,CAAP;AACD;;AAED,WAASsB,eAAT,CAAyB3G,OAAzB,EAAkCmG,WAAlC,EAA+C;AAC7C,QAAInG,OAAO,CAACjD,IAAR,KAAiB,MAArB,EAA6B;AAC3B,UAAImE,sBAAsB,CAAClB,OAAO,CAACkC,KAAT,CAA1B,EAA2C;AACzC,eAAO,OAAOlC,OAAO,CAACkC,KAAtB;AACD,OAFD,MAEO;AACL;AACA,YAAInB,MAAM,GAAG,OAAOf,OAAO,CAACkC,KAA5B;;AACA,YAAI,CAAC5F,kBAAL,EAAyB;AACvByE,UAAAA,MAAM,IAAI,IAAV;AACD;;AACD,eAAOA,MAAP;AACD;AACF;;AACD,QACE7E,KAAK,CAAC+D,MAAN,CAAa3E,MAAb,CAAoB6E,sBAApB,IACA,SAASc,IAAT,CAAcjB,OAAO,CAACkC,KAAtB,CAFF,EAGE;AACA,aAAO/B,sBAAsB,CAAC,OAAOH,OAAO,CAACkC,KAAf,GAAuB,IAAxB,EAA8BiE,WAA9B,CAA7B;AACD;;AACD,WAAO,OAAOnG,OAAO,CAACkC,KAAf,GAAuB,IAA9B;AACD;;AAED,WAAS0E,WAAT,CAAqBd,IAArB,EAA2B/E,MAA3B,EAAmC;AACjC,QAAIwC,CAAJ,EACEpC,GADF,EAEEnB,OAFF,EAGE6G,IAHF,EAIEC,kBAJF,EAKEX,WALF,EAMEY,QANF,EAOEC,QAPF,EAQEC,KARF,EASEC,SATF,EAUEC,MAVF,EAWEC,KAXF,EAYEC,MAZF,EAaEC,KAbF;;AAeA,QAAIxB,IAAI,CAACyB,eAAL,IAAwBzB,IAAI,CAACyB,eAAL,CAAqBnG,MAArB,GAA8B,CAA1D,EAA6D;AAC3DyF,MAAAA,IAAI,GAAG9F,MAAP;;AAEA,UAAIzE,kBAAJ,EAAwB;AACtB0D,QAAAA,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqB,CAArB,CAAV;AACAxG,QAAAA,MAAM,GAAG,EAAT;AAEAiG,QAAAA,QAAQ,GAAGhH,OAAO,CAACwH,aAAnB;AACAP,QAAAA,KAAK,GAAGjH,OAAO,CAACiH,KAAhB;AAEAE,QAAAA,MAAM,GAAG9K,UAAU,CAACoL,SAAX,CAAqBT,QAAQ,CAAC,CAAD,CAA7B,EAAkCC,KAAK,CAAC,CAAD,CAAvC,CAAT;AACAK,QAAAA,KAAK,GAAG,CAACH,MAAM,CAAC9D,KAAP,CAAa,KAAb,KAAuB,EAAxB,EAA4BjC,MAApC;;AACA,YAAIkG,KAAK,GAAG,CAAZ,EAAe;AACbvG,UAAAA,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;AACAvG,UAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAArB;AACD,SAHD,MAGO;AACLe,UAAAA,MAAM,CAAC2G,IAAP,CAAYP,MAAZ;AACApG,UAAAA,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,CAA3B;AACD;;AAEDkH,QAAAA,SAAS,GAAGD,KAAZ;;AAEA,aAAK1D,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAG2E,IAAI,CAACyB,eAAL,CAAqBnG,MAAvC,EAA+CmC,CAAC,GAAGpC,GAAnD,EAAwDoC,CAAC,EAAzD,EAA6D;AAC3DvD,UAAAA,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqBhE,CAArB,CAAV;AACA0D,UAAAA,KAAK,GAAGjH,OAAO,CAACiH,KAAhB;AAEAG,UAAAA,KAAK,GAAG/K,UAAU,CAACoL,SAAX,CAAqBP,SAAS,CAAC,CAAD,CAA9B,EAAmCD,KAAK,CAAC,CAAD,CAAxC,CAAR;AACAK,UAAAA,KAAK,GAAG,CAACF,KAAK,CAAC/D,KAAN,CAAY,KAAZ,KAAsB,EAAvB,EAA2BjC,MAAnC;AACAL,UAAAA,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;AACAvG,UAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAArB;AAEAkH,UAAAA,SAAS,GAAGD,KAAZ;AACD;;AAEDI,QAAAA,MAAM,GAAGhL,UAAU,CAACoL,SAAX,CAAqBR,KAAK,CAAC,CAAD,CAA1B,EAA+BD,QAAQ,CAAC,CAAD,CAAvC,CAAT;AACAM,QAAAA,KAAK,GAAG,CAACD,MAAM,CAAChE,KAAP,CAAa,KAAb,KAAuB,EAAxB,EAA4BjC,MAApC;AACAL,QAAAA,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;AACD,OAlCD,MAkCO;AACLtH,QAAAA,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqB,CAArB,CAAV;AACAxG,QAAAA,MAAM,GAAG,EAAT;;AACA,YACE/E,iBAAiB,IACjB8J,IAAI,CAAC/I,IAAL,KAAchC,MAAM,CAAC4M,OADrB,IAEA7B,IAAI,CAAC8B,IAAL,CAAUxG,MAAV,KAAqB,CAHvB,EAIE;AACAL,UAAAA,MAAM,CAAC2G,IAAP,CAAY,IAAZ;AACD;;AACD3G,QAAAA,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,CAA3B;;AACA,YACE,CAACkB,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CADzB,EAEE;AACA9B,UAAAA,MAAM,CAAC2G,IAAP,CAAY,IAAZ;AACD;;AAED,aAAKnE,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAG2E,IAAI,CAACyB,eAAL,CAAqBnG,MAAvC,EAA+CmC,CAAC,GAAGpC,GAAnD,EAAwD,EAAEoC,CAA1D,EAA6D;AAC3DvD,UAAAA,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqBhE,CAArB,CAAV;AACAwD,UAAAA,QAAQ,GAAG,CAACJ,eAAe,CAAC3G,OAAD,CAAhB,CAAX;;AACA,cACE,CAACkB,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CADzB,EAEE;AACAkE,YAAAA,QAAQ,CAACW,IAAT,CAAc,IAAd;AACD;;AACD3G,UAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACkB,QAAD,CAArB;AACD;AACF;;AAEDhG,MAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACgB,IAAD,CAArB;AACD;;AAED,QAAIf,IAAI,CAAC+B,gBAAT,EAA2B;AACzB,UAAIvL,kBAAJ,EAAwB;AACtB0D,QAAAA,OAAO,GAAG8F,IAAI,CAAC+B,gBAAL,CAAsB,CAAtB,CAAV;AACAb,QAAAA,QAAQ,GAAGhH,OAAO,CAACwH,aAAnB;AACAP,QAAAA,KAAK,GAAGjH,OAAO,CAACiH,KAAhB;AAEAE,QAAAA,MAAM,GAAG9K,UAAU,CAACoL,SAAX,CAAqBT,QAAQ,CAAC,CAAD,CAA7B,EAAkCC,KAAK,CAAC,CAAD,CAAvC,CAAT;AACAK,QAAAA,KAAK,GAAG,CAACH,MAAM,CAAC9D,KAAP,CAAa,KAAb,KAAuB,EAAxB,EAA4BjC,MAApC;;AAEA,YAAIkG,KAAK,GAAG,CAAZ,EAAe;AACbvG,UAAAA,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;AACAvG,UAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAArB;AACD,SAHD,MAGO;AACLe,UAAAA,MAAM,CAAC2G,IAAP,CAAYP,MAAZ;AACApG,UAAAA,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,CAA3B;AACD;AACF,OAfD,MAeO;AACL8G,QAAAA,kBAAkB,GAAG,CAAC5F,sBAAsB,CAC1C2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAD0C,CAA5C;AAGAsD,QAAAA,WAAW,GAAGvF,YAAY,CACxB,GADwB,EAExBsF,eAAe,CACbrB,sBAAsB,CAAC,CAACxJ,IAAD,EAAO0F,MAAP,EAAezF,MAAf,CAAD,CAAtB,CAA+CuH,QAA/C,EADa,CAFS,CAA1B;;AAMA,aAAKU,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAG2E,IAAI,CAAC+B,gBAAL,CAAsBzG,MAAxC,EAAgDmC,CAAC,GAAGpC,GAApD,EAAyD,EAAEoC,CAA3D,EAA8D;AAC5DvD,UAAAA,OAAO,GAAG8F,IAAI,CAAC+B,gBAAL,CAAsBtE,CAAtB,CAAV;;AACA,cAAIuD,kBAAJ,EAAwB;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAIvD,CAAC,KAAK,CAAV,EAAa;AACX;AACAxC,cAAAA,MAAM,GAAG,CAACA,MAAD,EAASzF,MAAT,CAAT;AACD,aAHD,MAGO;AACLyF,cAAAA,MAAM,GAAG,CAACA,MAAD,EAASoF,WAAT,CAAT;AACD;;AACDpF,YAAAA,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,EAAUmG,WAAV,CAA3B;AACD,WAbD,MAaO;AACLpF,YAAAA,MAAM,GAAG,CAACA,MAAD,EAAS8E,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAAlB,CAAT;AACD;;AACD,cACEuD,CAAC,KAAKpC,GAAG,GAAG,CAAZ,IACA,CAACD,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAFzB,EAGE;AACA9B,YAAAA,MAAM,GAAG,CAACA,MAAD,EAAS,IAAT,CAAT;AACD;AACF;AACF;AACF;;AAED,WAAOA,MAAP;AACD;;AAED,WAAS+G,kBAAT,CAA4B7C,KAA5B,EAAmC8C,GAAnC,EAAwChH,MAAxC,EAAgD;AAC9C,QAAIsF,CAAJ;AAAA,QACE2B,YAAY,GAAG,CADjB;;AAGA,SAAK3B,CAAC,GAAGpB,KAAT,EAAgBoB,CAAC,GAAG0B,GAApB,EAAyB1B,CAAC,EAA1B,EAA8B;AAC5B,UAAIhK,UAAU,CAACgK,CAAD,CAAV,KAAkB,IAAtB,EAA4B;AAC1B2B,QAAAA,YAAY;AACb;AACF;;AAED,SAAK3B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2B,YAAhB,EAA8B3B,CAAC,EAA/B,EAAmC;AACjCtF,MAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF;;AAED,WAASqM,YAAT,CAAsBC,IAAtB,EAA4BC,OAA5B,EAAqCC,MAArC,EAA6C;AAC3C,QAAID,OAAO,GAAGC,MAAd,EAAsB;AACpB,aAAO,CAAC,GAAD,EAAMF,IAAN,EAAY,GAAZ,CAAP;AACD;;AACD,WAAOA,IAAP;AACD;;AAED,WAASG,sBAAT,CAAgCC,MAAhC,EAAwC;AACtC,QAAI/E,CAAJ,EAAOC,EAAP,EAAWzC,MAAX;AACAA,IAAAA,MAAM,GAAGuH,MAAM,CAAC9B,KAAP,CAAa,SAAb,CAAT;;AACA,SAAKjD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGzC,MAAM,CAACK,MAAxB,EAAgCmC,CAAC,GAAGC,EAApC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3CxC,MAAAA,MAAM,CAACwC,CAAD,CAAN,GAAY3H,OAAO,GAAGP,IAAV,GAAiB0F,MAAM,CAACwC,CAAD,CAAnC;AACD;;AACD,WAAOxC,MAAP;AACD;;AAED,WAASwH,gBAAT,CAA0BC,IAA1B,EAAgCC,UAAhC,EAA4C;AAC1C,QAAI9H,QAAJ,EAAcI,MAAd,EAAsB2H,IAAtB;AACA/H,IAAAA,QAAQ,GAAG6H,IAAI,CAACtM,KAAK,CAACyE,QAAP,CAAf;;AAEA,QAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChCI,MAAAA,MAAM,GAAGkH,YAAY,CACnBI,sBAAsB,CAAC1H,QAAD,CADH,EAEnB3F,UAAU,CAACkC,QAFQ,EAGnBuL,UAHmB,CAArB;AAKD,KAND,MAMO;AACL;AACA1H,MAAAA,MAAM,GAAGsH,sBAAsB,CAAC1H,QAAQ,CAACgI,OAAV,CAA/B;AACAD,MAAAA,IAAI,GACF/H,QAAQ,CAAC8H,UAAT,IAAuB,IAAvB,GAA8B9H,QAAQ,CAAC8H,UAAvC,GAAoDzN,UAAU,CAACkC,QADjE;AAEA6D,MAAAA,MAAM,GAAGkH,YAAY,CAAClH,MAAD,EAAS2H,IAAT,EAAeD,UAAf,CAArB;AACD;;AAED,WAAO5D,sBAAsB,CAAC9D,MAAD,EAASyH,IAAT,CAA7B;AACD;;AAED,WAAS5L,aAAT,GAAyB,CAAE,CA92BjB,CAg3BV;;;AAEAA,EAAAA,aAAa,CAACgM,SAAd,CAAwBC,UAAxB,GAAqC,UAAS/C,IAAT,EAAexC,KAAf,EAAsB;AACzD,QAAIvC,MAAJ;AAAA,QACE+H,gBADF;AAAA,QAEEC,IAAI,GAAG,IAFT;AAIAD,IAAAA,gBAAgB,GAAG,CAAC5M,KAAK,CAAC8D,OAAP,IAAkB,CAAC8F,IAAI,CAACyB,eAA3C;;AAEA,QAAIzB,IAAI,CAAC/I,IAAL,KAAchC,MAAM,CAACiO,cAArB,IAAuCF,gBAA3C,EAA6D;AAC3D,aAAO,CAACjN,KAAD,EAAQ,KAAKoN,iBAAL,CAAuBnD,IAAvB,EAA6BxC,KAA7B,CAAR,CAAP;AACD;;AAED,QAAIwC,IAAI,CAAC/I,IAAL,KAAchC,MAAM,CAACmO,cAArB,IAAuCJ,gBAA3C,EAA6D;AAC3D,aAAO,GAAP;AACD;;AAED/C,IAAAA,UAAU,CAAC,YAAW;AACpBhF,MAAAA,MAAM,GAAG,CAACnF,OAAD,EAAUiK,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBnD,IAAvB,EAA6BxC,KAA7B,CAAD,CAAnB,CAAT;AACD,KAFS,CAAV;AAIA,WAAOvC,MAAP;AACD,GApBD;;AAsBAnE,EAAAA,aAAa,CAACgM,SAAd,CAAwBO,gBAAxB,GAA2C,UAASrD,IAAT,EAAe/E,MAAf,EAAuB;AAChE,QAAIqI,IAAI,GAAGlI,sBAAsB,CAC/B2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAD+B,CAAjC;;AAGA,QACEiD,IAAI,CAAC/I,IAAL,KAAchC,MAAM,CAACiO,cAArB,KACC,CAAC9M,KAAK,CAAC8D,OAAP,IAAkB,CAAC8F,IAAI,CAACyB,eADzB,KAEA,CAAC6B,IAHH,EAIE;AACA,aAAO,CAACrI,MAAD,EAASlF,KAAT,CAAP;AACD;;AACD,QAAIuN,IAAJ,EAAU;AACR,aAAO,CAACrI,MAAD,EAAS1F,IAAT,CAAP;AACD;;AACD,WAAO,CAAC0F,MAAD,EAASnF,OAAT,EAAkBP,IAAlB,CAAP;AACD,GAfD;;AAiBA,WAASgO,kBAAT,CAA4B1M,IAA5B,EAAkC;AAChC,WAAOkI,sBAAsB,CAAClI,IAAI,CAACqI,IAAN,EAAYrI,IAAZ,CAA7B;AACD;;AAED,WAAS2M,mBAAT,CAA6B3M,IAA7B,EAAmC4M,aAAnC,EAAkD;AAChD,WAAO5M,IAAI,CAAC6M,KAAL,GAAa,WAAWD,aAAa,GAAGnE,YAAY,EAAf,GAAoBvJ,KAA5C,CAAb,GAAkE,EAAzE;AACD;;AAED,WAAS4N,kBAAT,CAA4B9M,IAA5B,EAAkC;AAChC,QAAI+M,WAAW,GAAG/M,IAAI,CAACgN,SAAL,IAAkB,CAACzN,KAAK,CAACmE,GAAN,CAAUE,iBAA/C;AACA,WAAOmJ,WAAW,GAAG,MAAM7N,KAAT,GAAiB,EAAnC;AACD;;AAED,WAAS+N,oBAAT,CAA8BC,IAA9B,EAAoC;AAClC,QAAIC,IAAI,GAAGD,IAAI,CAAC3H,KAAhB;AAAA,QACEiF,MAAM,GAAG,EADX;;AAEA,QAAI2C,IAAI,CAACN,KAAT,EAAgB;AACdrC,MAAAA,MAAM,IAAImC,mBAAmB,CAACQ,IAAD,EAAO,CAACD,IAAI,CAACE,QAAb,CAA7B;AACD;;AACD,QAAID,IAAI,CAACH,SAAT,EAAoB;AAClB;AACAxC,MAAAA,MAAM,IAAIsC,kBAAkB,CAACK,IAAD,CAAlB,GAA2B,GAA3B,GAAiC,EAA3C;AACD;;AACD,WAAO3C,MAAP;AACD;;AAEDvK,EAAAA,aAAa,CAACgM,SAAd,CAAwBoB,eAAxB,GAA0C,UAASrN,IAAT,EAAe8L,UAAf,EAA2BnF,KAA3B,EAAkC;AAC1E,QAAI3G,IAAI,CAACI,IAAL,KAAchC,MAAM,CAACkP,UAAzB,EAAqC;AACnC,aAAOZ,kBAAkB,CAAC1M,IAAD,CAAzB;AACD;;AACD,WAAO,KAAKuN,kBAAL,CAAwBvN,IAAxB,EAA8B8L,UAA9B,EAA0CnF,KAA1C,CAAP;AACD,GALD;;AAOA1G,EAAAA,aAAa,CAACgM,SAAd,CAAwBuB,sBAAxB,GAAiD,UAASxN,IAAT,EAAe;AAC9D,QAAI4G,CAAJ,EAAOC,EAAP,EAAWzC,MAAX,EAAmBqJ,UAAnB;AAEAA,IAAAA,UAAU,GAAG,KAAb;;AAEA,QACEzN,IAAI,CAACI,IAAL,KAAchC,MAAM,CAACsP,uBAArB,IACA,CAAC1N,IAAI,CAAC2N,IADN,KAEC,CAAC3N,IAAI,CAAC4N,QAAN,IAAkB5N,IAAI,CAAC4N,QAAL,CAAcnJ,MAAd,KAAyB,CAF5C,KAGAzE,IAAI,CAAC6N,MAAL,CAAYpJ,MAAZ,KAAuB,CAHvB,IAIAzE,IAAI,CAAC6N,MAAL,CAAY,CAAZ,EAAezN,IAAf,KAAwBhC,MAAM,CAACkP,UALjC,EAME;AACA;AACAlJ,MAAAA,MAAM,GAAG,CACPuI,mBAAmB,CAAC3M,IAAD,EAAO,IAAP,CADZ,EAEP0M,kBAAkB,CAAC1M,IAAI,CAAC6N,MAAL,CAAY,CAAZ,CAAD,CAFX,CAAT;AAID,KAZD,MAYO;AACLzJ,MAAAA,MAAM,GACJpE,IAAI,CAACI,IAAL,KAAchC,MAAM,CAACsP,uBAArB,GACI,CAACf,mBAAmB,CAAC3M,IAAD,EAAO,KAAP,CAApB,CADJ,GAEI,EAHN;AAIAoE,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;AACA,UAAI/K,IAAI,CAAC4N,QAAT,EAAmB;AACjBH,QAAAA,UAAU,GAAG,IAAb;AACD;;AACD,WAAK7G,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAG7G,IAAI,CAAC6N,MAAL,CAAYpJ,MAA7B,EAAqCmC,CAAC,GAAGC,EAAzC,EAA6C,EAAED,CAA/C,EAAkD;AAChD,YAAI6G,UAAU,IAAIzN,IAAI,CAAC4N,QAAL,CAAchH,CAAd,CAAlB,EAAoC;AAClC;AACAxC,UAAAA,MAAM,CAAC2G,IAAP,CACE,KAAK+C,kBAAL,CACE9N,IAAI,CAAC6N,MAAL,CAAYjH,CAAZ,CADF,EAEE5G,IAAI,CAAC4N,QAAL,CAAchH,CAAd,CAFF,EAGE,GAHF,EAIEvI,UAAU,CAACoC,UAJb,EAKEkC,KALF,CADF;AASD,SAXD,MAWO;AACLyB,UAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKsC,eAAL,CAAqBrN,IAAI,CAAC6N,MAAL,CAAYjH,CAAZ,CAArB,EAAqCvI,UAAU,CAACoC,UAAhD,EAA4DkC,KAA5D,CADF;AAGD;;AACD,YAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,UAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM7L,KAAlB;AACD;AACF;;AAED,UAAIc,IAAI,CAAC2N,IAAT,EAAe;AACb,YAAI3N,IAAI,CAAC6N,MAAL,CAAYpJ,MAAhB,EAAwB;AACtBL,UAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM7L,KAAlB;AACD;;AACDkF,QAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAZ;AACA3G,QAAAA,MAAM,CAAC2G,IAAP,CAAY2B,kBAAkB,CAAC1M,IAAI,CAAC2N,IAAN,CAA9B;AACD;;AAEDvJ,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;;AAED,WAAO3G,MAAP;AACD,GA5DD;;AA8DAnE,EAAAA,aAAa,CAACgM,SAAd,CAAwB8B,oBAAxB,GAA+C,UAAS/N,IAAT,EAAe;AAC5D,QAAIoE,MAAJ,EAAYyH,IAAZ;AAEAzH,IAAAA,MAAM,GAAG,KAAKoJ,sBAAL,CAA4BxN,IAA5B,CAAT;;AAEA,QAAIA,IAAI,CAACI,IAAL,KAAchC,MAAM,CAACsP,uBAAzB,EAAkD;AAChDtJ,MAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAZ;AACAkF,MAAAA,MAAM,CAAC2G,IAAP,CAAY,IAAZ;AACD;;AAED,QAAI/K,IAAI,CAACgO,UAAT,EAAqB;AACnB5J,MAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAZ;AACA2M,MAAAA,IAAI,GAAG,KAAK0B,kBAAL,CAAwBvN,IAAI,CAACiL,IAA7B,EAAmC5M,UAAU,CAACoC,UAA9C,EAA0DkC,KAA1D,CAAP;;AACA,UAAIkJ,IAAI,CAAC3F,QAAL,GAAgB+H,MAAhB,CAAuB,CAAvB,MAA8B,GAAlC,EAAuC;AACrCpC,QAAAA,IAAI,GAAG,CAAC,GAAD,EAAMA,IAAN,EAAY,GAAZ,CAAP;AACD;;AACDzH,MAAAA,MAAM,CAAC2G,IAAP,CAAYc,IAAZ;AACD,KAPD,MAOO;AACLzH,MAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgBlM,IAAI,CAACiL,IAArB,EAA2B9H,MAA3B,CAAZ;AACD;;AAED,WAAOiB,MAAP;AACD,GAtBD;;AAwBAnE,EAAAA,aAAa,CAACgM,SAAd,CAAwBiC,6BAAxB,GAAwD,UACtDC,QADsD,EAEtDhF,IAFsD,EAGtDxC,KAHsD,EAItD;AACA,QAAIvC,MAAM,GAAG,CACT,SAAS+E,IAAI,CAACiF,KAAL,GAAa3F,YAAY,KAAK,OAA9B,GAAwC,EAAjD,IAAuDvJ,KAAvD,GAA+D,GADtD,CAAb;AAAA,QAGEkN,IAAI,GAAG,IAHT;AAIAhD,IAAAA,UAAU,CAAC,YAAW;AACpB,UAAID,IAAI,CAACR,IAAL,CAAUvI,IAAV,KAAmBhC,MAAM,CAACiQ,mBAA9B,EAAmD;AACjDjF,QAAAA,UAAU,CAAC,YAAW;AACpBhF,UAAAA,MAAM,CAAC2G,IAAP,CAAY5B,IAAI,CAACR,IAAL,CAAU2F,IAAV,GAAiB7F,YAAY,EAAzC;AACArE,UAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAACR,IAAL,CAAU4F,YAAV,CAAuB,CAAvB,CAAvB,EAAkDtL,MAAlD,CADF;AAGD,SALS,CAAV;AAMD,OAPD,MAOO;AACLmB,QAAAA,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACR,IAA7B,EAAmCtK,UAAU,CAACqD,IAA9C,EAAoDiB,KAApD,CAAZ;AACD;;AAEDyB,MAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS+J,QAAT,CAAb;AACA/J,MAAAA,MAAM,GAAG,CACPsE,IAAI,CACFtE,MADE,EAEFgI,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACP,KAA7B,EAAoCvK,UAAU,CAACoC,UAA/C,EAA2DkC,KAA3D,CAFE,CADG,EAKP,GALO,CAAT;AAOD,KApBS,CAAV;AAqBAyB,IAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAA3B,CAAZ;AACA,WAAOvC,MAAP;AACD,GAhCD;;AAkCAnE,EAAAA,aAAa,CAACgM,SAAd,CAAwBuC,mBAAxB,GAA8C,UAAS3C,IAAT,EAAeuB,QAAf,EAAyB;AACrE,QAAIhJ,MAAM,GAAG,EAAb;;AAEA,QAAIgJ,QAAJ,EAAc;AACZhJ,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;;AAED3G,IAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAxB,EAA8BxN,UAAU,CAACkC,QAAzC,EAAmDoC,KAAnD,CAAZ;;AAEA,QAAIyK,QAAJ,EAAc;AACZhJ,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;;AAED,WAAO3G,MAAP;AACD,GAdD;;AAgBAnE,EAAAA,aAAa,CAACgM,SAAd,CAAwB6B,kBAAxB,GAA6C,UAC3CnF,IAD2C,EAE3CC,KAF2C,EAG3CuF,QAH2C,EAI3CrC,UAJ2C,EAK3CnF,KAL2C,EAM3C;AACA,QAAItI,UAAU,CAACoC,UAAX,GAAwBqL,UAA5B,EAAwC;AACtCnF,MAAAA,KAAK,IAAIxE,UAAT;AACD;;AAED,WAAOmJ,YAAY,CACjB,CACE,KAAKiC,kBAAL,CAAwB5E,IAAxB,EAA8BtK,UAAU,CAACqD,IAAzC,EAA+CiF,KAA/C,CADF,EAEEzH,KAAK,GAAGiP,QAAR,GAAmBjP,KAFrB,EAGE,KAAKqO,kBAAL,CAAwB3E,KAAxB,EAA+BvK,UAAU,CAACoC,UAA1C,EAAsDkG,KAAtD,CAHF,CADiB,EAMjBtI,UAAU,CAACoC,UANM,EAOjBqL,UAPiB,CAAnB;AASD,GApBD;;AAsBA7L,EAAAA,aAAa,CAACgM,SAAd,CAAwBwC,SAAxB,GAAoC,UAAS9H,KAAT,EAAgB;AAClD,QAAI,CAACvH,UAAD,IAAeuH,KAAK,GAAGnE,eAA3B,EAA4C;AAC1C,aAAO,EAAP;AACD,KAHiD,CAIlD;;;AACA,WAAO,EAAP;AACD,GAND,CAxlCU,CAgmCV;;;AAEAvC,EAAAA,aAAa,CAACK,SAAd,GAA0B;AACxB+L,IAAAA,cAAc,EAAE,wBAASlD,IAAT,EAAexC,KAAf,EAAsB;AACpC,UAAI2D,KAAJ;AAAA,UACE0B,OADF;AAAA,UAEE5H,MAAM,GAAG,CAAC,GAAD,EAAMnF,OAAN,CAFX;AAAA,UAGEmN,IAAI,GAAG,IAHT;AAKAhD,MAAAA,UAAU,CAAC,YAAW;AACpB;AACA,YAAID,IAAI,CAAC8B,IAAL,CAAUxG,MAAV,KAAqB,CAArB,IAA0B9E,kBAA9B,EAAkD;AAChD2K,UAAAA,KAAK,GAAGnB,IAAI,CAACmB,KAAb;;AACA,cAAIA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAhB,GAAsB,CAA1B,EAA6B;AAC3B0B,YAAAA,OAAO,GAAGtM,UAAU,CAACoL,SAAX,CAAqBR,KAAK,CAAC,CAAD,CAAL,GAAW,CAAhC,EAAmCA,KAAK,CAAC,CAAD,CAAL,GAAW,CAA9C,CAAV;;AACA,gBAAI0B,OAAO,CAAC,CAAD,CAAP,KAAe,IAAnB,EAAyB;AACvB5H,cAAAA,MAAM,GAAG,CAAC,GAAD,CAAT;AACD;;AACDA,YAAAA,MAAM,CAAC2G,IAAP,CAAYiB,OAAZ;AACD;AACF;;AAED,YAAIpF,CAAJ,EAAOC,EAAP,EAAWuD,QAAX,EAAqBsE,SAArB;AACAA,QAAAA,SAAS,GAAG3L,MAAZ;;AACA,YAAI4D,KAAK,GAAGrE,WAAZ,EAAyB;AACvBoM,UAAAA,SAAS,IAAInM,eAAb;AACD;;AAED,aAAKqE,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC8B,IAAL,CAAUxG,MAA3B,EAAmCmC,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;AAC9C,cAAIjH,kBAAJ,EAAwB;AACtB;AACA,gBAAIiH,CAAC,KAAK,CAAV,EAAa;AACX,kBAAIuC,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAjB,EAAkC;AAChCN,gBAAAA,KAAK,GAAGnB,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAb,CAA6B,CAA7B,EAAgCC,aAAxC;AACAmB,gBAAAA,OAAO,GAAGtM,UAAU,CAACoL,SAAX,CAAqBR,KAAK,CAAC,CAAD,CAA1B,EAA+BA,KAAK,CAAC,CAAD,CAApC,CAAV;;AACA,oBAAI0B,OAAO,CAAC,CAAD,CAAP,KAAe,IAAnB,EAAyB;AACvB5H,kBAAAA,MAAM,GAAG,CAAC,GAAD,CAAT;AACD;AACF;;AACD,kBAAI,CAAC+E,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAlB,EAAmC;AACjCO,gBAAAA,kBAAkB,CAChBhC,IAAI,CAACmB,KAAL,CAAW,CAAX,CADgB,EAEhBnB,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaX,KAAb,CAAmB,CAAnB,CAFgB,EAGhBlG,MAHgB,CAAlB;AAKD;AACF,aAjBqB,CAmBtB;;;AACA,gBAAIwC,CAAC,GAAG,CAAR,EAAW;AACT,kBACE,CAACuC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBsE,gBAAlB,IACA,CAAC/B,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAagE,eAFhB,EAGE;AACAO,gBAAAA,kBAAkB,CAChBhC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiB0D,KAAjB,CAAuB,CAAvB,CADgB,EAEhBnB,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAFgB,EAGhBlG,MAHgB,CAAlB;AAKD;AACF;AACF;;AAED,cAAIwC,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;AAChB6H,YAAAA,SAAS,IAAIlM,eAAb;AACD;;AAED,cAAI2G,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAagE,eAAb,IAAgCjL,kBAApC,EAAwD;AACtDyK,YAAAA,QAAQ,GAAGgC,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAvB,EAAqC8H,SAArC,CAAX;AACD,WAFD,MAEO;AACLtE,YAAAA,QAAQ,GAAGlB,SAAS,CAClBkD,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAvB,EAAqC8H,SAArC,CADkB,CAApB;AAGD;;AAEDtK,UAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;AACA,cACE,CAAC7F,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CADzB,EAEE;AACA,gBAAIvG,kBAAkB,IAAIiH,CAAC,GAAGC,EAAE,GAAG,CAAnC,EAAsC;AACpC;AACA;AACA,kBAAI,CAACsC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBgE,eAAtB,EAAuC;AACrCxG,gBAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF,aAND,MAMO;AACLmF,cAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF;;AAED,cAAIU,kBAAJ,EAAwB;AACtB;AACA,gBAAIiH,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;AAChB,kBAAI,CAACsC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAasE,gBAAlB,EAAoC;AAClCC,gBAAAA,kBAAkB,CAChBhC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CADgB,EAEhBnB,IAAI,CAACmB,KAAL,CAAW,CAAX,CAFgB,EAGhBlG,MAHgB,CAAlB;AAKD;AACF;AACF;AACF;AACF,OA9FS,CAAV;AAgGAA,MAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAAC,GAAD,CAArB;AACA,aAAO9E,MAAP;AACD,KAzGuB;AA2GxBuK,IAAAA,cAAc,EAAE,wBAASxF,IAAT,EAAexC,KAAf,EAAsB;AACpC,UAAIwC,IAAI,CAACyF,KAAT,EAAgB;AACd,eAAO,WAAWzF,IAAI,CAACyF,KAAL,CAAWvG,IAAtB,GAA6B,KAAKoG,SAAL,CAAe9H,KAAf,CAApC;AACD;;AACD,aAAO,UAAU,KAAK8H,SAAL,CAAe9H,KAAf,CAAjB;AACD,KAhHuB;AAkHxBkI,IAAAA,iBAAiB,EAAE,2BAAS1F,IAAT,EAAexC,KAAf,EAAsB;AACvC,UAAIwC,IAAI,CAACyF,KAAT,EAAgB;AACd,eAAO,cAAczF,IAAI,CAACyF,KAAL,CAAWvG,IAAzB,GAAgC,KAAKoG,SAAL,CAAe9H,KAAf,CAAvC;AACD;;AACD,aAAO,aAAa,KAAK8H,SAAL,CAAe9H,KAAf,CAApB;AACD,KAvHuB;AAyHxBmI,IAAAA,SAAS,EAAE,mBAAS3F,IAAT,EAAexC,KAAf,EAAsB;AAC/B,UAAIvC,MAAM,GAAG,CAAC,GAAD,EAAMnF,OAAN,CAAb;AAAA,UACEmN,IAAI,GAAG,IADT;AAGAhD,MAAAA,UAAU,CAAC,UAASzK,MAAT,EAAiB;AAC1B,YAAIiI,CAAJ,EAAOC,EAAP;;AAEA,aAAKD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC8B,IAAL,CAAUxG,MAA3B,EAAmCmC,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;AAC9CxC,UAAAA,MAAM,CAAC2G,IAAP,CAAYpM,MAAZ;AACAyF,UAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAxB,EAAsCvI,UAAU,CAACkC,QAAjD,EAA2DoC,KAA3D,CADF;;AAGA,cAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,YAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF;AACF,OAZS,CAAV;;AAcA,UAAI,CAACsF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA3B,EAAwE;AACtE9B,QAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;;AACDmF,MAAAA,MAAM,CAAC2G,IAAP,CAAYrM,IAAZ;AACA0F,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA,aAAO3G,MAAP;AACD,KAjJuB;AAmJxB2K,IAAAA,gBAAgB,EAAE,0BAAS5F,IAAT,EAAexC,KAAf,EAAsB;AACtC,UAAIvC,MAAJ,EAAYgG,QAAZ;AACAhG,MAAAA,MAAM,GAAG,CAAC,OAAD,CAAT;;AACA,UAAI+E,IAAI,CAAC6F,EAAT,EAAa;AACX5K,QAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKmJ,kBAAL,CAAwBpE,IAAI,CAAC6F,EAA7B,EAAiC3Q,UAAU,CAACkC,QAA5C,EAAsDoC,KAAtD,CAFW,CAAb;AAID;;AACD,UAAIwG,IAAI,CAAC8F,UAAT,EAAqB;AACnB7E,QAAAA,QAAQ,GAAG1B,IAAI,CACb,SADa,EAEb,KAAK6E,kBAAL,CAAwBpE,IAAI,CAAC8F,UAA7B,EAAyC5Q,UAAU,CAACmD,KAApD,EAA2DmB,KAA3D,CAFa,CAAf;AAIAyB,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;AACD;;AACDhG,MAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAZ;AACAkF,MAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKuB,iBAAL,CAAuBnD,IAAI,CAAC8B,IAA5B,EAAkCjI,MAAlC,CAAZ;AACA,aAAOoB,MAAP;AACD,KAtKuB;AAwKxB8K,IAAAA,kBAAkB,EAAE,4BAAS/F,IAAT,EAAexC,KAAf,EAAsB;AACxC,UAAIpH,KAAK,CAACwE,GAAN,IAAaoF,IAAI,CAACpF,GAAtB,EAA2B;AACzB,eAAOoF,IAAI,CAACpF,GAAL,GAAW,KAAK0K,SAAL,CAAe9H,KAAf,CAAlB;AACD;;AACD,aAAOW,eAAe,CAAC6B,IAAI,CAAC7J,SAAN,CAAf,GAAkC,KAAKmP,SAAL,CAAe9H,KAAf,CAAzC;AACD,KA7KuB;AA+KxBwI,IAAAA,gBAAgB,EAAE,0BAAShG,IAAT,EAAexC,KAAf,EAAsB;AACtC;AACA,UAAIvC,MAAM,GAAGsE,IAAI,CAAC,IAAD,EAAO,KAAKwD,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BlI,MAA3B,CAAP,CAAjB;AACAqB,MAAAA,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC8B,IAA3B,EAAiC7G,MAAjC,CAAT;AACA,aAAOsE,IAAI,CAACtE,MAAD,EAAS,CAClB,UAAUlF,KAAV,GAAkB,GADA,EAElB,KAAKqO,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmCjG,UAAU,CAACkC,QAA9C,EAAwDoC,KAAxD,CAFkB,EAGlB,MAAM,KAAK8L,SAAL,CAAe9H,KAAf,CAHY,CAAT,CAAX;AAKD,KAxLuB;AA0LxByI,IAAAA,WAAW,EAAE,qBAASjG,IAAT,EAAexC,KAAf,EAAsB;AACjC,UAAIvC,MAAJ;AAAA,UACEgI,IAAI,GAAG,IADT;AAEAhD,MAAAA,UAAU,CAAC,YAAW;AACpB,YAAIiG,KAAJ;;AAEA,YAAIlG,IAAI,CAACmG,KAAT,EAAgB;AACdlL,UAAAA,MAAM,GAAG,CACP,UAAUlF,KAAV,GAAkB,GADX,EAEPkN,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACmG,KAA7B,EAAoCjR,UAAU,CAACkC,QAA/C,EAAyDoC,KAAzD,CAFO,EAGP,GAHO,CAAT;;AAMA,cAAIwG,IAAI,CAACkG,KAAT,EAAgB;AACdA,YAAAA,KAAK,GAAGjD,IAAI,CAACmB,kBAAL,CACNpE,IAAI,CAACkG,KADC,EAENhR,UAAU,CAACkC,QAFL,EAGNoC,KAHM,CAAR;AAKAyB,YAAAA,MAAM,CAACmL,MAAP,CAAc,CAAd,EAAiB,CAAjB,EAAoB,MAApB,EAA4BF,KAA5B;AACD;AACF,SAfD,MAeO;AACLjL,UAAAA,MAAM,GAAG,CAAC,OAAD,CAAT;AACD;AACF,OArBS,CAAV;AAsBAA,MAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BlI,MAA3B,CAAZ;AACA,aAAOqB,MAAP;AACD,KArNuB;AAuNxBoL,IAAAA,iBAAiB,EAAE,2BAASrG,IAAT,EAAexC,KAAf,EAAsB;AACvC,aAAO,aAAa,KAAK8H,SAAL,CAAe9H,KAAf,CAApB;AACD,KAzNuB;AA2NxB4F,IAAAA,cAAc,EAAE,wBAASpD,IAAT,EAAexC,KAAf,EAAsB;AACpC,aAAO,GAAP;AACD,KA7NuB;AA+NxB8I,IAAAA,wBAAwB,EAAE,kCAAStG,IAAT,EAAexC,KAAf,EAAsB;AAC9C,UAAIvC,MAAM,GAAG,CAAC,QAAD,CAAb;AAAA,UACEsK,SADF;AAGAA,MAAAA,SAAS,GAAG/H,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA/C,CAJ8C,CAM9C;AACA;;AACAqB,MAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,SAAT,CAAb;;AACA,UAAI/D,WAAW,CAAC8I,IAAI,CAACuG,WAAN,CAAf,EAAmC;AACjCtL,QAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKkI,iBAAL,CAAuBnD,IAAI,CAACuG,WAA5B,EAAyChB,SAAzC,CAFW,CAAb;AAID,OALD,MAKO;AACLtK,QAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKmJ,kBAAL,CACEpE,IAAI,CAACuG,WADP,EAEErR,UAAU,CAACoC,UAFb,EAGEkC,KAHF,IAII,KAAK8L,SAAL,CAAe9H,KAAf,CANO,CAAb;AAQD;;AACD,aAAOvC,MAAP;AACD,KAxPuB;AA0PxBuL,IAAAA,sBAAsB,EAAE,gCAASxG,IAAT,EAAexC,KAAf,EAAsB;AAC5C,UAAIvC,MAAM,GAAG,CAAC,QAAD,CAAb;AAAA,UACEsK,SADF;AAAA,UAEEtC,IAAI,GAAG,IAFT;AAIAsC,MAAAA,SAAS,GAAG/H,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA/C,CAL4C,CAO5C;AACA;;AACA,UAAIoG,IAAI,CAACuG,WAAT,EAAsB;AACpB,eAAOhH,IAAI,CACTtE,MADS,EAET,KAAKkI,iBAAL,CAAuBnD,IAAI,CAACuG,WAA5B,EAAyChB,SAAzC,CAFS,CAAX;AAID,OAd2C,CAgB5C;AACA;;;AACA,UAAIvF,IAAI,CAACyG,UAAT,EAAqB;AACnB,YAAIzG,IAAI,CAACyG,UAAL,CAAgBnL,MAAhB,KAA2B,CAA/B,EAAkC;AAChCL,UAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,MAAMlF,KAAN,GAAc,GAAvB,CAAb;AACD,SAFD,MAEO,IAAIiK,IAAI,CAACyG,UAAL,CAAgB,CAAhB,EAAmBxP,IAAnB,KAA4BhC,MAAM,CAACyR,oBAAvC,EAA6D;AAClEzL,UAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKmJ,kBAAL,CACEpE,IAAI,CAACyG,UAAL,CAAgB,CAAhB,CADF,EAEEvR,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CAFW,CAAb;AAQD,SATM,MASA;AACLyB,UAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,GAAT,CAAb;AACAgF,UAAAA,UAAU,CAAC,UAASzK,MAAT,EAAiB;AAC1B,gBAAIiI,CAAJ,EAAOC,EAAP;AACAzC,YAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;;AACA,iBAAK2H,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAACyG,UAAL,CAAgBnL,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;AACpDxC,cAAAA,MAAM,CAAC2G,IAAP,CAAYpM,MAAZ;AACAyF,cAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CACEpE,IAAI,CAACyG,UAAL,CAAgBhJ,CAAhB,CADF,EAEEvI,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CADF;;AAOA,kBAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,gBAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM9L,OAAlB;AACD;AACF;AACF,WAhBS,CAAV;;AAiBA,cACE,CAACsF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CADzB,EAEE;AACA9B,YAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;;AACDmF,UAAAA,MAAM,CAAC2G,IAAP,CAAYrM,IAAI,GAAG,GAAnB;AACD;;AAED,YAAIyK,IAAI,CAACpC,MAAT,EAAiB;AACf3C,UAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACpB,SAASlF,KADW,EAEpB;AACA,eAAKqO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqC1I,UAAU,CAACkC,QAAhD,EAA0DoC,KAA1D,CAHoB,EAIpB,KAAK8L,SAAL,CAAe9H,KAAf,CAJoB,CAAT,CAAb;AAMD,SAPD,MAOO;AACLvC,UAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAK0D,SAAL,CAAe9H,KAAf,CAAZ;AACD;AACF;;AACD,aAAOvC,MAAP;AACD,KA/TuB;AAiUxB0L,IAAAA,oBAAoB,EAAE,8BAAS3G,IAAT,EAAexC,KAAf,EAAsB;AAC1C;AACA,aAAO,CACL,WAAWzH,KADN,EAEL,MAAMA,KAFD,EAGL,SAASA,KAHJ,EAIL;AACA,WAAKqO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqC1I,UAAU,CAACkC,QAAhD,EAA0DoC,KAA1D,CALK,EAML,KAAK8L,SAAL,CAAe9H,KAAf,CANK,CAAP;AAQD,KA3UuB;AA6UxBoJ,IAAAA,mBAAmB,EAAE,6BAAS5G,IAAT,EAAexC,KAAf,EAAsB;AACzC,UAAIvC,MAAJ,EAAYgG,QAAZ;;AAEA,eAAS4F,eAAT,CAAyB5F,QAAzB,EAAmC;AACjC,YAAI1F,IAAJ;;AACA,YAAI0F,QAAQ,CAACtE,KAAT,CAAe,CAAf,EAAkB,CAAlB,MAAyB,OAA7B,EAAsC;AACpC,iBAAO,KAAP;AACD;;AACDpB,QAAAA,IAAI,GAAG0F,QAAQ,CAACxF,UAAT,CAAoB,CAApB,CAAP;AACA,eACEF,IAAI,KAAK;AAAK;AAAd,WACAjG,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BvE,IAA1B,CADA,IAEAjG,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,CAHF;AAKD;;AAED,eAASuL,kBAAT,CAA4B7F,QAA5B,EAAsC;AACpC,YAAI1F,IAAJ;;AACA,YAAI0F,QAAQ,CAACtE,KAAT,CAAe,CAAf,EAAkB,CAAlB,MAAyB,UAA7B,EAAyC;AACvC,iBAAO,KAAP;AACD;;AACDpB,QAAAA,IAAI,GAAG0F,QAAQ,CAACxF,UAAT,CAAoB,CAApB,CAAP;AACA,eACEF,IAAI,KAAK;AAAK;AAAd,WACAjG,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BvE,IAA1B,CADA,IAEAA,IAAI,KAAK;AAAK;AAFd,WAGAjG,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,CAJF;AAMD;;AAED,eAASwL,eAAT,CAAyB9F,QAAzB,EAAmC;AACjC,YAAI1F,IAAJ,EAAUkC,CAAV,EAAaC,EAAb;;AACA,YAAIuD,QAAQ,CAACtE,KAAT,CAAe,CAAf,EAAkB,CAAlB,MAAyB,OAA7B,EAAsC;AACpC,iBAAO,KAAP;AACD;;AACD,YAAI,CAACrH,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BmB,QAAQ,CAACxF,UAAT,CAAoB,CAApB,CAA1B,CAAL,EAAwD;AACtD,iBAAO,KAAP;AACD;;AACD,aAAKgC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGuD,QAAQ,CAAC3F,MAA1B,EAAkCmC,CAAC,GAAGC,EAAtC,EAA0C,EAAED,CAA5C,EAA+C;AAC7C,cAAI,CAACnI,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BmB,QAAQ,CAACxF,UAAT,CAAoBgC,CAApB,CAA1B,CAAL,EAAwD;AACtD;AACD;AACF;;AACD,YAAIA,CAAC,KAAKC,EAAV,EAAc;AACZ,iBAAO,KAAP;AACD;;AACD,YAAIuD,QAAQ,CAACtE,KAAT,CAAec,CAAf,EAAkBA,CAAC,GAAG,CAAtB,MAA6B,UAAjC,EAA6C;AAC3C,iBAAO,KAAP;AACD;;AACDlC,QAAAA,IAAI,GAAG0F,QAAQ,CAACxF,UAAT,CAAoBgC,CAAC,GAAG,CAAxB,CAAP;AACA,eACElC,IAAI,KAAK;AAAK;AAAd,WACAjG,OAAO,CAACiG,IAAR,CAAauE,YAAb,CAA0BvE,IAA1B,CADA,IAEAA,IAAI,KAAK;AAAK;AAFd,WAGAjG,OAAO,CAACiG,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,CAJF;AAMD;;AAEDN,MAAAA,MAAM,GAAG,CACP,KAAKmJ,kBAAL,CAAwBpE,IAAI,CAAC6E,UAA7B,EAAyC3P,UAAU,CAACkC,QAApD,EAA8DoC,KAA9D,CADO,CAAT,CA1DyC,CA6DzC;AACA;;AACAyH,MAAAA,QAAQ,GAAGlC,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAX;;AACA,UACEkE,QAAQ,CAACxF,UAAT,CAAoB,CAApB,MAA2B;AAAK;AAAhC,SAA6C;AAC7CoL,MAAAA,eAAe,CAAC5F,QAAD,CADf,IAEA6F,kBAAkB,CAAC7F,QAAD,CAFlB,IAGA8F,eAAe,CAAC9F,QAAD,CAHf,IAIC9K,SAAS,IACRqH,KAAK,GAAGpE,eADT,IAEC4G,IAAI,CAAC6E,UAAL,CAAgB5N,IAAhB,KAAyBhC,MAAM,CAAC+R,OAFjC,IAGC,OAAOhH,IAAI,CAAC6E,UAAL,CAAgBzI,KAAvB,KAAiC,QARrC,EASE;AACAnB,QAAAA,MAAM,GAAG,CAAC,GAAD,EAAMA,MAAN,EAAc,MAAM,KAAKqK,SAAL,CAAe9H,KAAf,CAApB,CAAT;AACD,OAXD,MAWO;AACLvC,QAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAK0D,SAAL,CAAe9H,KAAf,CAAZ;AACD;;AACD,aAAOvC,MAAP;AACD,KA5ZuB;AA8ZxBgM,IAAAA,iBAAiB,EAAE,2BAASjH,IAAT,EAAexC,KAAf,EAAsB;AACvC;AACA;AACA;AACA,UAAIvC,MAAJ;AAAA,UACEiM,MADF;AAAA,UAEEjE,IAAI,GAAG,IAFT,CAJuC,CAQvC;AACA;AACA;;AACA,UAAIjD,IAAI,CAACyG,UAAL,CAAgBnL,MAAhB,KAA2B,CAA/B,EAAkC;AAChC;AACA,eAAO,CACL,QADK,EAELvF,KAFK,EAGL;AACA,aAAKqO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqC1I,UAAU,CAACkC,QAAhD,EAA0DoC,KAA1D,CAJK,EAKL,KAAK8L,SAAL,CAAe9H,KAAf,CALK,CAAP;AAOD,OApBsC,CAsBvC;;;AACAvC,MAAAA,MAAM,GAAG,CAAC,QAAD,CAAT;AACAiM,MAAAA,MAAM,GAAG,CAAT,CAxBuC,CA0BvC;;AACA,UAAIlH,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,EAAwBjQ,IAAxB,KAAiChC,MAAM,CAACkS,sBAA5C,EAAoE;AAClElM,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACpB,KAAKmJ,kBAAL,CACEpE,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CADF,EAEEhS,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CADoB,CAAT,CAAb;AAOA,UAAE0N,MAAF;AACD;;AAED,UAAIlH,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CAAJ,EAA6B;AAC3B,YAAIA,MAAM,KAAK,CAAf,EAAkB;AAChBjM,UAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;;AAED,YAAI5B,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,EAAwBjQ,IAAxB,KAAiChC,MAAM,CAACmS,wBAA5C,EAAsE;AACpE;AACAnM,UAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACpBlF,KADoB,EAEpB,KAAKqO,kBAAL,CACEpE,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CADF,EAEEhS,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CAFoB,CAAT,CAAb;AAQD,SAVD,MAUO;AACL;AACAyB,UAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAK,GAAG,GAApB;;AAEA,cAAIiK,IAAI,CAACyG,UAAL,CAAgBnL,MAAhB,GAAyB4L,MAAzB,KAAoC,CAAxC,EAA2C;AACzC;AACAjM,YAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAZ;AACAkF,YAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKwC,kBAAL,CACEpE,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CADF,EAEEhS,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CADF;AAOAyB,YAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAK,GAAG,GAAR,GAAcA,KAA1B;AACD,WAXD,MAWO;AACL;AACA;AACA;AACA;AACAkK,YAAAA,UAAU,CAAC,UAASzK,MAAT,EAAiB;AAC1B,kBAAIiI,CAAJ,EAAOC,EAAP;AACAzC,cAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;;AACA,mBAAK2H,CAAC,GAAGyJ,MAAJ,EAAYxJ,EAAE,GAAGsC,IAAI,CAACyG,UAAL,CAAgBnL,MAAtC,EAA8CmC,CAAC,GAAGC,EAAlD,EAAsD,EAAED,CAAxD,EAA2D;AACzDxC,gBAAAA,MAAM,CAAC2G,IAAP,CAAYpM,MAAZ;AACAyF,gBAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CACEpE,IAAI,CAACyG,UAAL,CAAgBhJ,CAAhB,CADF,EAEEvI,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CADF;;AAOA,oBAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,kBAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM9L,OAAlB;AACD;AACF;AACF,aAhBS,CAAV;;AAiBA,gBACE,CAACsF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CADzB,EAEE;AACA9B,cAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;;AACDmF,YAAAA,MAAM,CAAC2G,IAAP,CAAYrM,IAAI,GAAG,GAAP,GAAaQ,KAAzB;AACD;AACF;AACF;;AAEDkF,MAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACpB,SAASlF,KADW,EAEpB;AACA,WAAKqO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqC1I,UAAU,CAACkC,QAAhD,EAA0DoC,KAA1D,CAHoB,EAIpB,KAAK8L,SAAL,CAAe9H,KAAf,CAJoB,CAAT,CAAb;AAMA,aAAOvC,MAAP;AACD,KAzgBuB;AA2gBxBoM,IAAAA,kBAAkB,EAAE,4BAASrH,IAAT,EAAexC,KAAf,EAAsB;AACxC,UAAI8J,SAAS,GAAG9J,KAAK,GAAGxE,UAAR,GAAqBQ,KAArB,GAA6BF,KAA7C;;AACA,UAAI0G,IAAI,CAACuH,IAAT,EAAe;AACb,eAAO,CACL,KAAKnD,kBAAL,CAAwBpE,IAAI,CAAC6F,EAA7B,EAAiC3Q,UAAU,CAACoC,UAA5C,EAAwDgQ,SAAxD,CADK,EAELvR,KAFK,EAGL,GAHK,EAILA,KAJK,EAKL,KAAKqO,kBAAL,CAAwBpE,IAAI,CAACuH,IAA7B,EAAmCrS,UAAU,CAACoC,UAA9C,EAA0DgQ,SAA1D,CALK,CAAP;AAOD;;AACD,aAAO,KAAKpD,eAAL,CAAqBlE,IAAI,CAAC6F,EAA1B,EAA8B3Q,UAAU,CAACoC,UAAzC,EAAqDgQ,SAArD,CAAP;AACD,KAvhBuB;AAyhBxBpC,IAAAA,mBAAmB,EAAE,6BAASlF,IAAT,EAAexC,KAAf,EAAsB;AACzC;AACA;AACA;AACA,UAAIvC,MAAJ;AAAA,UACEwC,CADF;AAAA,UAEEC,EAFF;AAAA,UAGE7G,IAHF;AAAA,UAIE0O,SAJF;AAAA,UAKEtC,IAAI,GAAG,IALT;AAOAhI,MAAAA,MAAM,GAAG,CAAC+E,IAAI,CAACmF,IAAN,CAAT;AAEAI,MAAAA,SAAS,GAAG/H,KAAK,GAAGxE,UAAR,GAAqBY,MAArB,GAA8BE,MAA1C;;AAEA,eAAS0N,KAAT,GAAiB;AACf3Q,QAAAA,IAAI,GAAGmJ,IAAI,CAACoF,YAAL,CAAkB,CAAlB,CAAP;;AACA,YAAIhP,KAAK,CAAC8D,OAAN,IAAiBrD,IAAI,CAAC4K,eAA1B,EAA2C;AACzCxG,UAAAA,MAAM,CAAC2G,IAAP,CAAY,IAAZ;AACA3G,UAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBtM,IAAvB,EAA6B0O,SAA7B,CAAD,CAArB;AACD,SAHD,MAGO;AACLtK,UAAAA,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,EAAxB;AACArE,UAAAA,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACE,iBAAL,CAAuBtM,IAAvB,EAA6B0O,SAA7B,CAAZ;AACD;;AAED,aAAK9H,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAACoF,YAAL,CAAkB9J,MAAnC,EAA2CmC,CAAC,GAAGC,EAA/C,EAAmD,EAAED,CAArD,EAAwD;AACtD5G,UAAAA,IAAI,GAAGmJ,IAAI,CAACoF,YAAL,CAAkB3H,CAAlB,CAAP;;AACA,cAAIrH,KAAK,CAAC8D,OAAN,IAAiBrD,IAAI,CAAC4K,eAA1B,EAA2C;AACzCxG,YAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM9L,OAAlB;AACAmF,YAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBtM,IAAvB,EAA6B0O,SAA7B,CAAD,CAArB;AACD,WAHD,MAGO;AACLtK,YAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM7L,KAAlB;AACAkF,YAAAA,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACE,iBAAL,CAAuBtM,IAAvB,EAA6B0O,SAA7B,CAAZ;AACD;AACF;AACF;;AAED,UAAIvF,IAAI,CAACoF,YAAL,CAAkB9J,MAAlB,GAA2B,CAA/B,EAAkC;AAChC2E,QAAAA,UAAU,CAACuH,KAAD,CAAV;AACD,OAFD,MAEO;AACLA,QAAAA,KAAK;AACN;;AAEDvM,MAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAK0D,SAAL,CAAe9H,KAAf,CAAZ;AAEA,aAAOvC,MAAP;AACD,KAvkBuB;AAykBxBwM,IAAAA,cAAc,EAAE,wBAASzH,IAAT,EAAexC,KAAf,EAAsB;AACpC,aAAO,CACL+B,IAAI,CACF,OADE,EAEF,KAAK6E,kBAAL,CAAwBpE,IAAI,CAAC0H,QAA7B,EAAuCxS,UAAU,CAACkC,QAAlD,EAA4DoC,KAA5D,CAFE,CADC,EAKL,KAAK8L,SAAL,CAAe9H,KAAf,CALK,CAAP;AAOD,KAjlBuB;AAmlBxBmK,IAAAA,YAAY,EAAE,sBAAS3H,IAAT,EAAexC,KAAf,EAAsB;AAClC,UAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf,EAAmBkK,eAAnB;AAEA3M,MAAAA,MAAM,GAAG,CAAC,KAAD,EAAQ,KAAK8H,UAAL,CAAgB/C,IAAI,CAACwH,KAArB,EAA4B5N,MAA5B,CAAR,CAAT;AACAqB,MAAAA,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAACwH,KAA3B,EAAkCvM,MAAlC,CAAT;;AAEA,UAAI+E,IAAI,CAAC6H,QAAT,EAAmB;AACjB;AACA,aAAKpK,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC6H,QAAL,CAAcvM,MAA/B,EAAuCmC,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EAAoD;AAClDxC,UAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKkI,iBAAL,CAAuBnD,IAAI,CAAC6H,QAAL,CAAcpK,CAAd,CAAvB,EAAyC7D,MAAzC,CAFW,CAAb;;AAIA,cAAIoG,IAAI,CAAC8H,SAAL,IAAkBrK,CAAC,GAAG,CAAJ,KAAUC,EAAhC,EAAoC;AAClCzC,YAAAA,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC6H,QAAL,CAAcpK,CAAd,EAAiBqE,IAAvC,EAA6C7G,MAA7C,CAAT;AACD;AACF;AACF,OAXD,MAWO;AACL2M,QAAAA,eAAe,GAAG5H,IAAI,CAAC4H,eAAL,IAAwB,EAA1C;;AAEA,aAAKnK,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGkK,eAAe,CAACtM,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;AACpDxC,UAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKkI,iBAAL,CAAuByE,eAAe,CAACnK,CAAD,CAAtC,EAA2C7D,MAA3C,CAFW,CAAb;;AAIA,cAAIoG,IAAI,CAAC8H,SAAL,IAAkBrK,CAAC,GAAG,CAAJ,KAAUC,EAAhC,EAAoC;AAClCzC,YAAAA,MAAM,GAAG,KAAKoI,gBAAL,CAAsBuE,eAAe,CAACnK,CAAD,CAAf,CAAmBqE,IAAzC,EAA+C7G,MAA/C,CAAT;AACD;AACF,SAXI,CAaL;;;AACA,YAAI+E,IAAI,CAAC+H,OAAT,EAAkB;AAChB,cAAIlJ,KAAK,CAACC,OAAN,CAAckB,IAAI,CAAC+H,OAAnB,CAAJ,EAAiC;AAC/B,iBAAKtK,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC+H,OAAL,CAAazM,MAA9B,EAAsCmC,CAAC,GAAGC,EAA1C,EAA8C,EAAED,CAAhD,EAAmD;AACjDxC,cAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKkI,iBAAL,CAAuBnD,IAAI,CAAC+H,OAAL,CAAatK,CAAb,CAAvB,EAAwC7D,MAAxC,CAFW,CAAb;;AAIA,kBAAIoG,IAAI,CAAC8H,SAAL,IAAkBrK,CAAC,GAAG,CAAJ,KAAUC,EAAhC,EAAoC;AAClCzC,gBAAAA,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC+H,OAAL,CAAatK,CAAb,EAAgBqE,IAAtC,EAA4C7G,MAA5C,CAAT;AACD;AACF;AACF,WAVD,MAUO;AACLA,YAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKkI,iBAAL,CAAuBnD,IAAI,CAAC+H,OAA5B,EAAqCnO,MAArC,CAAT,CAAb;;AACA,gBAAIoG,IAAI,CAAC8H,SAAT,EAAoB;AAClB7M,cAAAA,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC+H,OAAL,CAAajG,IAAnC,EAAyC7G,MAAzC,CAAT;AACD;AACF;AACF;AACF;;AACD,UAAI+E,IAAI,CAAC8H,SAAT,EAAoB;AAClB7M,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACpB,SADoB,EAEpB,KAAK8H,UAAL,CAAgB/C,IAAI,CAAC8H,SAArB,EAAgClO,MAAhC,CAFoB,CAAT,CAAb;AAID;;AACD,aAAOqB,MAAP;AACD,KA5oBuB;AA8oBxB+M,IAAAA,eAAe,EAAE,yBAAShI,IAAT,EAAexC,KAAf,EAAsB;AACrC,UAAIvC,MAAJ;AAAA,UACEgG,QADF;AAAA,UAEExD,CAFF;AAAA,UAGEC,EAHF;AAAA,UAIE6H,SAJF;AAAA,UAKEtC,IAAI,GAAG,IALT;AAMAhD,MAAAA,UAAU,CAAC,YAAW;AACpBhF,QAAAA,MAAM,GAAG,CACP,WAAWlF,KAAX,GAAmB,GADZ,EAEPkN,IAAI,CAACmB,kBAAL,CACEpE,IAAI,CAACiI,YADP,EAEE/S,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CAFO,EAOP,MAAMzD,KAAN,GAAc,GAAd,GAAoBD,OAPb,CAAT;AASD,OAVS,CAAV;;AAWA,UAAIkK,IAAI,CAACkI,KAAT,EAAgB;AACd3C,QAAAA,SAAS,GAAG3L,MAAZ;;AACA,aAAK6D,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAACkI,KAAL,CAAW5M,MAA5B,EAAoCmC,CAAC,GAAGC,EAAxC,EAA4C,EAAED,CAA9C,EAAiD;AAC/C,cAAIA,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;AAChB6H,YAAAA,SAAS,IAAIlM,eAAb;AACD;;AACD4H,UAAAA,QAAQ,GAAGlB,SAAS,CAClB,KAAKoD,iBAAL,CAAuBnD,IAAI,CAACkI,KAAL,CAAWzK,CAAX,CAAvB,EAAsC8H,SAAtC,CADkB,CAApB;AAGAtK,UAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;AACA,cACE,CAAC7F,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CADzB,EAEE;AACA9B,YAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF;AACF;;AACDmF,MAAAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAAC,GAAD,CAArB;AACA,aAAO9E,MAAP;AACD,KAnrBuB;AAqrBxBkN,IAAAA,UAAU,EAAE,oBAASnI,IAAT,EAAexC,KAAf,EAAsB;AAChC,UAAIvC,MAAJ;AAAA,UACEgG,QADF;AAAA,UAEExD,CAFF;AAAA,UAGEC,EAHF;AAAA,UAIE6H,SAJF;AAAA,UAKEtC,IAAI,GAAG,IALT;AAMAhD,MAAAA,UAAU,CAAC,YAAW;AACpB,YAAID,IAAI,CAAC7E,IAAT,EAAe;AACbF,UAAAA,MAAM,GAAG,CACP8E,SAAS,CACPR,IAAI,CACF,OADE,EAEF0D,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmCjG,UAAU,CAACkC,QAA9C,EAAwDoC,KAAxD,CAFE,CADG,CADF,EAOP,IAPO,CAAT;AASD,SAVD,MAUO;AACLyB,UAAAA,MAAM,GAAG,CAAC8E,SAAS,CAAC,WAAD,CAAV,CAAT;AACD;;AAEDtC,QAAAA,CAAC,GAAG,CAAJ;AACAC,QAAAA,EAAE,GAAGsC,IAAI,CAACoI,UAAL,CAAgB9M,MAArB;;AACA,YAAIoC,EAAE,IAAIsC,IAAI,CAACoI,UAAL,CAAgB,CAAhB,EAAmBnR,IAAnB,KAA4BhC,MAAM,CAACiO,cAA7C,EAA6D;AAC3DjC,UAAAA,QAAQ,GAAGgC,IAAI,CAACF,UAAL,CAAgB/C,IAAI,CAACoI,UAAL,CAAgB,CAAhB,CAAhB,EAAoCxO,MAApC,CAAX;AACAqB,UAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;AACAxD,UAAAA,CAAC,GAAG,CAAJ;AACD;;AAED,YACEA,CAAC,KAAKC,EAAN,IACA,CAACtC,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAFzB,EAGE;AACA9B,UAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;;AAEDyP,QAAAA,SAAS,GAAG3L,MAAZ;;AACA,eAAO6D,CAAC,GAAGC,EAAX,EAAe,EAAED,CAAjB,EAAoB;AAClB,cAAIA,CAAC,KAAKC,EAAE,GAAG,CAAX,IAAgBF,KAAK,GAAGnE,eAA5B,EAA6C;AAC3CkM,YAAAA,SAAS,IAAIlM,eAAb;AACD;;AACD4H,UAAAA,QAAQ,GAAGlB,SAAS,CAClBA,SAAS,CACPR,IAAI,CAAC0D,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAACoI,UAAL,CAAgB3K,CAAhB,CAAvB,EAA2C8H,SAA3C,CAAD,EAAwD,GAAxD,CADG,CADS,CAApB;AAKAtK,UAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;AACA,cACExD,CAAC,GAAG,CAAJ,KAAUC,EAAV,IACA,CAACtC,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAFzB,EAGE;AACA9B,YAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF;AACF,OAhDS,CAAV;AAiDA,aAAOmF,MAAP;AACD,KA9uBuB;AAgvBxBoN,IAAAA,WAAW,EAAE,qBAASrI,IAAT,EAAexC,KAAf,EAAsB;AACjC,UAAIvC,MAAJ;AAAA,UACEsK,SADF;AAAA,UAEE+C,iBAFF;AAAA,UAGErF,IAAI,GAAG,IAHT;AAIAhD,MAAAA,UAAU,CAAC,YAAW;AACpBhF,QAAAA,MAAM,GAAG,CACP,OAAOlF,KAAP,GAAe,GADR,EAEPkN,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmCjG,UAAU,CAACkC,QAA9C,EAAwDoC,KAAxD,CAFO,EAGP,GAHO,CAAT;AAKD,OANS,CAAV;AAOA8O,MAAAA,iBAAiB,GAAG9K,KAAK,GAAGnE,eAA5B;AACAkM,MAAAA,SAAS,GAAG3L,MAAZ;;AACA,UAAI0O,iBAAJ,EAAuB;AACrB/C,QAAAA,SAAS,IAAIlM,eAAb;AACD;;AACD,UAAI2G,IAAI,CAACuI,SAAT,EAAoB;AAClBtN,QAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAACoI,UAArB,EAAiCxO,MAAjC,CAAZ;AACAqB,QAAAA,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAACoI,UAA3B,EAAuCnN,MAAvC,CAAT;;AACA,YAAI+E,IAAI,CAACuI,SAAL,CAAetR,IAAf,KAAwBhC,MAAM,CAACoT,WAAnC,EAAgD;AAC9CpN,UAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACpB,OADoB,EAEpB,KAAKkI,iBAAL,CAAuBnD,IAAI,CAACuI,SAA5B,EAAuChD,SAAvC,CAFoB,CAAT,CAAb;AAID,SALD,MAKO;AACLtK,UAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEXsE,IAAI,CAAC,MAAD,EAAS,KAAKwD,UAAL,CAAgB/C,IAAI,CAACuI,SAArB,EAAgChD,SAAhC,CAAT,CAFO,CAAb;AAID;AACF,OAdD,MAcO;AACLtK,QAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAACoI,UAArB,EAAiC7C,SAAjC,CAAZ;AACD;;AACD,aAAOtK,MAAP;AACD,KAnxBuB;AAqxBxBuN,IAAAA,YAAY,EAAE,sBAASxI,IAAT,EAAexC,KAAf,EAAsB;AAClC,UAAIvC,MAAJ;AAAA,UACEgI,IAAI,GAAG,IADT;AAEAhD,MAAAA,UAAU,CAAC,YAAW;AACpBhF,QAAAA,MAAM,GAAG,CAAC,QAAQlF,KAAR,GAAgB,GAAjB,CAAT;;AACA,YAAIiK,IAAI,CAACuH,IAAT,EAAe;AACb;AACA,cAAIvH,IAAI,CAACuH,IAAL,CAAUtQ,IAAV,KAAmBhC,MAAM,CAACiQ,mBAA9B,EAAmD;AACjDjK,YAAAA,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAACuH,IAA5B,EAAkCzN,MAAlC,CAAZ;AACAmB,YAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD,WAHD,MAGO;AACL;AACA3G,YAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACuH,IAA7B,EAAmCrS,UAAU,CAACkC,QAA9C,EAAwDkC,KAAxD,CADF;AAGA2B,YAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;AACF,SAZD,MAYO;AACL3G,UAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;;AAED,YAAI5B,IAAI,CAAC7E,IAAT,EAAe;AACbF,UAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAZ;AACAkF,UAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmCjG,UAAU,CAACkC,QAA9C,EAAwDoC,KAAxD,CADF;AAGAyB,UAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD,SAND,MAMO;AACL3G,UAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;;AAED,YAAI5B,IAAI,CAACyI,MAAT,EAAiB;AACfxN,UAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAZ;AACAkF,UAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACyI,MAA7B,EAAqCvT,UAAU,CAACkC,QAAhD,EAA0DoC,KAA1D,CADF;AAGAyB,UAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD,SAND,MAMO;AACL3G,UAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;AACF,OArCS,CAAV;AAuCA3G,MAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CADF;AAGA,aAAOqB,MAAP;AACD,KAn0BuB;AAq0BxByN,IAAAA,cAAc,EAAE,wBAAS1I,IAAT,EAAexC,KAAf,EAAsB;AACpC,aAAO,KAAKuH,6BAAL,CACL,IADK,EAEL/E,IAFK,EAGLxC,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAH9B,CAAP;AAKD,KA30BuB;AA60BxB+O,IAAAA,cAAc,EAAE,wBAAS3I,IAAT,EAAexC,KAAf,EAAsB;AACpC,aAAO,KAAKuH,6BAAL,CACL,IADK,EAEL/E,IAFK,EAGLxC,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAH9B,CAAP;AAKD,KAn1BuB;AAq1BxBgP,IAAAA,gBAAgB,EAAE,0BAAS5I,IAAT,EAAexC,KAAf,EAAsB;AACtC,aAAO,CACLwC,IAAI,CAACyF,KAAL,CAAWvG,IAAX,GAAkB,GADb,EAEL,KAAK6D,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CAFK,CAAP;AAID,KA11BuB;AA41BxBiI,IAAAA,OAAO,EAAE,iBAAS7B,IAAT,EAAexC,KAAf,EAAsB;AAC7B,UAAIvC,MAAJ,EAAYgG,QAAZ,EAAsBxD,CAAtB,EAAyBC,EAAzB,EAA6B6H,SAA7B;AACA7H,MAAAA,EAAE,GAAGsC,IAAI,CAAC8B,IAAL,CAAUxG,MAAf;AACAL,MAAAA,MAAM,GAAG,CAAC/E,iBAAiB,IAAIwH,EAAE,GAAG,CAA1B,GAA8B,IAA9B,GAAqC,EAAtC,CAAT;AACA6H,MAAAA,SAAS,GAAGxL,MAAZ;;AACA,WAAK0D,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,EAAhB,EAAoB,EAAED,CAAtB,EAAyB;AACvB,YAAI,CAACvH,iBAAD,IAAsBuH,CAAC,KAAKC,EAAE,GAAG,CAArC,EAAwC;AACtC6H,UAAAA,SAAS,IAAIlM,eAAb;AACD;;AAED,YAAI7C,kBAAJ,EAAwB;AACtB;AACA,cAAIiH,CAAC,KAAK,CAAV,EAAa;AACX,gBAAI,CAACuC,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAlB,EAAmC;AACjCO,cAAAA,kBAAkB,CAAChC,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAD,EAAgBnB,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAAhB,EAAuClG,MAAvC,CAAlB;AACD;AACF,WANqB,CAQtB;;;AACA,cAAIwC,CAAC,GAAG,CAAR,EAAW;AACT,gBACE,CAACuC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBsE,gBAAlB,IACA,CAAC/B,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAagE,eAFhB,EAGE;AACAO,cAAAA,kBAAkB,CAChBhC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiB0D,KAAjB,CAAuB,CAAvB,CADgB,EAEhBnB,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAFgB,EAGhBlG,MAHgB,CAAlB;AAKD;AACF;AACF;;AAEDgG,QAAAA,QAAQ,GAAGlB,SAAS,CAAC,KAAKoD,iBAAL,CAAuBnD,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAvB,EAAqC8H,SAArC,CAAD,CAApB;AACAtK,QAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;AACA,YACExD,CAAC,GAAG,CAAJ,GAAQC,EAAR,IACA,CAACtC,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAFzB,EAGE;AACA,cAAIvG,kBAAJ,EAAwB;AACtB,gBAAI,CAACwJ,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBgE,eAAtB,EAAuC;AACrCxG,cAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF,WAJD,MAIO;AACLmF,YAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;AACF;;AAED,YAAIU,kBAAJ,EAAwB;AACtB;AACA,cAAIiH,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;AAChB,gBAAI,CAACsC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAasE,gBAAlB,EAAoC;AAClCC,cAAAA,kBAAkB,CAAChC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAAD,EAAwBnB,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAxB,EAAuClG,MAAvC,CAAlB;AACD;AACF;AACF;AACF;;AACD,aAAOA,MAAP;AACD,KAt5BuB;AAw5BxB;AACA4N,IAAAA,mBAAmB,EAAE,6BAAS7I,IAAT,EAAexC,KAAf,EAAsB;AACzC,aAAO,CACLgG,mBAAmB,CAACxD,IAAD,EAAO,IAAP,CADd,EAEL,UAFK,EAGL2D,kBAAkB,CAAC3D,IAAD,CAAlB,IAA4BV,YAAY,EAHnC,EAILU,IAAI,CAAC6F,EAAL,GAAUtC,kBAAkB,CAACvD,IAAI,CAAC6F,EAAN,CAA5B,GAAwC,EAJnC,EAKL,KAAKjB,oBAAL,CAA0B5E,IAA1B,CALK,CAAP;AAOD,KAj6BuB;AAm6BxB8I,IAAAA,eAAe,EAAE,yBAAS9I,IAAT,EAAexC,KAAf,EAAsB;AACrC,UAAIwC,IAAI,CAAC0H,QAAT,EAAmB;AACjB,eAAO,CACLnI,IAAI,CACF,QADE,EAEF,KAAK6E,kBAAL,CAAwBpE,IAAI,CAAC0H,QAA7B,EAAuCxS,UAAU,CAACkC,QAAlD,EAA4DoC,KAA5D,CAFE,CADC,EAKL,KAAK8L,SAAL,CAAe9H,KAAf,CALK,CAAP;AAOD;;AACD,aAAO,CAAC,WAAW,KAAK8H,SAAL,CAAe9H,KAAf,CAAZ,CAAP;AACD,KA96BuB;AAg7BxBuL,IAAAA,cAAc,EAAE,wBAAS/I,IAAT,EAAexC,KAAf,EAAsB;AACpC,UAAIvC,MAAJ;AAAA,UACEgI,IAAI,GAAG,IADT;AAEAhD,MAAAA,UAAU,CAAC,YAAW;AACpBhF,QAAAA,MAAM,GAAG,CACP,UAAUlF,KAAV,GAAkB,GADX,EAEPkN,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmCjG,UAAU,CAACkC,QAA9C,EAAwDoC,KAAxD,CAFO,EAGP,GAHO,CAAT;AAKD,OANS,CAAV;AAOAyB,MAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CADF;AAGA,aAAOqB,MAAP;AACD,KA97BuB;AAg8BxB+N,IAAAA,aAAa,EAAE,uBAAShJ,IAAT,EAAexC,KAAf,EAAsB;AACnC,UAAIvC,MAAJ;AAAA,UACEgI,IAAI,GAAG,IADT;AAEAhD,MAAAA,UAAU,CAAC,YAAW;AACpBhF,QAAAA,MAAM,GAAG,CACP,SAASlF,KAAT,GAAiB,GADV,EAEPkN,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACiJ,MAA7B,EAAqC/T,UAAU,CAACkC,QAAhD,EAA0DoC,KAA1D,CAFO,EAGP,GAHO,CAAT;AAKD,OANS,CAAV;AAOAyB,MAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CADF;AAGA,aAAOqB,MAAP;AACD;AA98BuB,GAA1B;AAi9BAS,EAAAA,KAAK,CAAC5E,aAAa,CAACgM,SAAf,EAA0BhM,aAAa,CAACK,SAAxC,CAAL,CAnjEU,CAqjEV;;AAEAL,EAAAA,aAAa,CAACC,UAAd,GAA2B;AACzBmS,IAAAA,kBAAkB,EAAE,4BAASxG,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACpD,UAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf;;AACA,UAAIxI,UAAU,CAACkC,QAAX,GAAsBuL,UAA1B,EAAsC;AACpCnF,QAAAA,KAAK,IAAIxE,UAAT;AACD;;AACDiC,MAAAA,MAAM,GAAG,EAAT;;AACA,WAAKwC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAACyG,WAAL,CAAiB7N,MAAlC,EAA0CmC,CAAC,GAAGC,EAA9C,EAAkD,EAAED,CAApD,EAAuD;AACrDxC,QAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKwC,kBAAL,CACE1B,IAAI,CAACyG,WAAL,CAAiB1L,CAAjB,CADF,EAEEvI,UAAU,CAACoC,UAFb,EAGEkG,KAHF,CADF;;AAOA,YAAIC,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,UAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM7L,KAAlB;AACD;AACF;;AACD,aAAOoM,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACkC,QAApB,EAA8BuL,UAA9B,CAAnB;AACD,KApBwB;AAsBzByG,IAAAA,oBAAoB,EAAE,8BAAS1G,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACtD,aAAO,KAAKmH,kBAAL,CACLjC,IAAI,CAAClD,IADA,EAELkD,IAAI,CAACjD,KAFA,EAGLiD,IAAI,CAACsC,QAHA,EAILrC,UAJK,EAKLnF,KALK,CAAP;AAOD,KA9BwB;AAgCzB+G,IAAAA,uBAAuB,EAAE,iCAAS7B,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACzD,aAAO2E,YAAY,CACjB,KAAKyC,oBAAL,CAA0BlC,IAA1B,CADiB,EAEjBxN,UAAU,CAACsC,aAFM,EAGjBmL,UAHiB,CAAnB;AAKD,KAtCwB;AAwCzB0G,IAAAA,qBAAqB,EAAE,+BAAS3G,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACvD,UAAItI,UAAU,CAACqC,WAAX,GAAyBoL,UAA7B,EAAyC;AACvCnF,QAAAA,KAAK,IAAIxE,UAAT;AACD;;AACD,aAAOmJ,YAAY,CACjB,CACE,KAAKiC,kBAAL,CAAwB1B,IAAI,CAACvH,IAA7B,EAAmCjG,UAAU,CAACuC,SAA9C,EAAyD+F,KAAzD,CADF,EAEEzH,KAAK,GAAG,GAAR,GAAcA,KAFhB,EAGE,KAAKqO,kBAAL,CACE1B,IAAI,CAAC0F,UADP,EAEElT,UAAU,CAACoC,UAFb,EAGEkG,KAHF,CAHF,EAQEzH,KAAK,GAAG,GAAR,GAAcA,KARhB,EASE,KAAKqO,kBAAL,CAAwB1B,IAAI,CAAC6F,SAA7B,EAAwCrT,UAAU,CAACoC,UAAnD,EAA+DkG,KAA/D,CATF,CADiB,EAYjBtI,UAAU,CAACqC,WAZM,EAajBoL,UAbiB,CAAnB;AAeD,KA3DwB;AA6DzB2G,IAAAA,iBAAiB,EAAE,2BAAS5G,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACnD,aAAO,KAAK+L,gBAAL,CAAsB7G,IAAtB,EAA4BC,UAA5B,EAAwCnF,KAAxC,CAAP;AACD,KA/DwB;AAiEzB+L,IAAAA,gBAAgB,EAAE,0BAAS7G,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAClD,UAAIvC,MAAJ,EACEuO,cADF,EAEEC,eAFF,EAGEC,iBAHF,EAIEzI,QAJF,EAKEvB,UALF;AAMAgK,MAAAA,iBAAiB,GAAGvU,gBAAgB,CAACuN,IAAI,CAACsC,QAAN,CAApC;AACAwE,MAAAA,cAAc,GACZ9G,IAAI,CAACsC,QAAL,KAAkB,IAAlB,GAAyB9P,UAAU,CAACoD,OAApC,GAA8CoR,iBADhD;AAEAD,MAAAA,eAAe,GACb/G,IAAI,CAACsC,QAAL,KAAkB,IAAlB,GAAyB0E,iBAAzB,GAA6CA,iBAAiB,GAAG,CADnE;;AAGA,UAAIA,iBAAiB,GAAG/G,UAAxB,EAAoC;AAClCnF,QAAAA,KAAK,IAAIxE,UAAT;AACD;;AAEDiI,MAAAA,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAAClD,IAA7B,EAAmCgK,cAAnC,EAAmDhM,KAAnD,CAAX;AAEAkC,MAAAA,UAAU,GAAGuB,QAAQ,CAAClE,QAAT,EAAb;;AAEA,UACE2C,UAAU,CAACjE,UAAX,CAAsBiE,UAAU,CAACpE,MAAX,GAAoB,CAA1C,MAAiD;AAAK;AAAtD,SACAhG,OAAO,CAACiG,IAAR,CAAakD,mBAAb,CAAiCiE,IAAI,CAACsC,QAAL,CAAcvJ,UAAd,CAAyB,CAAzB,CAAjC,CAFF,EAGE;AACAR,QAAAA,MAAM,GAAG,CAACgG,QAAD,EAAW3B,YAAY,EAAvB,EAA2BoD,IAAI,CAACsC,QAAhC,CAAT;AACD,OALD,MAKO;AACL/J,QAAAA,MAAM,GAAGsE,IAAI,CAAC0B,QAAD,EAAWyB,IAAI,CAACsC,QAAhB,CAAb;AACD;;AAED/D,MAAAA,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAACjD,KAA7B,EAAoCgK,eAApC,EAAqDjM,KAArD,CAAX;;AAEA,UACGkF,IAAI,CAACsC,QAAL,KAAkB,GAAlB,IAAyB/D,QAAQ,CAAClE,QAAT,GAAoB+H,MAApB,CAA2B,CAA3B,MAAkC,GAA5D,IACCpC,IAAI,CAACsC,QAAL,CAAcrI,KAAd,CAAoB,CAAC,CAArB,MAA4B,GAA5B,IACCsE,QAAQ,CAAClE,QAAT,GAAoBJ,KAApB,CAA0B,CAA1B,EAA6B,CAA7B,MAAoC,KAHxC,EAIE;AACA;AACA1B,QAAAA,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,EAAxB;AACArE,QAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;AACD,OARD,MAQO;AACLhG,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;AACD;;AAED,UAAIyB,IAAI,CAACsC,QAAL,KAAkB,IAAlB,IAA0B,EAAExH,KAAK,GAAGxE,UAAV,CAA9B,EAAqD;AACnD,eAAO,CAAC,GAAD,EAAMiC,MAAN,EAAc,GAAd,CAAP;AACD;;AACD,aAAOkH,YAAY,CAAClH,MAAD,EAASyO,iBAAT,EAA4B/G,UAA5B,CAAnB;AACD,KAjHwB;AAmHzBgH,IAAAA,cAAc,EAAE,wBAASjH,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAChD,UAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf,CADgD,CAEhD;;AACAzC,MAAAA,MAAM,GAAG,CAAC,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACkH,MAA7B,EAAqC1U,UAAU,CAACqD,IAAhD,EAAsDgB,KAAtD,CAAD,CAAT;AACA0B,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;AACA,WAAKnE,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC,WAAD,CAAJ,CAAkBpH,MAAnC,EAA2CmC,CAAC,GAAGC,EAA/C,EAAmD,EAAED,CAArD,EAAwD;AACtDxC,QAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKwC,kBAAL,CACE1B,IAAI,CAAC,WAAD,CAAJ,CAAkBjF,CAAlB,CADF,EAEEvI,UAAU,CAACoC,UAFb,EAGEkC,KAHF,CADF;;AAOA,YAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,UAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM7L,KAAlB;AACD;AACF;;AACDkF,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;AAEA,UAAI,EAAEpE,KAAK,GAAGvE,YAAV,CAAJ,EAA6B;AAC3B,eAAO,CAAC,GAAD,EAAMgC,MAAN,EAAc,GAAd,CAAP;AACD;;AACD,aAAOkH,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACqD,IAApB,EAA0BoK,UAA1B,CAAnB;AACD,KA1IwB;AA4IzBkH,IAAAA,aAAa,EAAE,uBAASnH,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC/C,UAAIvC,MAAJ,EAAYK,MAAZ,EAAoBmC,CAApB,EAAuBC,EAAvB,EAA2B4J,SAA3B;AACAhM,MAAAA,MAAM,GAAGoH,IAAI,CAAC,WAAD,CAAJ,CAAkBpH,MAA3B,CAF+C,CAI/C;AACA;;AACAgM,MAAAA,SAAS,GACP9J,KAAK,GAAGtE,oBAAR,IAAgC,CAAClD,WAAjC,IAAgDsF,MAAM,KAAK,CAA3D,GACI3B,KADJ,GAEIF,KAHN;AAKAwB,MAAAA,MAAM,GAAGsE,IAAI,CACX,KADW,EAEX,KAAK6E,kBAAL,CAAwB1B,IAAI,CAACkH,MAA7B,EAAqC1U,UAAU,CAACsD,GAAhD,EAAqD8O,SAArD,CAFW,CAAb;;AAKA,UAAI,EAAE9J,KAAK,GAAGtE,oBAAV,KAAmClD,WAAnC,IAAkDsF,MAAM,GAAG,CAA/D,EAAkE;AAChEL,QAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;AACA,aAAKnE,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGpC,MAAjB,EAAyBmC,CAAC,GAAGC,EAA7B,EAAiC,EAAED,CAAnC,EAAsC;AACpCxC,UAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKwC,kBAAL,CACE1B,IAAI,CAAC,WAAD,CAAJ,CAAkBjF,CAAlB,CADF,EAEEvI,UAAU,CAACoC,UAFb,EAGEkC,KAHF,CADF;;AAOA,cAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,YAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM7L,KAAlB;AACD;AACF;;AACDkF,QAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;;AAED,aAAOO,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACsD,GAApB,EAAyBmK,UAAzB,CAAnB;AACD,KA9KwB;AAgLzBmH,IAAAA,gBAAgB,EAAE,0BAASpH,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAClD,UAAIvC,MAAJ,EAAYgG,QAAZ,CADkD,CAGlD;;AACAhG,MAAAA,MAAM,GAAG,CACP,KAAKmJ,kBAAL,CACE1B,IAAI,CAACuG,MADP,EAEE/T,UAAU,CAACqD,IAFb,EAGEiF,KAAK,GAAGvE,YAAR,GAAuBM,KAAvB,GAA+BE,KAHjC,CADO,CAAT;;AAQA,UAAIiJ,IAAI,CAACuB,QAAT,EAAmB;AACjBhJ,QAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA3G,QAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKwC,kBAAL,CACE1B,IAAI,CAACqH,QADP,EAEE7U,UAAU,CAACkC,QAFb,EAGEoG,KAAK,GAAGvE,YAAR,GAAuBO,KAAvB,GAA+BG,KAHjC,CADF;AAOAsB,QAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD,OAVD,MAUO;AACL,YACEc,IAAI,CAACuG,MAAL,CAAYhS,IAAZ,KAAqBhC,MAAM,CAAC+R,OAA5B,IACA,OAAOtE,IAAI,CAACuG,MAAL,CAAY7M,KAAnB,KAA6B,QAF/B,EAGE;AACA6E,UAAAA,QAAQ,GAAGlC,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAX,CADA,CAEA;AACA;AACA;AACA;AACA;AACA;;AACA,cACEkE,QAAQ,CAACvE,OAAT,CAAiB,GAAjB,IAAwB,CAAxB,IACA,CAAC,SAASvB,IAAT,CAAc8F,QAAd,CADD,IAEA3L,OAAO,CAACiG,IAAR,CAAa0C,cAAb,CACEgD,QAAQ,CAACxF,UAAT,CAAoBwF,QAAQ,CAAC3F,MAAT,GAAkB,CAAtC,CADF,CAFA,IAKA,EAAE2F,QAAQ,CAAC3F,MAAT,IAAmB,CAAnB,IAAwB2F,QAAQ,CAACxF,UAAT,CAAoB,CAApB,MAA2B,EAArD,CANF,CAM2D;AAN3D,YAOE;AACAR,YAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;AACF;;AACD3G,QAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA3G,QAAAA,MAAM,CAAC2G,IAAP,CAAY2B,kBAAkB,CAACb,IAAI,CAACqH,QAAN,CAA9B;AACD;;AAED,aAAO5H,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACwD,MAApB,EAA4BiK,UAA5B,CAAnB;AACD,KAlOwB;AAoOzBqH,IAAAA,YAAY,EAAE,sBAAStH,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC9C,UAAIvC,MAAJ;AACAA,MAAAA,MAAM,GAAG,EAAT;AACAA,MAAAA,MAAM,CAAC2G,IAAP,CACE,OAAOc,IAAI,CAACuH,IAAZ,KAAqB,QAArB,GACIvH,IAAI,CAACuH,IADT,GAEI1G,kBAAkB,CAACb,IAAI,CAACuH,IAAN,CAHxB;AAKAhP,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA3G,MAAAA,MAAM,CAAC2G,IAAP,CACE,OAAOc,IAAI,CAACqH,QAAZ,KAAyB,QAAzB,GACIrH,IAAI,CAACqH,QADT,GAEIxG,kBAAkB,CAACb,IAAI,CAACqH,QAAN,CAHxB;AAKA,aAAO5H,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACwD,MAApB,EAA4BiK,UAA5B,CAAnB;AACD,KAnPwB;AAqPzBuH,IAAAA,eAAe,EAAE,yBAASxH,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,UAAIvC,MAAJ,EAAYgG,QAAZ,EAAsBpB,aAAtB,EAAqCH,UAArC,EAAiDE,YAAjD;AACAqB,MAAAA,QAAQ,GAAG,KAAKmD,kBAAL,CACT1B,IAAI,CAACgF,QADI,EAETxS,UAAU,CAACmD,KAFF,EAGTmB,KAHS,CAAX;;AAMA,UAAIzD,KAAK,KAAK,EAAd,EAAkB;AAChBkF,QAAAA,MAAM,GAAGsE,IAAI,CAACmD,IAAI,CAACsC,QAAN,EAAgB/D,QAAhB,CAAb;AACD,OAFD,MAEO;AACLhG,QAAAA,MAAM,GAAG,CAACyH,IAAI,CAACsC,QAAN,CAAT;;AACA,YAAItC,IAAI,CAACsC,QAAL,CAAc1J,MAAd,GAAuB,CAA3B,EAA8B;AAC5B;AACA;AACAL,UAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;AACD,SAJD,MAIO;AACL;AACA;AACAvB,UAAAA,UAAU,GAAGX,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAb;AACA6C,UAAAA,YAAY,GAAGF,UAAU,CAACjE,UAAX,CAAsBiE,UAAU,CAACpE,MAAX,GAAoB,CAA1C,CAAf;AACAuE,UAAAA,aAAa,GAAGoB,QAAQ,CAAClE,QAAT,GAAoBtB,UAApB,CAA+B,CAA/B,CAAhB;;AAEA,cACG,CAACmE,YAAY,KAAK;AAAK;AAAtB,aAAiCA,YAAY,KAAK;AAAM;AAAzD,eACCA,YAAY,KAAKC,aADnB,IAECvK,OAAO,CAACiG,IAAR,CAAakD,mBAAb,CAAiCmB,YAAjC,KACCtK,OAAO,CAACiG,IAAR,CAAakD,mBAAb,CAAiCoB,aAAjC,CAJJ,EAKE;AACA5E,YAAAA,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,EAAxB;AACArE,YAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;AACD,WARD,MAQO;AACLhG,YAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;AACD;AACF;AACF;;AACD,aAAOkB,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACmD,KAApB,EAA2BsK,UAA3B,CAAnB;AACD,KA1RwB;AA4RzBwH,IAAAA,eAAe,EAAE,yBAASzH,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,UAAIvC,MAAJ;;AACA,UAAIyH,IAAI,CAAC0H,QAAT,EAAmB;AACjBnP,QAAAA,MAAM,GAAG,QAAT;AACD,OAFD,MAEO;AACLA,QAAAA,MAAM,GAAG,OAAT;AACD;;AACD,UAAIyH,IAAI,CAACgF,QAAT,EAAmB;AACjBzM,QAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCxS,UAAU,CAACmC,KAAlD,EAAyDmC,KAAzD,CAFW,CAAb;AAID;;AACD,aAAO2I,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACmC,KAApB,EAA2BsL,UAA3B,CAAnB;AACD,KA1SwB;AA4SzB0H,IAAAA,eAAe,EAAE,yBAAS3H,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,UAAIvC,MAAM,GAAGsE,IAAI,CACfmD,IAAI,CAAC4H,GAAL,GAAW,QAAX,GAAsB,OADP,EAEf,KAAKlG,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCxS,UAAU,CAACkD,KAAlD,EAAyDoB,KAAzD,CAFe,CAAjB;AAIA,aAAO2I,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACkD,KAApB,EAA2BuK,UAA3B,CAAnB;AACD,KAlTwB;AAoTzB4H,IAAAA,gBAAgB,EAAE,0BAAS7H,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAClD,UAAIkF,IAAI,CAACrB,MAAT,EAAiB;AACf,eAAOc,YAAY,CACjB,CACEO,IAAI,CAACsC,QADP,EAEE,KAAKZ,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCxS,UAAU,CAACmD,KAAlD,EAAyDmB,KAAzD,CAFF,CADiB,EAKjBtE,UAAU,CAACmD,KALM,EAMjBsK,UANiB,CAAnB;AAQD;;AACD,aAAOR,YAAY,CACjB,CACE,KAAKiC,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCxS,UAAU,CAACoD,OAAlD,EAA2DkB,KAA3D,CADF,EAEEkJ,IAAI,CAACsC,QAFP,CADiB,EAKjB9P,UAAU,CAACoD,OALM,EAMjBqK,UANiB,CAAnB;AAQD,KAvUwB;AAyUzB6H,IAAAA,kBAAkB,EAAE,4BAAS9H,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACpD,UAAIvC,MAAM,GAAG,CAACuI,mBAAmB,CAACd,IAAD,EAAO,IAAP,CAApB,EAAkC,UAAlC,CAAb;;AACA,UAAIA,IAAI,CAACmD,EAAT,EAAa;AACX5K,QAAAA,MAAM,CAAC2G,IAAP,CAAY+B,kBAAkB,CAACjB,IAAD,CAAlB,IAA4BpD,YAAY,EAApD;AACArE,QAAAA,MAAM,CAAC2G,IAAP,CAAY2B,kBAAkB,CAACb,IAAI,CAACmD,EAAN,CAA9B;AACD,OAHD,MAGO;AACL5K,QAAAA,MAAM,CAAC2G,IAAP,CAAY+B,kBAAkB,CAACjB,IAAD,CAAlB,IAA4B3M,KAAxC;AACD;;AACDkF,MAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKgD,oBAAL,CAA0BlC,IAA1B,CAAZ;AACA,aAAOzH,MAAP;AACD,KAnVwB;AAqVzBwP,IAAAA,YAAY,EAAE,sBAAS/H,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC9C,aAAO,KAAKkN,eAAL,CAAqBhI,IAArB,EAA2BC,UAA3B,EAAuCnF,KAAvC,EAA8C,IAA9C,CAAP;AACD,KAvVwB;AAyVzBkN,IAAAA,eAAe,EAAE,yBAAShI,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkCmN,SAAlC,EAA6C;AAC5D,UAAI1P,MAAJ;AAAA,UACE2P,SADF;AAAA,UAEE3H,IAAI,GAAG,IAFT;;AAGA,UAAI,CAACP,IAAI,CAACmI,QAAL,CAAcvP,MAAnB,EAA2B;AACzB,eAAO,IAAP;AACD;;AACDsP,MAAAA,SAAS,GAAGD,SAAS,GAAG,KAAH,GAAWjI,IAAI,CAACmI,QAAL,CAAcvP,MAAd,GAAuB,CAAvD;AACAL,MAAAA,MAAM,GAAG,CAAC,GAAD,EAAM2P,SAAS,GAAG9U,OAAH,GAAa,EAA5B,CAAT;AACAmK,MAAAA,UAAU,CAAC,UAASzK,MAAT,EAAiB;AAC1B,YAAIiI,CAAJ,EAAOC,EAAP;;AACA,aAAKD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAACmI,QAAL,CAAcvP,MAA/B,EAAuCmC,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EAAoD;AAClD,cAAI,CAACiF,IAAI,CAACmI,QAAL,CAAcpN,CAAd,CAAL,EAAuB;AACrB,gBAAImN,SAAJ,EAAe;AACb3P,cAAAA,MAAM,CAAC2G,IAAP,CAAYpM,MAAZ;AACD;;AACD,gBAAIiI,CAAC,GAAG,CAAJ,KAAUC,EAAd,EAAkB;AAChBzC,cAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACD;AACF,WAPD,MAOO;AACL3G,YAAAA,MAAM,CAAC2G,IAAP,CAAYgJ,SAAS,GAAGpV,MAAH,GAAY,EAAjC;AACAyF,YAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CACE1B,IAAI,CAACmI,QAAL,CAAcpN,CAAd,CADF,EAEEvI,UAAU,CAACoC,UAFb,EAGEkC,KAHF,CADF;AAOD;;AACD,cAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,YAAAA,MAAM,CAAC2G,IAAP,CAAY,OAAOgJ,SAAS,GAAG9U,OAAH,GAAaC,KAA7B,CAAZ;AACD;AACF;AACF,OAxBS,CAAV;;AAyBA,UACE6U,SAAS,IACT,CAACxP,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAFzB,EAGE;AACA9B,QAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;;AACDmF,MAAAA,MAAM,CAAC2G,IAAP,CAAYgJ,SAAS,GAAGrV,IAAH,GAAU,EAA/B;AACA0F,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA,aAAO3G,MAAP;AACD,KApYwB;AAsYzB6P,IAAAA,WAAW,EAAE,qBAASpI,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC7C,aAAO,QAAQ,KAAK0G,eAAL,CAAqBxB,IAAI,CAACgF,QAA1B,CAAf;AACD,KAxYwB;AA0YzBqD,IAAAA,eAAe,EAAE,yBAASrI,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,UAAIvC,MAAJ,EAAYgG,QAAZ;AACAhG,MAAAA,MAAM,GAAG,CAAC,OAAD,CAAT;;AACA,UAAIyH,IAAI,CAACmD,EAAT,EAAa;AACX5K,QAAAA,MAAM,GAAGsE,IAAI,CACXtE,MADW,EAEX,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACmD,EAA7B,EAAiC3Q,UAAU,CAACkC,QAA5C,EAAsDoC,KAAtD,CAFW,CAAb;AAID;;AACD,UAAIkJ,IAAI,CAACoD,UAAT,EAAqB;AACnB7E,QAAAA,QAAQ,GAAG1B,IAAI,CACb,SADa,EAEb,KAAK6E,kBAAL,CAAwB1B,IAAI,CAACoD,UAA7B,EAAyC5Q,UAAU,CAACmD,KAApD,EAA2DmB,KAA3D,CAFa,CAAf;AAIAyB,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;AACD;;AACDhG,MAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAZ;AACAkF,MAAAA,MAAM,CAAC2G,IAAP,CAAY,KAAKuB,iBAAL,CAAuBT,IAAI,CAACZ,IAA5B,EAAkCjI,MAAlC,CAAZ;AACA,aAAOoB,MAAP;AACD,KA7ZwB;AA+ZzB+P,IAAAA,gBAAgB,EAAE,0BAAStI,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAClD,UAAIvC,MAAJ,EAAYgG,QAAZ;;AACA,UAAIyB,IAAI,CAAC,QAAD,CAAR,EAAoB;AAClBzH,QAAAA,MAAM,GAAG,CAAC,WAAWlF,KAAZ,CAAT;AACD,OAFD,MAEO;AACLkF,QAAAA,MAAM,GAAG,EAAT;AACD;;AACD,UAAIyH,IAAI,CAACyC,IAAL,KAAc,KAAd,IAAuBzC,IAAI,CAACyC,IAAL,KAAc,KAAzC,EAAgD;AAC9ClE,QAAAA,QAAQ,GAAG,CACT1B,IAAI,CAACmD,IAAI,CAACyC,IAAN,EAAY,KAAKE,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAAZ,CADK,EAET,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAFS,CAAX;AAID,OALD,MAKO;AACL6E,QAAAA,QAAQ,GAAG,CACT6C,oBAAoB,CAACpB,IAAD,CADX,EAET,KAAK2C,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAFS,EAGT,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAHS,CAAX;AAKD;;AACD,aAAOmD,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAX;AACD,KAnbwB;AAqbzBgK,IAAAA,QAAQ,EAAE,kBAASvI,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC1C,UAAIkF,IAAI,CAACyC,IAAL,KAAc,KAAd,IAAuBzC,IAAI,CAACyC,IAAL,KAAc,KAAzC,EAAgD;AAC9C,eAAO,CACLzC,IAAI,CAACyC,IADA,EAEL7F,YAAY,EAFP,EAGL,KAAK+F,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAHK,EAIL,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAJK,CAAP;AAMD;;AAED,UAAIsG,IAAI,CAACwI,SAAT,EAAoB;AAClB,YAAIxI,IAAI,CAACtG,KAAL,CAAWnF,IAAX,KAAoB,mBAAxB,EAA6C;AAC3C,iBAAO,KAAKkU,iBAAL,CAAuBzI,IAAI,CAACtG,KAA5B,EAAmClH,UAAU,CAACkC,QAA9C,EAAwDoC,KAAxD,CAAP;AACD;;AACD,eAAO,KAAK6L,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAAP;AACD;;AAED,UAAIvB,IAAI,CAAC0I,MAAT,EAAiB;AACf,eAAO,CACLtH,oBAAoB,CAACpB,IAAD,CADf,EAEL,KAAK2C,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAFK,EAGL,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAHK,CAAP;AAKD;;AAED,aAAO,CACL,KAAKiJ,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CADK,EAEL,MAAMlO,KAFD,EAGL,KAAKqO,kBAAL,CAAwB1B,IAAI,CAACtG,KAA7B,EAAoClH,UAAU,CAACoC,UAA/C,EAA2DkC,KAA3D,CAHK,CAAP;AAKD,KAndwB;AAqdzB6R,IAAAA,gBAAgB,EAAE,0BAAS3I,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAClD,UAAIoN,SAAJ;AAAA,UACE3P,MADF;AAAA,UAEEgG,QAFF;AAAA,UAGEgC,IAAI,GAAG,IAHT;;AAKA,UAAI,CAACP,IAAI,CAAC4I,UAAL,CAAgBhQ,MAArB,EAA6B;AAC3B,eAAO,IAAP;AACD;;AACDsP,MAAAA,SAAS,GAAGlI,IAAI,CAAC4I,UAAL,CAAgBhQ,MAAhB,GAAyB,CAArC;AAEA2E,MAAAA,UAAU,CAAC,YAAW;AACpBgB,QAAAA,QAAQ,GAAGgC,IAAI,CAACmB,kBAAL,CACT1B,IAAI,CAAC4I,UAAL,CAAgB,CAAhB,CADS,EAETpW,UAAU,CAACkC,QAFF,EAGToC,KAHS,CAAX;AAKD,OANS,CAAV;;AAQA,UAAI,CAACoR,SAAL,EAAgB;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAI,CAAC1P,iBAAiB,CAAC6D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAAtB,EAAqE;AACnE,iBAAO,CAAC,GAAD,EAAMhH,KAAN,EAAakL,QAAb,EAAuBlL,KAAvB,EAA8B,GAA9B,CAAP;AACD;AACF;;AAEDkK,MAAAA,UAAU,CAAC,UAASzK,MAAT,EAAiB;AAC1B,YAAIiI,CAAJ,EAAOC,EAAP;AACAzC,QAAAA,MAAM,GAAG,CAAC,GAAD,EAAMnF,OAAN,EAAeN,MAAf,EAAuByL,QAAvB,CAAT;;AAEA,YAAI2J,SAAJ,EAAe;AACb3P,UAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM9L,OAAlB;;AACA,eAAK2H,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC4I,UAAL,CAAgBhQ,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;AACpDxC,YAAAA,MAAM,CAAC2G,IAAP,CAAYpM,MAAZ;AACAyF,YAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CACE1B,IAAI,CAAC4I,UAAL,CAAgB7N,CAAhB,CADF,EAEEvI,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CADF;;AAOA,gBAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,cAAAA,MAAM,CAAC2G,IAAP,CAAY,MAAM9L,OAAlB;AACD;AACF;AACF;AACF,OApBS,CAAV;;AAsBA,UAAI,CAACsF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA3B,EAAwE;AACtE9B,QAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;;AACDmF,MAAAA,MAAM,CAAC2G,IAAP,CAAYrM,IAAZ;AACA0F,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA,aAAO3G,MAAP;AACD,KAlhBwB;AAohBzBkQ,IAAAA,iBAAiB,EAAE,2BAASzI,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACnD,aAAO,KAAKmH,kBAAL,CACLjC,IAAI,CAAClD,IADA,EAELkD,IAAI,CAACjD,KAFA,EAGL,GAHK,EAILkD,UAJK,EAKLnF,KALK,CAAP;AAOD,KA5hBwB;AA8hBzB+N,IAAAA,aAAa,EAAE,uBAAS7I,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC/C,UAAIvC,MAAJ;AAAA,UACEwC,CADF;AAAA,UAEEC,EAFF;AAAA,UAGEkN,SAHF;AAAA,UAIEb,QAJF;AAAA,UAKE9G,IAAI,GAAG,IALT;;AAMA,UAAI,CAACP,IAAI,CAAC4I,UAAL,CAAgBhQ,MAArB,EAA6B;AAC3B,eAAO,IAAP;AACD;;AAEDsP,MAAAA,SAAS,GAAG,KAAZ;;AACA,UAAIlI,IAAI,CAAC4I,UAAL,CAAgBhQ,MAAhB,KAA2B,CAA/B,EAAkC;AAChCyO,QAAAA,QAAQ,GAAGrH,IAAI,CAAC4I,UAAL,CAAgB,CAAhB,CAAX;;AACA,YAAIvB,QAAQ,CAAC3N,KAAT,CAAenF,IAAf,KAAwBhC,MAAM,CAACkP,UAAnC,EAA+C;AAC7CyG,UAAAA,SAAS,GAAG,IAAZ;AACD;AACF,OALD,MAKO;AACL,aAAKnN,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC4I,UAAL,CAAgBhQ,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;AACpDsM,UAAAA,QAAQ,GAAGrH,IAAI,CAAC4I,UAAL,CAAgB7N,CAAhB,CAAX;;AACA,cAAI,CAACsM,QAAQ,CAACmB,SAAd,EAAyB;AACvBN,YAAAA,SAAS,GAAG,IAAZ;AACA;AACD;AACF;AACF;;AACD3P,MAAAA,MAAM,GAAG,CAAC,GAAD,EAAM2P,SAAS,GAAG9U,OAAH,GAAa,EAA5B,CAAT;AAEAmK,MAAAA,UAAU,CAAC,UAASzK,MAAT,EAAiB;AAC1B,YAAIiI,CAAJ,EAAOC,EAAP;;AACA,aAAKD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC4I,UAAL,CAAgBhQ,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;AACpDxC,UAAAA,MAAM,CAAC2G,IAAP,CAAYgJ,SAAS,GAAGpV,MAAH,GAAY,EAAjC;AACAyF,UAAAA,MAAM,CAAC2G,IAAP,CACEqB,IAAI,CAACmB,kBAAL,CACE1B,IAAI,CAAC4I,UAAL,CAAgB7N,CAAhB,CADF,EAEEvI,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CADF;;AAOA,cAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,YAAAA,MAAM,CAAC2G,IAAP,CAAY,OAAOgJ,SAAS,GAAG9U,OAAH,GAAaC,KAA7B,CAAZ;AACD;AACF;AACF,OAfS,CAAV;;AAiBA,UACE6U,SAAS,IACT,CAACxP,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAFzB,EAGE;AACA9B,QAAAA,MAAM,CAAC2G,IAAP,CAAY9L,OAAZ;AACD;;AACDmF,MAAAA,MAAM,CAAC2G,IAAP,CAAYgJ,SAAS,GAAGrV,IAAH,GAAU,EAA/B;AACA0F,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA,aAAO3G,MAAP;AACD,KAplBwB;AAslBzBuQ,IAAAA,cAAc,EAAE,wBAAS9I,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAChD,aAAO,MAAP;AACD,KAxlBwB;AA0lBzBiO,IAAAA,KAAK,EAAE,eAAS/I,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACvC,aAAO,OAAP;AACD,KA5lBwB;AA8lBzB2G,IAAAA,UAAU,EAAE,oBAASzB,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC5C,aAAO+F,kBAAkB,CAACb,IAAD,CAAzB;AACD,KAhmBwB;AAkmBzByE,IAAAA,sBAAsB,EAAE,gCAASzE,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACxD,aAAO+F,kBAAkB,CAACb,IAAI,CAACmD,EAAL,IAAWnD,IAAI,CAACgJ,KAAjB,CAAzB;AACD,KApmBwB;AAsmBzBtE,IAAAA,wBAAwB,EAAE,kCAAS1E,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC1D,UAAIvC,MAAM,GAAG,CAAC,GAAD,CAAb;AACA,UAAI4K,EAAE,GAAGnD,IAAI,CAACmD,EAAL,IAAWnD,IAAI,CAACgJ,KAAzB;;AACA,UAAI7F,EAAJ,EAAQ;AACN5K,QAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAK,GAAG,IAAR,GAAeuJ,YAAY,EAA3B,GAAgCiE,kBAAkB,CAACsC,EAAD,CAA9D;AACD;;AACD,aAAO5K,MAAP;AACD,KA7mBwB;AA+mBzB0Q,IAAAA,eAAe,EAAE,yBAASjJ,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,UAAIoO,QAAQ,GAAGlJ,IAAI,CAACkJ,QAApB;AACA,UAAI3Q,MAAM,GAAG,CAAC2Q,QAAQ,CAAC1M,IAAV,CAAb;AACA,UAAIwM,KAAK,GAAGhJ,IAAI,CAACgJ,KAAjB;;AACA,UAAIA,KAAK,IAAIA,KAAK,CAACxM,IAAN,KAAe0M,QAAQ,CAAC1M,IAArC,EAA2C;AACzCjE,QAAAA,MAAM,CAAC2G,IAAP,CACEtC,YAAY,KAAK,IAAjB,GAAwBA,YAAY,EAApC,GAAyCiE,kBAAkB,CAACmI,KAAD,CAD7D;AAGD;;AACD,aAAOzQ,MAAP;AACD,KAznBwB;AA2nBzB4Q,IAAAA,eAAe,EAAE,yBAASnJ,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,UAAIkO,KAAK,GAAGhJ,IAAI,CAACgJ,KAAjB;AACA,UAAIzQ,MAAM,GAAG,CAACyQ,KAAK,CAACxM,IAAP,CAAb;AACA,UAAI4M,QAAQ,GAAGpJ,IAAI,CAACoJ,QAApB;;AACA,UAAIA,QAAQ,IAAIA,QAAQ,CAAC5M,IAAT,KAAkBwM,KAAK,CAACxM,IAAxC,EAA8C;AAC5CjE,QAAAA,MAAM,CAAC2G,IAAP,CACEtC,YAAY,KAAK,IAAjB,GAAwBA,YAAY,EAApC,GAAyCiE,kBAAkB,CAACuI,QAAD,CAD7D;AAGD;;AACD,aAAO7Q,MAAP;AACD,KAroBwB;AAuoBzB+L,IAAAA,OAAO,EAAE,iBAAStE,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACzC,UAAI5C,GAAJ;;AACA,UAAI8H,IAAI,CAAC1L,cAAL,CAAoB,KAApB,KAA8BX,KAA9B,IAAuCD,KAAK,CAACwE,GAAjD,EAAsD;AACpD,YAAI;AACFA,UAAAA,GAAG,GAAGvE,KAAK,CAACqM,IAAI,CAAC9H,GAAN,CAAL,CAAgBkH,IAAhB,CAAqB,CAArB,EAAwB+C,UAA9B;;AACA,cAAIjK,GAAG,CAAC3D,IAAJ,KAAahC,MAAM,CAAC+R,OAAxB,EAAiC;AAC/B,gBAAIpM,GAAG,CAACwB,KAAJ,KAAcsG,IAAI,CAACtG,KAAvB,EAA8B;AAC5B,qBAAOsG,IAAI,CAAC9H,GAAZ;AACD;AACF;AACF,SAPD,CAOE,OAAOmR,CAAP,EAAU,CACV;AACD;AACF;;AAED,UAAIrJ,IAAI,CAACsJ,KAAT,EAAgB;AACd,eAAO,MAAMtJ,IAAI,CAACsJ,KAAL,CAAWC,OAAjB,GAA2B,GAA3B,GAAiCvJ,IAAI,CAACsJ,KAAL,CAAWxO,KAAnD;AACD;;AAED,UAAIkF,IAAI,CAACtG,KAAL,KAAe,IAAnB,EAAyB;AACvB,eAAO,MAAP;AACD;;AAED,UAAI,OAAOsG,IAAI,CAACtG,KAAZ,KAAsB,QAA1B,EAAoC;AAClC,eAAOiC,YAAY,CAACqE,IAAI,CAACtG,KAAN,CAAnB;AACD;;AAED,UAAI,OAAOsG,IAAI,CAACtG,KAAZ,KAAsB,QAA1B,EAAoC;AAClC,eAAOD,cAAc,CAACuG,IAAI,CAACtG,KAAN,CAArB;AACD;;AAED,UAAI,OAAOsG,IAAI,CAACtG,KAAZ,KAAsB,SAA1B,EAAqC;AACnC,eAAOsG,IAAI,CAACtG,KAAL,GAAa,MAAb,GAAsB,OAA7B;AACD;;AAED,aAAOiB,cAAc,CAACqF,IAAI,CAACtG,KAAN,CAArB;AACD,KA3qBwB;AA6qBzB8P,IAAAA,mBAAmB,EAAE,6BAASxJ,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACrD,aAAO,KAAK2O,uBAAL,CAA6BzJ,IAA7B,EAAmCC,UAAnC,EAA+CnF,KAA/C,CAAP;AACD,KA/qBwB;AAirBzB2O,IAAAA,uBAAuB,EAAE,iCAASzJ,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACzD;AACA;AAEA,UAAIvC,MAAJ;AAAA,UACEwC,CADF;AAAA,UAEEC,EAFF;AAAA,UAGEuD,QAHF;AAAA,UAIEgC,IAAI,GAAG,IAJT;AAKAhI,MAAAA,MAAM,GAAGyH,IAAI,CAACzL,IAAL,KAAchC,MAAM,CAACiX,mBAArB,GAA2C,CAAC,GAAD,CAA3C,GAAmD,CAAC,GAAD,CAA5D;;AAEA,UAAI9V,KAAK,CAACmE,GAAN,CAAUC,2CAAd,EAA2D;AACzDyG,QAAAA,QAAQ,GAAG,KAAKmD,kBAAL,CACT1B,IAAI,CAACZ,IADI,EAET5M,UAAU,CAACoC,UAFF,EAGTkC,KAHS,CAAX;AAKAyB,QAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;AACD;;AAED,UAAIyB,IAAI,CAAC0J,MAAT,EAAiB;AACfnM,QAAAA,UAAU,CAAC,YAAW;AACpB,eAAKxC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC0J,MAAL,CAAY9Q,MAA7B,EAAqCmC,CAAC,GAAGC,EAAzC,EAA6C,EAAED,CAA/C,EAAkD;AAChDwD,YAAAA,QAAQ,GAAGgC,IAAI,CAACmB,kBAAL,CACT1B,IAAI,CAAC0J,MAAL,CAAY3O,CAAZ,CADS,EAETvI,UAAU,CAACkC,QAFF,EAGToC,KAHS,CAAX;;AAKA,gBACEiE,CAAC,GAAG,CAAJ,IACArH,KAAK,CAACmE,GAAN,CAAUC,2CAFZ,EAGE;AACAS,cAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;AACD,aALD,MAKO;AACLhG,cAAAA,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;AACD;AACF;AACF,SAhBS,CAAV;AAiBD;;AAED,UAAIyB,IAAI,CAAC2J,MAAT,EAAiB;AACfpR,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,OAAOlF,KAAhB,CAAb;AACAkL,QAAAA,QAAQ,GAAG,KAAKmD,kBAAL,CACT1B,IAAI,CAAC2J,MADI,EAETnX,UAAU,CAACkC,QAFF,EAGToC,KAHS,CAAX;AAKAyB,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CAAC,GAAD,EAAMgG,QAAN,EAAgB,GAAhB,CAAT,CAAb;AACD;;AAED,UAAI,CAAC7K,KAAK,CAACmE,GAAN,CAAUC,2CAAf,EAA4D;AAC1DyG,QAAAA,QAAQ,GAAG,KAAKmD,kBAAL,CACT1B,IAAI,CAACZ,IADI,EAET5M,UAAU,CAACoC,UAFF,EAGTkC,KAHS,CAAX;AAMAyB,QAAAA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;AACD;;AAEDhG,MAAAA,MAAM,CAAC2G,IAAP,CAAYc,IAAI,CAACzL,IAAL,KAAchC,MAAM,CAACiX,mBAArB,GAA2C,GAA3C,GAAiD,GAA7D;AACA,aAAOjR,MAAP;AACD,KA/uBwB;AAivBzBqR,IAAAA,kBAAkB,EAAE,4BAAS5J,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACpD,UAAIyD,QAAJ;;AACA,UAAIyB,IAAI,CAAClD,IAAL,CAAUvI,IAAV,KAAmBhC,MAAM,CAACiQ,mBAA9B,EAAmD;AACjDjE,QAAAA,QAAQ,GAAG,CACTyB,IAAI,CAAClD,IAAL,CAAU2F,IADD,EAET7F,YAAY,EAFH,EAGT,KAAK6D,iBAAL,CAAuBT,IAAI,CAAClD,IAAL,CAAU4F,YAAV,CAAuB,CAAvB,CAAvB,EAAkDtL,MAAlD,CAHS,CAAX;AAKD,OAND,MAMO;AACLmH,QAAAA,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAAClD,IAA7B,EAAmCtK,UAAU,CAACqD,IAA9C,EAAoDiB,KAApD,CAAX;AACD;;AAEDyH,MAAAA,QAAQ,GAAG1B,IAAI,CAAC0B,QAAD,EAAWyB,IAAI,CAAC6J,EAAL,GAAU,IAAV,GAAiB,IAA5B,CAAf;AACAtL,MAAAA,QAAQ,GAAG1B,IAAI,CACb0B,QADa,EAEb,KAAKmD,kBAAL,CAAwB1B,IAAI,CAACjD,KAA7B,EAAoCvK,UAAU,CAACkC,QAA/C,EAAyDoC,KAAzD,CAFa,CAAf;AAKA,aAAO,CAAC,QAAQzD,KAAR,GAAgB,GAAjB,EAAsBkL,QAAtB,EAAgC,GAAhC,CAAP;AACD,KApwBwB;AAswBzBuL,IAAAA,aAAa,EAAE,uBAAS9J,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC/C,aAAO,CACL,KADK,EAEL,KAAK4G,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCxS,UAAU,CAACoC,UAAlD,EAA8DkC,KAA9D,CAFK,CAAP;AAID,KA3wBwB;AA6wBzBiT,IAAAA,wBAAwB,EAAE,kCAAS/J,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AAC1D,UAAI8J,SAAS,GAAG/N,KAAhB;;AACA,UAAI,EAAEiE,KAAK,GAAGvE,YAAV,CAAJ,EAA6B;AAC3BqO,QAAAA,SAAS,GAAG7N,KAAZ;AACD;;AACD,UAAIwB,MAAM,GAAG,CACX,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACgK,GAA7B,EAAkCxX,UAAU,CAACqD,IAA7C,EAAmD+O,SAAnD,CADW,EAEX,KAAKlD,kBAAL,CAAwB1B,IAAI,CAACiK,KAA7B,EAAoCzX,UAAU,CAACyD,OAA/C,EAAwDe,KAAxD,CAFW,CAAb;AAIA,aAAOyI,YAAY,CAAClH,MAAD,EAAS/F,UAAU,CAACuD,cAApB,EAAoCkK,UAApC,CAAnB;AACD,KAvxBwB;AAyxBzBiK,IAAAA,eAAe,EAAE,yBAASlK,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD;AACA;AACA,aAAOkF,IAAI,CAACtG,KAAL,CAAWxB,GAAlB;AACD,KA7xBwB;AA+xBzBiS,IAAAA,eAAe,EAAE,yBAASnK,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,UAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf;AACAzC,MAAAA,MAAM,GAAG,CAAC,GAAD,CAAT;;AACA,WAAKwC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAACoK,MAAL,CAAYxR,MAA7B,EAAqCmC,CAAC,GAAGC,EAAzC,EAA6C,EAAED,CAA/C,EAAkD;AAChDxC,QAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKwC,kBAAL,CAAwB1B,IAAI,CAACoK,MAAL,CAAYrP,CAAZ,CAAxB,EAAwCvI,UAAU,CAACyD,OAAnD,EAA4Da,KAA5D,CADF;;AAGA,YAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;AACdzC,UAAAA,MAAM,CAAC2G,IAAP,CAAY,OAAO7L,KAAnB;AACAkF,UAAAA,MAAM,CAAC2G,IAAP,CACE,KAAKwC,kBAAL,CACE1B,IAAI,CAACyG,WAAL,CAAiB1L,CAAjB,CADF,EAEEvI,UAAU,CAACkC,QAFb,EAGEoC,KAHF,CADF;AAOAyB,UAAAA,MAAM,CAAC2G,IAAP,CAAY7L,KAAK,GAAG,GAApB;AACD;AACF;;AACDkF,MAAAA,MAAM,CAAC2G,IAAP,CAAY,GAAZ;AACA,aAAO3G,MAAP;AACD,KApzBwB;AAszBzB8R,IAAAA,eAAe,EAAE,yBAASrK,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;AACjD,aAAO,KAAKwJ,OAAL,CAAatE,IAAb,EAAmBC,UAAnB,EAA+BnF,KAA/B,CAAP;AACD,KAxzBwB;AA0zBzBwP,IAAAA,gBAAgB,EAAE,0BAAStK,IAAT,EAAeC,UAAf,EAA2BsK,IAA3B,EAAiC;AACjD,aAAO9K,YAAY,CACjB,CACE,SADF,EAEE,KAAKiC,kBAAL,CAAwB1B,IAAI,CAAC9E,MAA7B,EAAqC1I,UAAU,CAACoC,UAAhD,EAA4DkC,KAA5D,CAFF,EAGE,GAHF,CADiB,EAMjBtE,UAAU,CAACqD,IANM,EAOjBoK,UAPiB,CAAnB;AASD;AAp0BwB,GAA3B;AAu0BAjH,EAAAA,KAAK,CAAC5E,aAAa,CAACgM,SAAf,EAA0BhM,aAAa,CAACC,UAAxC,CAAL;;AAEAD,EAAAA,aAAa,CAACgM,SAAd,CAAwBsB,kBAAxB,GAA6C,UAC3C1B,IAD2C,EAE3CC,UAF2C,EAG3CnF,KAH2C,EAI3C;AACA,QAAIvC,MAAJ,EAAYhE,IAAZ;AAEAA,IAAAA,IAAI,GAAGyL,IAAI,CAACzL,IAAL,IAAahC,MAAM,CAACgW,QAA3B;;AAEA,QAAI7U,KAAK,CAACyE,QAAN,IAAkB6H,IAAI,CAAC1L,cAAL,CAAoBZ,KAAK,CAACyE,QAA1B,CAAtB,EAA2D;AACzD,aAAO4H,gBAAgB,CAACC,IAAD,EAAOC,UAAP,CAAvB;AACD;;AAED1H,IAAAA,MAAM,GAAG,KAAKhE,IAAL,EAAWyL,IAAX,EAAiBC,UAAjB,EAA6BnF,KAA7B,CAAT;;AAEA,QAAIpH,KAAK,CAAC8D,OAAV,EAAmB;AACjBe,MAAAA,MAAM,GAAG6F,WAAW,CAAC4B,IAAD,EAAOzH,MAAP,CAApB;AACD;;AACD,WAAO8D,sBAAsB,CAAC9D,MAAD,EAASyH,IAAT,CAA7B;AACD,GAnBD;;AAqBA5L,EAAAA,aAAa,CAACgM,SAAd,CAAwBK,iBAAxB,GAA4C,UAASnD,IAAT,EAAexC,KAAf,EAAsB;AAChE,QAAIvC,MAAJ,EAAYgG,QAAZ;AAEAhG,IAAAA,MAAM,GAAG,KAAK+E,IAAI,CAAC/I,IAAV,EAAgB+I,IAAhB,EAAsBxC,KAAtB,CAAT,CAHgE,CAKhE;;AAEA,QAAIpH,KAAK,CAAC8D,OAAV,EAAmB;AACjBe,MAAAA,MAAM,GAAG6F,WAAW,CAACd,IAAD,EAAO/E,MAAP,CAApB;AACD;;AAEDgG,IAAAA,QAAQ,GAAGlC,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAX;;AACA,QACEiD,IAAI,CAAC/I,IAAL,KAAchC,MAAM,CAAC4M,OAArB,IACA,CAAC3L,iBADD,IAEAJ,OAAO,KAAK,EAFZ,IAGAmL,QAAQ,CAAC6D,MAAT,CAAgB7D,QAAQ,CAAC3F,MAAT,GAAkB,CAAlC,MAAyC,IAJ3C,EAKE;AACAL,MAAAA,MAAM,GAAG3E,SAAS,GACdyI,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+BiS,YAA/B,CAA4C,MAA5C,EAAoD,EAApD,CADc,GAEdjM,QAAQ,CAACrE,OAAT,CAAiB,MAAjB,EAAyB,EAAzB,CAFJ;AAGD;;AAED,WAAOmC,sBAAsB,CAAC9D,MAAD,EAAS+E,IAAT,CAA7B;AACD,GAxBD;;AA0BA,WAASmN,gBAAT,CAA0BtW,IAA1B,EAAgC;AAC9B,QAAIuW,OAAJ;AAEAA,IAAAA,OAAO,GAAG,IAAItW,aAAJ,EAAV;;AACA,QAAII,WAAW,CAACL,IAAD,CAAf,EAAuB;AACrB,aAAOuW,OAAO,CAACjK,iBAAR,CAA0BtM,IAA1B,EAAgC+C,MAAhC,CAAP;AACD;;AAED,QAAIhD,YAAY,CAACC,IAAD,CAAhB,EAAwB;AACtB,aAAOuW,OAAO,CAAChJ,kBAAR,CAA2BvN,IAA3B,EAAiC3B,UAAU,CAACkC,QAA5C,EAAsDoC,KAAtD,CAAP;AACD;;AAED,UAAM,IAAIiD,KAAJ,CAAU,wBAAwB5F,IAAI,CAACI,IAAvC,CAAN;AACD;;AAED,WAASoW,QAAT,CAAkBxW,IAAlB,EAAwByW,OAAxB,EAAiC;AAC/B,QAAIC,cAAc,GAAGtT,iBAAiB,EAAtC;AAAA,QACEgB,MADF;AAAA,QAEEuS,IAFF;;AAGA,QAAIF,OAAO,IAAI,IAAf,EAAqB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,UAAI,OAAOA,OAAO,CAAC9X,MAAf,KAA0B,QAA9B,EAAwC;AACtC+X,QAAAA,cAAc,CAACpT,MAAf,CAAsB3E,MAAtB,CAA6B4E,KAA7B,GAAqCkT,OAAO,CAAC9X,MAA7C;AACD;;AACD,UAAI,OAAO8X,OAAO,CAAC/X,IAAf,KAAwB,QAA5B,EAAsC;AACpCgY,QAAAA,cAAc,CAACpT,MAAf,CAAsB3E,MAAtB,CAA6BD,IAA7B,GAAoC+X,OAAO,CAAC/X,IAA5C;AACD;;AACD+X,MAAAA,OAAO,GAAGxR,YAAY,CAACyR,cAAD,EAAiBD,OAAjB,CAAtB;AACA9X,MAAAA,MAAM,GAAG8X,OAAO,CAACnT,MAAR,CAAe3E,MAAf,CAAsB4E,KAA/B;;AACA,UAAI,OAAOkT,OAAO,CAAC/X,IAAf,KAAwB,QAA5B,EAAsC;AACpCA,QAAAA,IAAI,GAAG+X,OAAO,CAAC/X,IAAf;AACD,OAFD,MAEO;AACLA,QAAAA,IAAI,GAAGuF,YAAY,CAACtF,MAAD,EAAS8X,OAAO,CAACnT,MAAR,CAAe3E,MAAf,CAAsBD,IAA/B,CAAnB;AACD;AACF,KApBD,MAoBO;AACL+X,MAAAA,OAAO,GAAGC,cAAV;AACA/X,MAAAA,MAAM,GAAG8X,OAAO,CAACnT,MAAR,CAAe3E,MAAf,CAAsB4E,KAA/B;AACA7E,MAAAA,IAAI,GAAGuF,YAAY,CAACtF,MAAD,EAAS8X,OAAO,CAACnT,MAAR,CAAe3E,MAAf,CAAsBD,IAA/B,CAAnB;AACD;;AACDE,IAAAA,IAAI,GAAG6X,OAAO,CAACnT,MAAR,CAAe1E,IAAtB;AACAC,IAAAA,QAAQ,GAAG4X,OAAO,CAACnT,MAAR,CAAezE,QAA1B;AACAC,IAAAA,WAAW,GAAGF,IAAI,GAAG,KAAH,GAAW6X,OAAO,CAACnT,MAAR,CAAexE,WAA5C;AACAC,IAAAA,MAAM,GAAGH,IAAI,GAAG,QAAH,GAAc6X,OAAO,CAACnT,MAAR,CAAevE,MAA1C;AACAC,IAAAA,UAAU,GAAGyX,OAAO,CAACnT,MAAR,CAAetE,UAA5B;AACAC,IAAAA,OAAO,GAAGwX,OAAO,CAACnT,MAAR,CAAerE,OAAzB;AACAC,IAAAA,KAAK,GAAGuX,OAAO,CAACnT,MAAR,CAAepE,KAAvB;;AACA,QAAIuX,OAAO,CAACnT,MAAR,CAAeG,OAAnB,EAA4B;AAC1BxE,MAAAA,OAAO,GAAGC,KAAK,GAAGP,MAAM,GAAGD,IAAI,GAAG,EAAlC;AACD;;AACDS,IAAAA,WAAW,GAAGsX,OAAO,CAACnT,MAAR,CAAenE,WAA7B;AACAC,IAAAA,UAAU,GAAGqX,OAAO,CAACnT,MAAR,CAAelE,UAA5B;AACAC,IAAAA,iBAAiB,GAAGoX,OAAO,CAACnT,MAAR,CAAejE,iBAAnC;AACAC,IAAAA,SAAS,GAAGmX,OAAO,CAACnX,SAApB;AACAE,IAAAA,KAAK,GAAGZ,IAAI,GAAG,IAAH,GAAU6X,OAAO,CAACjX,KAA9B;AACAC,IAAAA,SAAS,GAAGgX,OAAO,CAAChX,SAApB;AACAC,IAAAA,UAAU,GAAG+W,OAAO,CAAC/W,UAArB;AACAC,IAAAA,kBAAkB,GAChB8W,OAAO,CAACnT,MAAR,CAAe3D,kBAAf,IAAqCD,UAAU,KAAK,IADtD;AAEAH,IAAAA,KAAK,GAAGkX,OAAR;;AAEA,QAAIhX,SAAJ,EAAe;AACb,UAAI,CAACmX,OAAO,CAACC,OAAb,EAAsB;AACpB;AACA;AACAtY,QAAAA,UAAU,GAAGuB,OAAO,CAAC,YAAD,CAAP,CAAsBvB,UAAnC;AACD,OAJD,MAIO;AACLA,QAAAA,UAAU,GAAGuY,MAAM,CAACrX,SAAP,CAAiBlB,UAA9B;AACD;AACF;;AAED6F,IAAAA,MAAM,GAAGkS,gBAAgB,CAACtW,IAAD,CAAzB;;AAEA,QAAI,CAACP,SAAL,EAAgB;AACdkX,MAAAA,IAAI,GAAG;AAAEjS,QAAAA,IAAI,EAAEN,MAAM,CAAC8B,QAAP,EAAR;AAA2B6Q,QAAAA,GAAG,EAAE;AAAhC,OAAP;AACA,aAAON,OAAO,CAAC3S,iBAAR,GAA4B6S,IAA5B,GAAmCA,IAAI,CAACjS,IAA/C;AACD;;AAEDiS,IAAAA,IAAI,GAAGvS,MAAM,CAAC4S,qBAAP,CAA6B;AAClCC,MAAAA,IAAI,EAAER,OAAO,CAACQ,IADoB;AAElCC,MAAAA,UAAU,EAAET,OAAO,CAAC5S;AAFc,KAA7B,CAAP;;AAKA,QAAI4S,OAAO,CAACU,aAAZ,EAA2B;AACzBR,MAAAA,IAAI,CAACI,GAAL,CAASK,gBAAT,CAA0BX,OAAO,CAAChX,SAAlC,EAA6CgX,OAAO,CAACU,aAArD;AACD;;AAED,QAAIV,OAAO,CAAC3S,iBAAZ,EAA+B;AAC7B,aAAO6S,IAAP;AACD;;AAED,WAAOA,IAAI,CAACI,GAAL,CAAS7Q,QAAT,EAAP;AACD;;AAEDtG,EAAAA,aAAa,GAAG;AACdjB,IAAAA,MAAM,EAAE;AACN4E,MAAAA,KAAK,EAAE,EADD;AAEN7E,MAAAA,IAAI,EAAE;AAFA,KADM;AAKdG,IAAAA,QAAQ,EAAE,IALI;AAMdC,IAAAA,WAAW,EAAE,IANC;AAOdC,IAAAA,MAAM,EAAE,MAPM;AAQdC,IAAAA,UAAU,EAAE,IARE;AASdyE,IAAAA,OAAO,EAAE,IATK;AAUdtE,IAAAA,WAAW,EAAE,KAVC;AAWdC,IAAAA,UAAU,EAAE;AAXE,GAAhB;AAcAS,EAAAA,eAAe,GAAGuD,iBAAiB,GAAGE,MAAtC;AAEAsT,EAAAA,OAAO,CAACJ,QAAR,GAAmBA,QAAnB;AACAI,EAAAA,OAAO,CAACS,cAAR,GAAyB7Y,UAAU,CAAC6Y,cAApC;AACAT,EAAAA,OAAO,CAACvY,UAAR,GAAqB4G,YAAY,CAAC,EAAD,EAAK5G,UAAL,CAAjC;AACAuY,EAAAA,OAAO,CAACC,OAAR,GAAkB,KAAlB;AACAD,EAAAA,OAAO,CAAChX,aAAR,GAAwBA,aAAxB;AACAgX,EAAAA,OAAO,CAAC/W,eAAR,GAA0BA,eAA1B;AACD,CAviGD;AAwiGA","sourcesContent":["/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*global exports:true, require:true, global:true*/\n(function() {\n  // \"use strict\";\n\n  var Syntax,\n    Precedence,\n    BinaryPrecedence,\n    SourceNode,\n    estraverse,\n    esutils,\n    base,\n    indent,\n    json,\n    renumber,\n    hexadecimal,\n    quotes,\n    escapeless,\n    newline,\n    space,\n    parentheses,\n    semicolons,\n    safeConcatenation,\n    directive,\n    extra,\n    parse,\n    sourceMap,\n    sourceCode,\n    preserveBlankLines,\n    FORMAT_MINIFY,\n    FORMAT_DEFAULTS;\n\n  estraverse = require(\"estraverse\");\n  esutils = require(\"esutils\");\n\n  Syntax = estraverse.Syntax;\n\n  // Generation is done by generateExpression.\n  function isExpression(node) {\n    return CodeGenerator.Expression.hasOwnProperty(node.type);\n  }\n\n  // Generation is done by generateStatement.\n  function isStatement(node) {\n    return CodeGenerator.Statement.hasOwnProperty(node.type);\n  }\n\n  Precedence = {\n    Sequence: 0,\n    Yield: 1,\n    Assignment: 1,\n    Conditional: 2,\n    ArrowFunction: 2,\n    LogicalOR: 3,\n    LogicalAND: 4,\n    BitwiseOR: 5,\n    BitwiseXOR: 6,\n    BitwiseAND: 7,\n    Equality: 8,\n    Relational: 9,\n    BitwiseSHIFT: 10,\n    Additive: 11,\n    Multiplicative: 12,\n    Exponentiation: 13,\n    Await: 14,\n    Unary: 14,\n    Postfix: 15,\n    Call: 16,\n    New: 17,\n    TaggedTemplate: 18,\n    Member: 19,\n    Primary: 20\n  };\n\n  BinaryPrecedence = {\n    \"||\": Precedence.LogicalOR,\n    \"&&\": Precedence.LogicalAND,\n    \"|\": Precedence.BitwiseOR,\n    \"^\": Precedence.BitwiseXOR,\n    \"&\": Precedence.BitwiseAND,\n    \"==\": Precedence.Equality,\n    \"!=\": Precedence.Equality,\n    \"===\": Precedence.Equality,\n    \"!==\": Precedence.Equality,\n    is: Precedence.Equality,\n    isnt: Precedence.Equality,\n    \"<\": Precedence.Relational,\n    \">\": Precedence.Relational,\n    \"<=\": Precedence.Relational,\n    \">=\": Precedence.Relational,\n    in: Precedence.Relational,\n    instanceof: Precedence.Relational,\n    \"<<\": Precedence.BitwiseSHIFT,\n    \">>\": Precedence.BitwiseSHIFT,\n    \">>>\": Precedence.BitwiseSHIFT,\n    \"+\": Precedence.Additive,\n    \"-\": Precedence.Additive,\n    \"*\": Precedence.Multiplicative,\n    \"%\": Precedence.Multiplicative,\n    \"/\": Precedence.Multiplicative,\n    \"**\": Precedence.Exponentiation\n  };\n\n  //Flags\n  var F_ALLOW_IN = 1,\n    F_ALLOW_CALL = 1 << 1,\n    F_ALLOW_UNPARATH_NEW = 1 << 2,\n    F_FUNC_BODY = 1 << 3,\n    F_DIRECTIVE_CTX = 1 << 4,\n    F_SEMICOLON_OPT = 1 << 5;\n\n  //Expression flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_ALLOW_CALL\n  // F_ALLOW_UNPARATH_NEW\n  var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n    E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n    E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n    E_TFF = F_ALLOW_IN,\n    E_FFT = F_ALLOW_UNPARATH_NEW,\n    E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n\n  //Statement flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_FUNC_BODY\n  // F_DIRECTIVE_CTX\n  // F_SEMICOLON_OPT\n  var S_TFFF = F_ALLOW_IN,\n    S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n    S_FFFF = 0x00,\n    S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n    S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n\n  function getDefaultOptions() {\n    // default options\n    return {\n      indent: null,\n      base: null,\n      parse: null,\n      comment: false,\n      format: {\n        indent: {\n          style: \"    \",\n          base: 0,\n          adjustMultilineComment: false\n        },\n        newline: \"\\n\",\n        space: \" \",\n        json: false,\n        renumber: false,\n        hexadecimal: false,\n        quotes: \"single\",\n        escapeless: false,\n        compact: false,\n        parentheses: true,\n        semicolons: true,\n        safeConcatenation: false,\n        preserveBlankLines: false\n      },\n      moz: {\n        comprehensionExpressionStartsWithAssignment: false,\n        starlessGenerator: false\n      },\n      sourceMap: null,\n      sourceMapRoot: null,\n      sourceMapWithCode: false,\n      directive: false,\n      raw: true,\n      verbatim: null,\n      sourceCode: null\n    };\n  }\n\n  function stringRepeat(str, num) {\n    var result = \"\";\n\n    for (num |= 0; num > 0; num >>>= 1, str += str) {\n      if (num & 1) {\n        result += str;\n      }\n    }\n\n    return result;\n  }\n\n  function hasLineTerminator(str) {\n    return /[\\r\\n]/g.test(str);\n  }\n\n  function endsWithLineTerminator(str) {\n    var len = str.length;\n    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n  }\n\n  function merge(target, override) {\n    var key;\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        target[key] = override[key];\n      }\n    }\n    return target;\n  }\n\n  function updateDeeply(target, override) {\n    var key, val;\n\n    function isHashObject(target) {\n      return (\n        typeof target === \"object\" &&\n        target instanceof Object &&\n        !(target instanceof RegExp)\n      );\n    }\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        val = override[key];\n        if (isHashObject(val)) {\n          if (isHashObject(target[key])) {\n            updateDeeply(target[key], val);\n          } else {\n            target[key] = updateDeeply({}, val);\n          }\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n    return target;\n  }\n\n  function generateNumber(value) {\n    var result, point, temp, exponent, pos;\n\n    // eslint-disable-next-line\n    if (value !== value) {\n      throw new Error(\"Numeric literal whose value is NaN\");\n    }\n    if (value < 0 || (value === 0 && 1 / value < 0)) {\n      throw new Error(\"Numeric literal whose value is negative\");\n    }\n\n    if (value === 1 / 0) {\n      return json ? \"null\" : renumber ? \"1e400\" : \"1e+400\";\n    }\n\n    result = \"\" + value;\n    if (!renumber || result.length < 3) {\n      return result;\n    }\n\n    point = result.indexOf(\".\");\n    if (!json && result.charCodeAt(0) === 0x30 /* 0 */ && point === 1) {\n      point = 0;\n      result = result.slice(1);\n    }\n    temp = result;\n    result = result.replace(\"e+\", \"e\");\n    exponent = 0;\n    if ((pos = temp.indexOf(\"e\")) > 0) {\n      exponent = +temp.slice(pos + 1);\n      temp = temp.slice(0, pos);\n    }\n    if (point >= 0) {\n      exponent -= temp.length - point - 1;\n      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + \"\";\n    }\n    pos = 0;\n    while (temp.charCodeAt(temp.length + pos - 1) === 0x30 /* 0 */) {\n      --pos;\n    }\n    if (pos !== 0) {\n      exponent -= pos;\n      temp = temp.slice(0, pos);\n    }\n    if (exponent !== 0) {\n      temp += \"e\" + exponent;\n    }\n    if (\n      (temp.length < result.length ||\n        (hexadecimal &&\n          value > 1e12 &&\n          Math.floor(value) === value &&\n          (temp = \"0x\" + value.toString(16)).length < result.length)) &&\n      +temp === value\n    ) {\n      result = temp;\n    }\n\n    return result;\n  }\n\n  // Generate valid RegExp expression.\n  // This function is based on https://github.com/Constellation/iv Engine\n\n  function escapeRegExpCharacter(ch, previousIsBackslash) {\n    // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n    if ((ch & ~1) === 0x2028) {\n      return (\n        (previousIsBackslash ? \"u\" : \"\\\\u\") + (ch === 0x2028 ? \"2028\" : \"2029\")\n      );\n    } else if (ch === 10 || ch === 13) {\n      // \\n, \\r\n      return (previousIsBackslash ? \"\" : \"\\\\\") + (ch === 10 ? \"n\" : \"r\");\n    }\n    return String.fromCharCode(ch);\n  }\n\n  function generateRegExp(reg) {\n    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n\n    result = reg.toString();\n\n    if (reg.source) {\n      // extract flag from toString result\n      match = result.match(/\\/([^/]*)$/);\n      if (!match) {\n        return result;\n      }\n\n      flags = match[1];\n      result = \"\";\n\n      characterInBrack = false;\n      previousIsBackslash = false;\n      for (i = 0, iz = reg.source.length; i < iz; ++i) {\n        ch = reg.source.charCodeAt(i);\n\n        if (!previousIsBackslash) {\n          if (characterInBrack) {\n            if (ch === 93) {\n              // ]\n              characterInBrack = false;\n            }\n          } else {\n            if (ch === 47) {\n              // /\n              result += \"\\\\\";\n            } else if (ch === 91) {\n              // [\n              characterInBrack = true;\n            }\n          }\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          previousIsBackslash = ch === 92; // \\\n        } else {\n          // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          // prevent like /\\\\[/]/\n          previousIsBackslash = false;\n        }\n      }\n\n      return \"/\" + result + \"/\" + flags;\n    }\n\n    return result;\n  }\n\n  function escapeAllowedCharacter(code, next) {\n    var hex;\n\n    if (code === 0x08 /* \\b */) {\n      return \"\\\\b\";\n    }\n\n    if (code === 0x0c /* \\f */) {\n      return \"\\\\f\";\n    }\n\n    if (code === 0x09 /* \\t */) {\n      return \"\\\\t\";\n    }\n\n    hex = code.toString(16).toUpperCase();\n    if (json || code > 0xff) {\n      return \"\\\\u\" + \"0000\".slice(hex.length) + hex;\n    } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n      return \"\\\\0\";\n    } else if (code === 0x000b /* \\v */) {\n      // '\\v'\n      return \"\\\\x0B\";\n    } else {\n      return \"\\\\x\" + \"00\".slice(hex.length) + hex;\n    }\n  }\n\n  function escapeDisallowedCharacter(code) {\n    if (code === 0x5c /* \\ */) {\n      return \"\\\\\\\\\";\n    }\n\n    if (code === 0x0a /* \\n */) {\n      return \"\\\\n\";\n    }\n\n    if (code === 0x0d /* \\r */) {\n      return \"\\\\r\";\n    }\n\n    if (code === 0x2028) {\n      return \"\\\\u2028\";\n    }\n\n    if (code === 0x2029) {\n      return \"\\\\u2029\";\n    }\n\n    throw new Error(\"Incorrectly classified character\");\n  }\n\n  function escapeDirective(str) {\n    var i, iz, code, quote;\n\n    quote = quotes === \"double\" ? '\"' : \"'\";\n    for (i = 0, iz = str.length; i < iz; ++i) {\n      code = str.charCodeAt(i);\n      if (code === 0x27 /* ' */) {\n        quote = '\"';\n        break;\n      } else if (code === 0x22 /* \" */) {\n        quote = \"'\";\n        break;\n      } else if (code === 0x5c /* \\ */) {\n        ++i;\n      }\n    }\n\n    return quote + str + quote;\n  }\n\n  function escapeString(str) {\n    var result = \"\",\n      i,\n      len,\n      code,\n      singleQuotes = 0,\n      doubleQuotes = 0,\n      single,\n      quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n      if (code === 0x27 /* ' */) {\n        ++singleQuotes;\n      } else if (code === 0x22 /* \" */) {\n        ++doubleQuotes;\n      } else if (code === 0x2f /* / */ && json) {\n        result += \"\\\\\";\n      } else if (esutils.code.isLineTerminator(code) || code === 0x5c /* \\ */) {\n        result += escapeDisallowedCharacter(code);\n        continue;\n      } else if (\n        !esutils.code.isIdentifierPartES5(code) &&\n        ((json && code < 0x20) /* SP */ ||\n          (!json &&\n            !escapeless &&\n            (code < 0x20 /* SP */ || code > 0x7e))) /* ~ */\n      ) {\n        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n        continue;\n      }\n      result += String.fromCharCode(code);\n    }\n\n    single = !(\n      quotes === \"double\" ||\n      (quotes === \"auto\" && doubleQuotes < singleQuotes)\n    );\n    quote = single ? \"'\" : '\"';\n\n    if (!(single ? singleQuotes : doubleQuotes)) {\n      return quote + result + quote;\n    }\n\n    str = result;\n    result = quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n      if (\n        (code === 0x27 /* ' */ && single) ||\n        (code === 0x22 /* \" */ && !single)\n      ) {\n        result += \"\\\\\";\n      }\n      result += String.fromCharCode(code);\n    }\n\n    return result + quote;\n  }\n\n  /**\n   * flatten an array to a string, where the array can contain\n   * either strings or nested arrays\n   */\n  function flattenToString(arr) {\n    var i,\n      iz,\n      elem,\n      result = \"\";\n    for (i = 0, iz = arr.length; i < iz; ++i) {\n      elem = arr[i];\n      result += Array.isArray(elem) ? flattenToString(elem) : elem;\n    }\n    return result;\n  }\n\n  /**\n   * convert generated to a SourceNode when source maps are enabled.\n   */\n  function toSourceNodeWhenNeeded(generated, node) {\n    if (!sourceMap) {\n      // with no source maps, generated is either an\n      // array or a string.  if an array, flatten it.\n      // if a string, just return it\n      if (Array.isArray(generated)) {\n        return flattenToString(generated);\n      } else {\n        return generated;\n      }\n    }\n    if (node == null) {\n      if (generated instanceof SourceNode) {\n        return generated;\n      } else {\n        node = {};\n      }\n    }\n    if (node.loc == null) {\n      return new SourceNode(\n        null,\n        null,\n        sourceMap,\n        generated,\n        node.name || null\n      );\n    }\n    return new SourceNode(\n      node.loc.start.line,\n      node.loc.start.column,\n      sourceMap === true ? node.loc.source || null : sourceMap,\n      generated,\n      node.name || null\n    );\n  }\n\n  function noEmptySpace() {\n    return space ? space : \" \";\n  }\n\n  function join(left, right) {\n    var leftSource, rightSource, leftCharCode, rightCharCode;\n\n    leftSource = toSourceNodeWhenNeeded(left).toString();\n    if (leftSource.length === 0) {\n      return [right];\n    }\n\n    rightSource = toSourceNodeWhenNeeded(right).toString();\n    if (rightSource.length === 0) {\n      return [left];\n    }\n\n    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n    rightCharCode = rightSource.charCodeAt(0);\n\n    if (\n      ((leftCharCode === 0x2b /* + */ || leftCharCode === 0x2d) /* - */ &&\n        leftCharCode === rightCharCode) ||\n      (esutils.code.isIdentifierPartES5(leftCharCode) &&\n        esutils.code.isIdentifierPartES5(rightCharCode)) ||\n      (leftCharCode === 0x2f /* / */ && rightCharCode === 0x69) /* i */\n    ) {\n      // infix word operators all start with `i`\n      return [left, noEmptySpace(), right];\n    } else if (\n      esutils.code.isWhiteSpace(leftCharCode) ||\n      esutils.code.isLineTerminator(leftCharCode) ||\n      esutils.code.isWhiteSpace(rightCharCode) ||\n      esutils.code.isLineTerminator(rightCharCode)\n    ) {\n      return [left, right];\n    }\n    return [left, space, right];\n  }\n\n  function addIndent(stmt) {\n    return [base, stmt];\n  }\n\n  function withIndent(fn) {\n    var previousBase;\n    previousBase = base;\n    base += indent;\n    fn(base);\n    base = previousBase;\n  }\n\n  function calculateSpaces(str) {\n    var i;\n    for (i = str.length - 1; i >= 0; --i) {\n      if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n        break;\n      }\n    }\n    return str.length - 1 - i;\n  }\n\n  function adjustMultilineComment(value, specialBase) {\n    var array, i, len, line, j, spaces, previousBase, sn;\n\n    array = value.split(/\\r\\n|[\\r\\n]/);\n    spaces = Number.MAX_VALUE;\n\n    // first line doesn't have indentation\n    for (i = 1, len = array.length; i < len; ++i) {\n      line = array[i];\n      j = 0;\n      while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n        ++j;\n      }\n      if (spaces > j) {\n        spaces = j;\n      }\n    }\n\n    if (typeof specialBase !== \"undefined\") {\n      // pattern like\n      // {\n      //   var t = 20;  /*\n      //                 * this is comment\n      //                 */\n      // }\n      previousBase = base;\n      if (array[1][spaces] === \"*\") {\n        specialBase += \" \";\n      }\n      base = specialBase;\n    } else {\n      if (spaces & 1) {\n        // /*\n        //  *\n        //  */\n        // If spaces are odd number, above pattern is considered.\n        // We waste 1 space.\n        --spaces;\n      }\n      previousBase = base;\n    }\n\n    for (i = 1, len = array.length; i < len; ++i) {\n      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n      array[i] = sourceMap ? sn.join(\"\") : sn;\n    }\n\n    base = previousBase;\n\n    return array.join(\"\\n\");\n  }\n\n  function generateComment(comment, specialBase) {\n    if (comment.type === \"Line\") {\n      if (endsWithLineTerminator(comment.value)) {\n        return \"//\" + comment.value;\n      } else {\n        // Always use LineTerminator\n        var result = \"//\" + comment.value;\n        if (!preserveBlankLines) {\n          result += \"\\n\";\n        }\n        return result;\n      }\n    }\n    if (\n      extra.format.indent.adjustMultilineComment &&\n      /[\\n\\r]/.test(comment.value)\n    ) {\n      return adjustMultilineComment(\"/*\" + comment.value + \"*/\", specialBase);\n    }\n    return \"/*\" + comment.value + \"*/\";\n  }\n\n  function addComments(stmt, result) {\n    var i,\n      len,\n      comment,\n      save,\n      tailingToStatement,\n      specialBase,\n      fragment,\n      extRange,\n      range,\n      prevRange,\n      prefix,\n      infix,\n      suffix,\n      count;\n\n    if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n      save = result;\n\n      if (preserveBlankLines) {\n        comment = stmt.leadingComments[0];\n        result = [];\n\n        extRange = comment.extendedRange;\n        range = comment.range;\n\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n        if (count > 0) {\n          result.push(stringRepeat(\"\\n\", count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n\n        prevRange = range;\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n          comment = stmt.leadingComments[i];\n          range = comment.range;\n\n          infix = sourceCode.substring(prevRange[1], range[0]);\n          count = (infix.match(/\\n/g) || []).length;\n          result.push(stringRepeat(\"\\n\", count));\n          result.push(addIndent(generateComment(comment)));\n\n          prevRange = range;\n        }\n\n        suffix = sourceCode.substring(range[1], extRange[1]);\n        count = (suffix.match(/\\n/g) || []).length;\n        result.push(stringRepeat(\"\\n\", count));\n      } else {\n        comment = stmt.leadingComments[0];\n        result = [];\n        if (\n          safeConcatenation &&\n          stmt.type === Syntax.Program &&\n          stmt.body.length === 0\n        ) {\n          result.push(\"\\n\");\n        }\n        result.push(generateComment(comment));\n        if (\n          !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())\n        ) {\n          result.push(\"\\n\");\n        }\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n          comment = stmt.leadingComments[i];\n          fragment = [generateComment(comment)];\n          if (\n            !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())\n          ) {\n            fragment.push(\"\\n\");\n          }\n          result.push(addIndent(fragment));\n        }\n      }\n\n      result.push(addIndent(save));\n    }\n\n    if (stmt.trailingComments) {\n      if (preserveBlankLines) {\n        comment = stmt.trailingComments[0];\n        extRange = comment.extendedRange;\n        range = comment.range;\n\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n\n        if (count > 0) {\n          result.push(stringRepeat(\"\\n\", count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n      } else {\n        tailingToStatement = !endsWithLineTerminator(\n          toSourceNodeWhenNeeded(result).toString()\n        );\n        specialBase = stringRepeat(\n          \" \",\n          calculateSpaces(\n            toSourceNodeWhenNeeded([base, result, indent]).toString()\n          )\n        );\n        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n          comment = stmt.trailingComments[i];\n          if (tailingToStatement) {\n            // We assume target like following script\n            //\n            // var t = 20;  /**\n            //               * This is comment of t\n            //               */\n            if (i === 0) {\n              // first case\n              result = [result, indent];\n            } else {\n              result = [result, specialBase];\n            }\n            result.push(generateComment(comment, specialBase));\n          } else {\n            result = [result, addIndent(generateComment(comment))];\n          }\n          if (\n            i !== len - 1 &&\n            !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())\n          ) {\n            result = [result, \"\\n\"];\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function generateBlankLines(start, end, result) {\n    var j,\n      newlineCount = 0;\n\n    for (j = start; j < end; j++) {\n      if (sourceCode[j] === \"\\n\") {\n        newlineCount++;\n      }\n    }\n\n    for (j = 1; j < newlineCount; j++) {\n      result.push(newline);\n    }\n  }\n\n  function parenthesize(text, current, should) {\n    if (current < should) {\n      return [\"(\", text, \")\"];\n    }\n    return text;\n  }\n\n  function generateVerbatimString(string) {\n    var i, iz, result;\n    result = string.split(/\\r\\n|\\n/);\n    for (i = 1, iz = result.length; i < iz; i++) {\n      result[i] = newline + base + result[i];\n    }\n    return result;\n  }\n\n  function generateVerbatim(expr, precedence) {\n    var verbatim, result, prec;\n    verbatim = expr[extra.verbatim];\n\n    if (typeof verbatim === \"string\") {\n      result = parenthesize(\n        generateVerbatimString(verbatim),\n        Precedence.Sequence,\n        precedence\n      );\n    } else {\n      // verbatim is object\n      result = generateVerbatimString(verbatim.content);\n      prec =\n        verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n      result = parenthesize(result, prec, precedence);\n    }\n\n    return toSourceNodeWhenNeeded(result, expr);\n  }\n\n  function CodeGenerator() {}\n\n  // Helpers.\n\n  CodeGenerator.prototype.maybeBlock = function(stmt, flags) {\n    var result,\n      noLeadingComment,\n      that = this;\n\n    noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n      return [space, this.generateStatement(stmt, flags)];\n    }\n\n    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n      return \";\";\n    }\n\n    withIndent(function() {\n      result = [newline, addIndent(that.generateStatement(stmt, flags))];\n    });\n\n    return result;\n  };\n\n  CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {\n    var ends = endsWithLineTerminator(\n      toSourceNodeWhenNeeded(result).toString()\n    );\n    if (\n      stmt.type === Syntax.BlockStatement &&\n      (!extra.comment || !stmt.leadingComments) &&\n      !ends\n    ) {\n      return [result, space];\n    }\n    if (ends) {\n      return [result, base];\n    }\n    return [result, newline, base];\n  };\n\n  function generateIdentifier(node) {\n    return toSourceNodeWhenNeeded(node.name, node);\n  }\n\n  function generateAsyncPrefix(node, spaceRequired) {\n    return node.async ? \"async\" + (spaceRequired ? noEmptySpace() : space) : \"\";\n  }\n\n  function generateStarSuffix(node) {\n    var isGenerator = node.generator && !extra.moz.starlessGenerator;\n    return isGenerator ? \"*\" + space : \"\";\n  }\n\n  function generateMethodPrefix(prop) {\n    var func = prop.value,\n      prefix = \"\";\n    if (func.async) {\n      prefix += generateAsyncPrefix(func, !prop.computed);\n    }\n    if (func.generator) {\n      // avoid space before method name\n      prefix += generateStarSuffix(func) ? \"*\" : \"\";\n    }\n    return prefix;\n  }\n\n  CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {\n    if (node.type === Syntax.Identifier) {\n      return generateIdentifier(node);\n    }\n    return this.generateExpression(node, precedence, flags);\n  };\n\n  CodeGenerator.prototype.generateFunctionParams = function(node) {\n    var i, iz, result, hasDefault;\n\n    hasDefault = false;\n\n    if (\n      node.type === Syntax.ArrowFunctionExpression &&\n      !node.rest &&\n      (!node.defaults || node.defaults.length === 0) &&\n      node.params.length === 1 &&\n      node.params[0].type === Syntax.Identifier\n    ) {\n      // arg => { } case\n      result = [\n        generateAsyncPrefix(node, true),\n        generateIdentifier(node.params[0])\n      ];\n    } else {\n      result =\n        node.type === Syntax.ArrowFunctionExpression\n          ? [generateAsyncPrefix(node, false)]\n          : [];\n      result.push(\"(\");\n      if (node.defaults) {\n        hasDefault = true;\n      }\n      for (i = 0, iz = node.params.length; i < iz; ++i) {\n        if (hasDefault && node.defaults[i]) {\n          // Handle default values.\n          result.push(\n            this.generateAssignment(\n              node.params[i],\n              node.defaults[i],\n              \"=\",\n              Precedence.Assignment,\n              E_TTT\n            )\n          );\n        } else {\n          result.push(\n            this.generatePattern(node.params[i], Precedence.Assignment, E_TTT)\n          );\n        }\n        if (i + 1 < iz) {\n          result.push(\",\" + space);\n        }\n      }\n\n      if (node.rest) {\n        if (node.params.length) {\n          result.push(\",\" + space);\n        }\n        result.push(\"...\");\n        result.push(generateIdentifier(node.rest));\n      }\n\n      result.push(\")\");\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateFunctionBody = function(node) {\n    var result, expr;\n\n    result = this.generateFunctionParams(node);\n\n    if (node.type === Syntax.ArrowFunctionExpression) {\n      result.push(space);\n      result.push(\"=>\");\n    }\n\n    if (node.expression) {\n      result.push(space);\n      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n      if (expr.toString().charAt(0) === \"{\") {\n        expr = [\"(\", expr, \")\"];\n      }\n      result.push(expr);\n    } else {\n      result.push(this.maybeBlock(node.body, S_TTFF));\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateIterationForStatement = function(\n    operator,\n    stmt,\n    flags\n  ) {\n    var result = [\n        \"for\" + (stmt.await ? noEmptySpace() + \"await\" : \"\") + space + \"(\"\n      ],\n      that = this;\n    withIndent(function() {\n      if (stmt.left.type === Syntax.VariableDeclaration) {\n        withIndent(function() {\n          result.push(stmt.left.kind + noEmptySpace());\n          result.push(\n            that.generateStatement(stmt.left.declarations[0], S_FFFF)\n          );\n        });\n      } else {\n        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n      }\n\n      result = join(result, operator);\n      result = [\n        join(\n          result,\n          that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)\n        ),\n        \")\"\n      ];\n    });\n    result.push(this.maybeBlock(stmt.body, flags));\n    return result;\n  };\n\n  CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {\n    var result = [];\n\n    if (computed) {\n      result.push(\"[\");\n    }\n\n    result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));\n\n    if (computed) {\n      result.push(\"]\");\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateAssignment = function(\n    left,\n    right,\n    operator,\n    precedence,\n    flags\n  ) {\n    if (Precedence.Assignment < precedence) {\n      flags |= F_ALLOW_IN;\n    }\n\n    return parenthesize(\n      [\n        this.generateExpression(left, Precedence.Call, flags),\n        space + operator + space,\n        this.generateExpression(right, Precedence.Assignment, flags)\n      ],\n      Precedence.Assignment,\n      precedence\n    );\n  };\n\n  CodeGenerator.prototype.semicolon = function(flags) {\n    if (!semicolons && flags & F_SEMICOLON_OPT) {\n      return \"\";\n    }\n    // return \";\"; // dan\n    return \"\";\n  };\n\n  // Statements.\n\n  CodeGenerator.Statement = {\n    BlockStatement: function(stmt, flags) {\n      var range,\n        content,\n        result = [\"{\", newline],\n        that = this;\n\n      withIndent(function() {\n        // handle functions without any code\n        if (stmt.body.length === 0 && preserveBlankLines) {\n          range = stmt.range;\n          if (range[1] - range[0] > 2) {\n            content = sourceCode.substring(range[0] + 1, range[1] - 1);\n            if (content[0] === \"\\n\") {\n              result = [\"{\"];\n            }\n            result.push(content);\n          }\n        }\n\n        var i, iz, fragment, bodyFlags;\n        bodyFlags = S_TFFF;\n        if (flags & F_FUNC_BODY) {\n          bodyFlags |= F_DIRECTIVE_CTX;\n        }\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          if (preserveBlankLines) {\n            // handle spaces before the first line\n            if (i === 0) {\n              if (stmt.body[0].leadingComments) {\n                range = stmt.body[0].leadingComments[0].extendedRange;\n                content = sourceCode.substring(range[0], range[1]);\n                if (content[0] === \"\\n\") {\n                  result = [\"{\"];\n                }\n              }\n              if (!stmt.body[0].leadingComments) {\n                generateBlankLines(\n                  stmt.range[0],\n                  stmt.body[0].range[0],\n                  result\n                );\n              }\n            }\n\n            // handle spaces between lines\n            if (i > 0) {\n              if (\n                !stmt.body[i - 1].trailingComments &&\n                !stmt.body[i].leadingComments\n              ) {\n                generateBlankLines(\n                  stmt.body[i - 1].range[1],\n                  stmt.body[i].range[0],\n                  result\n                );\n              }\n            }\n          }\n\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          if (stmt.body[i].leadingComments && preserveBlankLines) {\n            fragment = that.generateStatement(stmt.body[i], bodyFlags);\n          } else {\n            fragment = addIndent(\n              that.generateStatement(stmt.body[i], bodyFlags)\n            );\n          }\n\n          result.push(fragment);\n          if (\n            !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())\n          ) {\n            if (preserveBlankLines && i < iz - 1) {\n              // don't add a new line if there are leading coments\n              // in the next statement\n              if (!stmt.body[i + 1].leadingComments) {\n                result.push(newline);\n              }\n            } else {\n              result.push(newline);\n            }\n          }\n\n          if (preserveBlankLines) {\n            // handle spaces after the last line\n            if (i === iz - 1) {\n              if (!stmt.body[i].trailingComments) {\n                generateBlankLines(\n                  stmt.body[i].range[1],\n                  stmt.range[1],\n                  result\n                );\n              }\n            }\n          }\n        }\n      });\n\n      result.push(addIndent(\"}\"));\n      return result;\n    },\n\n    BreakStatement: function(stmt, flags) {\n      if (stmt.label) {\n        return \"break \" + stmt.label.name + this.semicolon(flags);\n      }\n      return \"break\" + this.semicolon(flags);\n    },\n\n    ContinueStatement: function(stmt, flags) {\n      if (stmt.label) {\n        return \"continue \" + stmt.label.name + this.semicolon(flags);\n      }\n      return \"continue\" + this.semicolon(flags);\n    },\n\n    ClassBody: function(stmt, flags) {\n      var result = [\"{\", newline],\n        that = this;\n\n      withIndent(function(indent) {\n        var i, iz;\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          result.push(indent);\n          result.push(\n            that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT)\n          );\n          if (i + 1 < iz) {\n            result.push(newline);\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n      result.push(base);\n      result.push(\"}\");\n      return result;\n    },\n\n    ClassDeclaration: function(stmt, flags) {\n      var result, fragment;\n      result = [\"class\"];\n      if (stmt.id) {\n        result = join(\n          result,\n          this.generateExpression(stmt.id, Precedence.Sequence, E_TTT)\n        );\n      }\n      if (stmt.superClass) {\n        fragment = join(\n          \"extends\",\n          this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT)\n        );\n        result = join(result, fragment);\n      }\n      result.push(space);\n      result.push(this.generateStatement(stmt.body, S_TFFT));\n      return result;\n    },\n\n    DirectiveStatement: function(stmt, flags) {\n      if (extra.raw && stmt.raw) {\n        return stmt.raw + this.semicolon(flags);\n      }\n      return escapeDirective(stmt.directive) + this.semicolon(flags);\n    },\n\n    DoWhileStatement: function(stmt, flags) {\n      // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n      var result = join(\"do\", this.maybeBlock(stmt.body, S_TFFF));\n      result = this.maybeBlockSuffix(stmt.body, result);\n      return join(result, [\n        \"while\" + space + \"(\",\n        this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n        \")\" + this.semicolon(flags)\n      ]);\n    },\n\n    CatchClause: function(stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function() {\n        var guard;\n\n        if (stmt.param) {\n          result = [\n            \"catch\" + space + \"(\",\n            that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\n            \")\"\n          ];\n\n          if (stmt.guard) {\n            guard = that.generateExpression(\n              stmt.guard,\n              Precedence.Sequence,\n              E_TTT\n            );\n            result.splice(2, 0, \" if \", guard);\n          }\n        } else {\n          result = [\"catch\"];\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, S_TFFF));\n      return result;\n    },\n\n    DebuggerStatement: function(stmt, flags) {\n      return \"debugger\" + this.semicolon(flags);\n    },\n\n    EmptyStatement: function(stmt, flags) {\n      return \";\";\n    },\n\n    ExportDefaultDeclaration: function(stmt, flags) {\n      var result = [\"export\"],\n        bodyFlags;\n\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n\n      // export default HoistableDeclaration[Default]\n      // export default AssignmentExpression[In] ;\n      result = join(result, \"default\");\n      if (isStatement(stmt.declaration)) {\n        result = join(\n          result,\n          this.generateStatement(stmt.declaration, bodyFlags)\n        );\n      } else {\n        result = join(\n          result,\n          this.generateExpression(\n            stmt.declaration,\n            Precedence.Assignment,\n            E_TTT\n          ) + this.semicolon(flags)\n        );\n      }\n      return result;\n    },\n\n    ExportNamedDeclaration: function(stmt, flags) {\n      var result = [\"export\"],\n        bodyFlags,\n        that = this;\n\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n\n      // export VariableStatement\n      // export Declaration[Default]\n      if (stmt.declaration) {\n        return join(\n          result,\n          this.generateStatement(stmt.declaration, bodyFlags)\n        );\n      }\n\n      // export ExportClause[NoReference] FromClause ;\n      // export ExportClause ;\n      if (stmt.specifiers) {\n        if (stmt.specifiers.length === 0) {\n          result = join(result, \"{\" + space + \"}\");\n        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n          result = join(\n            result,\n            this.generateExpression(\n              stmt.specifiers[0],\n              Precedence.Sequence,\n              E_TTT\n            )\n          );\n        } else {\n          result = join(result, \"{\");\n          withIndent(function(indent) {\n            var i, iz;\n            result.push(newline);\n            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n              result.push(indent);\n              result.push(\n                that.generateExpression(\n                  stmt.specifiers[i],\n                  Precedence.Sequence,\n                  E_TTT\n                )\n              );\n              if (i + 1 < iz) {\n                result.push(\",\" + newline);\n              }\n            }\n          });\n          if (\n            !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())\n          ) {\n            result.push(newline);\n          }\n          result.push(base + \"}\");\n        }\n\n        if (stmt.source) {\n          result = join(result, [\n            \"from\" + space,\n            // ModuleSpecifier\n            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n            this.semicolon(flags)\n          ]);\n        } else {\n          result.push(this.semicolon(flags));\n        }\n      }\n      return result;\n    },\n\n    ExportAllDeclaration: function(stmt, flags) {\n      // export * FromClause ;\n      return [\n        \"export\" + space,\n        \"*\" + space,\n        \"from\" + space,\n        // ModuleSpecifier\n        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n        this.semicolon(flags)\n      ];\n    },\n\n    ExpressionStatement: function(stmt, flags) {\n      var result, fragment;\n\n      function isClassPrefixed(fragment) {\n        var code;\n        if (fragment.slice(0, 5) !== \"class\") {\n          return false;\n        }\n        code = fragment.charCodeAt(5);\n        return (\n          code === 0x7b /* '{' */ ||\n          esutils.code.isWhiteSpace(code) ||\n          esutils.code.isLineTerminator(code)\n        );\n      }\n\n      function isFunctionPrefixed(fragment) {\n        var code;\n        if (fragment.slice(0, 8) !== \"function\") {\n          return false;\n        }\n        code = fragment.charCodeAt(8);\n        return (\n          code === 0x28 /* '(' */ ||\n          esutils.code.isWhiteSpace(code) ||\n          code === 0x2a /* '*' */ ||\n          esutils.code.isLineTerminator(code)\n        );\n      }\n\n      function isAsyncPrefixed(fragment) {\n        var code, i, iz;\n        if (fragment.slice(0, 5) !== \"async\") {\n          return false;\n        }\n        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n          return false;\n        }\n        for (i = 6, iz = fragment.length; i < iz; ++i) {\n          if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n            break;\n          }\n        }\n        if (i === iz) {\n          return false;\n        }\n        if (fragment.slice(i, i + 8) !== \"function\") {\n          return false;\n        }\n        code = fragment.charCodeAt(i + 8);\n        return (\n          code === 0x28 /* '(' */ ||\n          esutils.code.isWhiteSpace(code) ||\n          code === 0x2a /* '*' */ ||\n          esutils.code.isLineTerminator(code)\n        );\n      }\n\n      result = [\n        this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)\n      ];\n      // 12.4 '{', 'function', 'class' is not allowed in this position.\n      // wrap expression with parentheses\n      fragment = toSourceNodeWhenNeeded(result).toString();\n      if (\n        fragment.charCodeAt(0) === 0x7b /* '{' */ || // ObjectExpression\n        isClassPrefixed(fragment) ||\n        isFunctionPrefixed(fragment) ||\n        isAsyncPrefixed(fragment) ||\n        (directive &&\n          flags & F_DIRECTIVE_CTX &&\n          stmt.expression.type === Syntax.Literal &&\n          typeof stmt.expression.value === \"string\")\n      ) {\n        result = [\"(\", result, \")\" + this.semicolon(flags)];\n      } else {\n        result.push(this.semicolon(flags));\n      }\n      return result;\n    },\n\n    ImportDeclaration: function(stmt, flags) {\n      // ES6: 15.2.1 valid import declarations:\n      //     - import ImportClause FromClause ;\n      //     - import ModuleSpecifier ;\n      var result,\n        cursor,\n        that = this;\n\n      // If no ImportClause is present,\n      // this should be `import ModuleSpecifier` so skip `from`\n      // ModuleSpecifier is StringLiteral.\n      if (stmt.specifiers.length === 0) {\n        // import ModuleSpecifier ;\n        return [\n          \"import\",\n          space,\n          // ModuleSpecifier\n          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n          this.semicolon(flags)\n        ];\n      }\n\n      // import ImportClause FromClause ;\n      result = [\"import\"];\n      cursor = 0;\n\n      // ImportedBinding\n      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n        result = join(result, [\n          this.generateExpression(\n            stmt.specifiers[cursor],\n            Precedence.Sequence,\n            E_TTT\n          )\n        ]);\n        ++cursor;\n      }\n\n      if (stmt.specifiers[cursor]) {\n        if (cursor !== 0) {\n          result.push(\",\");\n        }\n\n        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n          // NameSpaceImport\n          result = join(result, [\n            space,\n            this.generateExpression(\n              stmt.specifiers[cursor],\n              Precedence.Sequence,\n              E_TTT\n            )\n          ]);\n        } else {\n          // NamedImports\n          result.push(space + \"{\");\n\n          if (stmt.specifiers.length - cursor === 1) {\n            // import { ... } from \"...\";\n            result.push(space);\n            result.push(\n              this.generateExpression(\n                stmt.specifiers[cursor],\n                Precedence.Sequence,\n                E_TTT\n              )\n            );\n            result.push(space + \"}\" + space);\n          } else {\n            // import {\n            //    ...,\n            //    ...,\n            // } from \"...\";\n            withIndent(function(indent) {\n              var i, iz;\n              result.push(newline);\n              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                result.push(indent);\n                result.push(\n                  that.generateExpression(\n                    stmt.specifiers[i],\n                    Precedence.Sequence,\n                    E_TTT\n                  )\n                );\n                if (i + 1 < iz) {\n                  result.push(\",\" + newline);\n                }\n              }\n            });\n            if (\n              !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())\n            ) {\n              result.push(newline);\n            }\n            result.push(base + \"}\" + space);\n          }\n        }\n      }\n\n      result = join(result, [\n        \"from\" + space,\n        // ModuleSpecifier\n        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n        this.semicolon(flags)\n      ]);\n      return result;\n    },\n\n    VariableDeclarator: function(stmt, flags) {\n      var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n      if (stmt.init) {\n        return [\n          this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\n          space,\n          \"=\",\n          space,\n          this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\n        ];\n      }\n      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n    },\n\n    VariableDeclaration: function(stmt, flags) {\n      // VariableDeclarator is typed as Statement,\n      // but joined with comma (not LineTerminator).\n      // So if comment is attached to target node, we should specialize.\n      var result,\n        i,\n        iz,\n        node,\n        bodyFlags,\n        that = this;\n\n      result = [stmt.kind];\n\n      bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n\n      function block() {\n        node = stmt.declarations[0];\n        if (extra.comment && node.leadingComments) {\n          result.push(\"\\n\");\n          result.push(addIndent(that.generateStatement(node, bodyFlags)));\n        } else {\n          result.push(noEmptySpace());\n          result.push(that.generateStatement(node, bodyFlags));\n        }\n\n        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n          node = stmt.declarations[i];\n          if (extra.comment && node.leadingComments) {\n            result.push(\",\" + newline);\n            result.push(addIndent(that.generateStatement(node, bodyFlags)));\n          } else {\n            result.push(\",\" + space);\n            result.push(that.generateStatement(node, bodyFlags));\n          }\n        }\n      }\n\n      if (stmt.declarations.length > 1) {\n        withIndent(block);\n      } else {\n        block();\n      }\n\n      result.push(this.semicolon(flags));\n\n      return result;\n    },\n\n    ThrowStatement: function(stmt, flags) {\n      return [\n        join(\n          \"throw\",\n          this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n        ),\n        this.semicolon(flags)\n      ];\n    },\n\n    TryStatement: function(stmt, flags) {\n      var result, i, iz, guardedHandlers;\n\n      result = [\"try\", this.maybeBlock(stmt.block, S_TFFF)];\n      result = this.maybeBlockSuffix(stmt.block, result);\n\n      if (stmt.handlers) {\n        // old interface\n        for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n          result = join(\n            result,\n            this.generateStatement(stmt.handlers[i], S_TFFF)\n          );\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n          }\n        }\n      } else {\n        guardedHandlers = stmt.guardedHandlers || [];\n\n        for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n          result = join(\n            result,\n            this.generateStatement(guardedHandlers[i], S_TFFF)\n          );\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n          }\n        }\n\n        // new interface\n        if (stmt.handler) {\n          if (Array.isArray(stmt.handler)) {\n            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n              result = join(\n                result,\n                this.generateStatement(stmt.handler[i], S_TFFF)\n              );\n              if (stmt.finalizer || i + 1 !== iz) {\n                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n              }\n            }\n          } else {\n            result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n            if (stmt.finalizer) {\n              result = this.maybeBlockSuffix(stmt.handler.body, result);\n            }\n          }\n        }\n      }\n      if (stmt.finalizer) {\n        result = join(result, [\n          \"finally\",\n          this.maybeBlock(stmt.finalizer, S_TFFF)\n        ]);\n      }\n      return result;\n    },\n\n    SwitchStatement: function(stmt, flags) {\n      var result,\n        fragment,\n        i,\n        iz,\n        bodyFlags,\n        that = this;\n      withIndent(function() {\n        result = [\n          \"switch\" + space + \"(\",\n          that.generateExpression(\n            stmt.discriminant,\n            Precedence.Sequence,\n            E_TTT\n          ),\n          \")\" + space + \"{\" + newline\n        ];\n      });\n      if (stmt.cases) {\n        bodyFlags = S_TFFF;\n        for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n          fragment = addIndent(\n            this.generateStatement(stmt.cases[i], bodyFlags)\n          );\n          result.push(fragment);\n          if (\n            !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())\n          ) {\n            result.push(newline);\n          }\n        }\n      }\n      result.push(addIndent(\"}\"));\n      return result;\n    },\n\n    SwitchCase: function(stmt, flags) {\n      var result,\n        fragment,\n        i,\n        iz,\n        bodyFlags,\n        that = this;\n      withIndent(function() {\n        if (stmt.test) {\n          result = [\n            addIndent(\n              join(\n                \"case \",\n                that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)\n              )\n            ),\n            \" :\"\n          ];\n        } else {\n          result = [addIndent(\"default :\")];\n        }\n\n        i = 0;\n        iz = stmt.consequent.length;\n        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n          result.push(fragment);\n          i = 1;\n        }\n\n        if (\n          i !== iz &&\n          !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())\n        ) {\n          result.push(newline);\n        }\n\n        bodyFlags = S_TFFF;\n        for (; i < iz; ++i) {\n          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n          fragment = addIndent(\n            addIndent(\n              join(that.generateStatement(stmt.consequent[i], bodyFlags), \";\")\n            )\n          );\n          result.push(fragment);\n          if (\n            i + 1 !== iz &&\n            !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())\n          ) {\n            result.push(newline);\n          }\n        }\n      });\n      return result;\n    },\n\n    IfStatement: function(stmt, flags) {\n      var result,\n        bodyFlags,\n        semicolonOptional,\n        that = this;\n      withIndent(function() {\n        result = [\n          \"if\" + space + \"(\",\n          that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n          \")\"\n        ];\n      });\n      semicolonOptional = flags & F_SEMICOLON_OPT;\n      bodyFlags = S_TFFF;\n      if (semicolonOptional) {\n        bodyFlags |= F_SEMICOLON_OPT;\n      }\n      if (stmt.alternate) {\n        result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n        result = this.maybeBlockSuffix(stmt.consequent, result);\n        if (stmt.alternate.type === Syntax.IfStatement) {\n          result = join(result, [\n            \"else \",\n            this.generateStatement(stmt.alternate, bodyFlags)\n          ]);\n        } else {\n          result = join(\n            result,\n            join(\"else\", this.maybeBlock(stmt.alternate, bodyFlags))\n          );\n        }\n      } else {\n        result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n      }\n      return result;\n    },\n\n    ForStatement: function(stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function() {\n        result = [\"for\" + space + \"(\"];\n        if (stmt.init) {\n          // console.log(stmt.init.type);\n          if (stmt.init.type === Syntax.VariableDeclaration) {\n            result.push(that.generateStatement(stmt.init, S_FFFF));\n            result.push(\";\");\n          } else {\n            // F_ALLOW_IN becomes false.\n            result.push(\n              that.generateExpression(stmt.init, Precedence.Sequence, E_FTT)\n            );\n            result.push(\";\");\n          }\n        } else {\n          result.push(\";\");\n        }\n\n        if (stmt.test) {\n          result.push(space);\n          result.push(\n            that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)\n          );\n          result.push(\";\");\n        } else {\n          result.push(\";\");\n        }\n\n        if (stmt.update) {\n          result.push(space);\n          result.push(\n            that.generateExpression(stmt.update, Precedence.Sequence, E_TTT)\n          );\n          result.push(\")\");\n        } else {\n          result.push(\")\");\n        }\n      });\n\n      result.push(\n        this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)\n      );\n      return result;\n    },\n\n    ForInStatement: function(stmt, flags) {\n      return this.generateIterationForStatement(\n        \"in\",\n        stmt,\n        flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF\n      );\n    },\n\n    ForOfStatement: function(stmt, flags) {\n      return this.generateIterationForStatement(\n        \"of\",\n        stmt,\n        flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF\n      );\n    },\n\n    LabeledStatement: function(stmt, flags) {\n      return [\n        stmt.label.name + \":\",\n        this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)\n      ];\n    },\n\n    Program: function(stmt, flags) {\n      var result, fragment, i, iz, bodyFlags;\n      iz = stmt.body.length;\n      result = [safeConcatenation && iz > 0 ? \"\\n\" : \"\"];\n      bodyFlags = S_TFTF;\n      for (i = 0; i < iz; ++i) {\n        if (!safeConcatenation && i === iz - 1) {\n          bodyFlags |= F_SEMICOLON_OPT;\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces before the first line\n          if (i === 0) {\n            if (!stmt.body[0].leadingComments) {\n              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n            }\n          }\n\n          // handle spaces between lines\n          if (i > 0) {\n            if (\n              !stmt.body[i - 1].trailingComments &&\n              !stmt.body[i].leadingComments\n            ) {\n              generateBlankLines(\n                stmt.body[i - 1].range[1],\n                stmt.body[i].range[0],\n                result\n              );\n            }\n          }\n        }\n\n        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n        result.push(fragment);\n        if (\n          i + 1 < iz &&\n          !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())\n        ) {\n          if (preserveBlankLines) {\n            if (!stmt.body[i + 1].leadingComments) {\n              result.push(newline);\n            }\n          } else {\n            result.push(newline);\n          }\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces after the last line\n          if (i === iz - 1) {\n            if (!stmt.body[i].trailingComments) {\n              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n            }\n          }\n        }\n      }\n      return result;\n    },\n\n    //dan\n    FunctionDeclaration: function(stmt, flags) {\n      return [\n        generateAsyncPrefix(stmt, true),\n        \"function\",\n        generateStarSuffix(stmt) || noEmptySpace(),\n        stmt.id ? generateIdentifier(stmt.id) : \"\",\n        this.generateFunctionBody(stmt)\n      ];\n    },\n\n    ReturnStatement: function(stmt, flags) {\n      if (stmt.argument) {\n        return [\n          join(\n            \"return\",\n            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n          ),\n          this.semicolon(flags)\n        ];\n      }\n      return [\"return\" + this.semicolon(flags)];\n    },\n\n    WhileStatement: function(stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function() {\n        result = [\n          \"while\" + space + \"(\",\n          that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n          \")\"\n        ];\n      });\n      result.push(\n        this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)\n      );\n      return result;\n    },\n\n    WithStatement: function(stmt, flags) {\n      var result,\n        that = this;\n      withIndent(function() {\n        result = [\n          \"with\" + space + \"(\",\n          that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\n          \")\"\n        ];\n      });\n      result.push(\n        this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)\n      );\n      return result;\n    }\n  };\n\n  merge(CodeGenerator.prototype, CodeGenerator.Statement);\n\n  // Expressions.\n\n  CodeGenerator.Expression = {\n    SequenceExpression: function(expr, precedence, flags) {\n      var result, i, iz;\n      if (Precedence.Sequence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n      result = [];\n      for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n        result.push(\n          this.generateExpression(\n            expr.expressions[i],\n            Precedence.Assignment,\n            flags\n          )\n        );\n        if (i + 1 < iz) {\n          result.push(\",\" + space);\n        }\n      }\n      return parenthesize(result, Precedence.Sequence, precedence);\n    },\n\n    AssignmentExpression: function(expr, precedence, flags) {\n      return this.generateAssignment(\n        expr.left,\n        expr.right,\n        expr.operator,\n        precedence,\n        flags\n      );\n    },\n\n    ArrowFunctionExpression: function(expr, precedence, flags) {\n      return parenthesize(\n        this.generateFunctionBody(expr),\n        Precedence.ArrowFunction,\n        precedence\n      );\n    },\n\n    ConditionalExpression: function(expr, precedence, flags) {\n      if (Precedence.Conditional < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n      return parenthesize(\n        [\n          this.generateExpression(expr.test, Precedence.LogicalOR, flags),\n          space + \"?\" + space,\n          this.generateExpression(\n            expr.consequent,\n            Precedence.Assignment,\n            flags\n          ),\n          space + \":\" + space,\n          this.generateExpression(expr.alternate, Precedence.Assignment, flags)\n        ],\n        Precedence.Conditional,\n        precedence\n      );\n    },\n\n    LogicalExpression: function(expr, precedence, flags) {\n      return this.BinaryExpression(expr, precedence, flags);\n    },\n\n    BinaryExpression: function(expr, precedence, flags) {\n      var result,\n        leftPrecedence,\n        rightPrecedence,\n        currentPrecedence,\n        fragment,\n        leftSource;\n      currentPrecedence = BinaryPrecedence[expr.operator];\n      leftPrecedence =\n        expr.operator === \"**\" ? Precedence.Postfix : currentPrecedence;\n      rightPrecedence =\n        expr.operator === \"**\" ? currentPrecedence : currentPrecedence + 1;\n\n      if (currentPrecedence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n\n      leftSource = fragment.toString();\n\n      if (\n        leftSource.charCodeAt(leftSource.length - 1) === 0x2f /* / */ &&\n        esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))\n      ) {\n        result = [fragment, noEmptySpace(), expr.operator];\n      } else {\n        result = join(fragment, expr.operator);\n      }\n\n      fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n\n      if (\n        (expr.operator === \"/\" && fragment.toString().charAt(0) === \"/\") ||\n        (expr.operator.slice(-1) === \"<\" &&\n          fragment.toString().slice(0, 3) === \"!--\")\n      ) {\n        // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n        result.push(noEmptySpace());\n        result.push(fragment);\n      } else {\n        result = join(result, fragment);\n      }\n\n      if (expr.operator === \"in\" && !(flags & F_ALLOW_IN)) {\n        return [\"(\", result, \")\"];\n      }\n      return parenthesize(result, currentPrecedence, precedence);\n    },\n\n    CallExpression: function(expr, precedence, flags) {\n      var result, i, iz;\n      // F_ALLOW_UNPARATH_NEW becomes false.\n      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n      result.push(\"(\");\n      for (i = 0, iz = expr[\"arguments\"].length; i < iz; ++i) {\n        result.push(\n          this.generateExpression(\n            expr[\"arguments\"][i],\n            Precedence.Assignment,\n            E_TTT\n          )\n        );\n        if (i + 1 < iz) {\n          result.push(\",\" + space);\n        }\n      }\n      result.push(\")\");\n\n      if (!(flags & F_ALLOW_CALL)) {\n        return [\"(\", result, \")\"];\n      }\n      return parenthesize(result, Precedence.Call, precedence);\n    },\n\n    NewExpression: function(expr, precedence, flags) {\n      var result, length, i, iz, itemFlags;\n      length = expr[\"arguments\"].length;\n\n      // F_ALLOW_CALL becomes false.\n      // F_ALLOW_UNPARATH_NEW may become false.\n      itemFlags =\n        flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0\n          ? E_TFT\n          : E_TFF;\n\n      result = join(\n        \"new\",\n        this.generateExpression(expr.callee, Precedence.New, itemFlags)\n      );\n\n      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n        result.push(\"(\");\n        for (i = 0, iz = length; i < iz; ++i) {\n          result.push(\n            this.generateExpression(\n              expr[\"arguments\"][i],\n              Precedence.Assignment,\n              E_TTT\n            )\n          );\n          if (i + 1 < iz) {\n            result.push(\",\" + space);\n          }\n        }\n        result.push(\")\");\n      }\n\n      return parenthesize(result, Precedence.New, precedence);\n    },\n\n    MemberExpression: function(expr, precedence, flags) {\n      var result, fragment;\n\n      // F_ALLOW_UNPARATH_NEW becomes false.\n      result = [\n        this.generateExpression(\n          expr.object,\n          Precedence.Call,\n          flags & F_ALLOW_CALL ? E_TTF : E_TFF\n        )\n      ];\n\n      if (expr.computed) {\n        result.push(\"[\");\n        result.push(\n          this.generateExpression(\n            expr.property,\n            Precedence.Sequence,\n            flags & F_ALLOW_CALL ? E_TTT : E_TFT\n          )\n        );\n        result.push(\"]\");\n      } else {\n        if (\n          expr.object.type === Syntax.Literal &&\n          typeof expr.object.value === \"number\"\n        ) {\n          fragment = toSourceNodeWhenNeeded(result).toString();\n          // When the following conditions are all true,\n          //   1. No floating point\n          //   2. Don't have exponents\n          //   3. The last character is a decimal digit\n          //   4. Not hexadecimal OR octal number literal\n          // we should add a floating point.\n          if (\n            fragment.indexOf(\".\") < 0 &&\n            !/[eExX]/.test(fragment) &&\n            esutils.code.isDecimalDigit(\n              fragment.charCodeAt(fragment.length - 1)\n            ) &&\n            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48) // '0'\n          ) {\n            result.push(\" \");\n          }\n        }\n        result.push(\".\");\n        result.push(generateIdentifier(expr.property));\n      }\n\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n\n    MetaProperty: function(expr, precedence, flags) {\n      var result;\n      result = [];\n      result.push(\n        typeof expr.meta === \"string\"\n          ? expr.meta\n          : generateIdentifier(expr.meta)\n      );\n      result.push(\".\");\n      result.push(\n        typeof expr.property === \"string\"\n          ? expr.property\n          : generateIdentifier(expr.property)\n      );\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n\n    UnaryExpression: function(expr, precedence, flags) {\n      var result, fragment, rightCharCode, leftSource, leftCharCode;\n      fragment = this.generateExpression(\n        expr.argument,\n        Precedence.Unary,\n        E_TTT\n      );\n\n      if (space === \"\") {\n        result = join(expr.operator, fragment);\n      } else {\n        result = [expr.operator];\n        if (expr.operator.length > 2) {\n          // delete, void, typeof\n          // get `typeof []`, not `typeof[]`\n          result = join(result, fragment);\n        } else {\n          // Prevent inserting spaces between operator and argument if it is unnecessary\n          // like, `!cond`\n          leftSource = toSourceNodeWhenNeeded(result).toString();\n          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n          rightCharCode = fragment.toString().charCodeAt(0);\n\n          if (\n            ((leftCharCode === 0x2b /* + */ || leftCharCode === 0x2d) /* - */ &&\n              leftCharCode === rightCharCode) ||\n            (esutils.code.isIdentifierPartES5(leftCharCode) &&\n              esutils.code.isIdentifierPartES5(rightCharCode))\n          ) {\n            result.push(noEmptySpace());\n            result.push(fragment);\n          } else {\n            result.push(fragment);\n          }\n        }\n      }\n      return parenthesize(result, Precedence.Unary, precedence);\n    },\n\n    YieldExpression: function(expr, precedence, flags) {\n      var result;\n      if (expr.delegate) {\n        result = \"yield*\";\n      } else {\n        result = \"yield\";\n      }\n      if (expr.argument) {\n        result = join(\n          result,\n          this.generateExpression(expr.argument, Precedence.Yield, E_TTT)\n        );\n      }\n      return parenthesize(result, Precedence.Yield, precedence);\n    },\n\n    AwaitExpression: function(expr, precedence, flags) {\n      var result = join(\n        expr.all ? \"await*\" : \"await\",\n        this.generateExpression(expr.argument, Precedence.Await, E_TTT)\n      );\n      return parenthesize(result, Precedence.Await, precedence);\n    },\n\n    UpdateExpression: function(expr, precedence, flags) {\n      if (expr.prefix) {\n        return parenthesize(\n          [\n            expr.operator,\n            this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\n          ],\n          Precedence.Unary,\n          precedence\n        );\n      }\n      return parenthesize(\n        [\n          this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\n          expr.operator\n        ],\n        Precedence.Postfix,\n        precedence\n      );\n    },\n\n    FunctionExpression: function(expr, precedence, flags) {\n      var result = [generateAsyncPrefix(expr, true), \"function\"];\n      if (expr.id) {\n        result.push(generateStarSuffix(expr) || noEmptySpace());\n        result.push(generateIdentifier(expr.id));\n      } else {\n        result.push(generateStarSuffix(expr) || space);\n      }\n      result.push(this.generateFunctionBody(expr));\n      return result;\n    },\n\n    ArrayPattern: function(expr, precedence, flags) {\n      return this.ArrayExpression(expr, precedence, flags, true);\n    },\n\n    ArrayExpression: function(expr, precedence, flags, isPattern) {\n      var result,\n        multiline,\n        that = this;\n      if (!expr.elements.length) {\n        return \"[]\";\n      }\n      multiline = isPattern ? false : expr.elements.length > 1;\n      result = [\"[\", multiline ? newline : \"\"];\n      withIndent(function(indent) {\n        var i, iz;\n        for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n          if (!expr.elements[i]) {\n            if (multiline) {\n              result.push(indent);\n            }\n            if (i + 1 === iz) {\n              result.push(\",\");\n            }\n          } else {\n            result.push(multiline ? indent : \"\");\n            result.push(\n              that.generateExpression(\n                expr.elements[i],\n                Precedence.Assignment,\n                E_TTT\n              )\n            );\n          }\n          if (i + 1 < iz) {\n            result.push(\",\" + (multiline ? newline : space));\n          }\n        }\n      });\n      if (\n        multiline &&\n        !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())\n      ) {\n        result.push(newline);\n      }\n      result.push(multiline ? base : \"\");\n      result.push(\"]\");\n      return result;\n    },\n\n    RestElement: function(expr, precedence, flags) {\n      return \"...\" + this.generatePattern(expr.argument);\n    },\n\n    ClassExpression: function(expr, precedence, flags) {\n      var result, fragment;\n      result = [\"class\"];\n      if (expr.id) {\n        result = join(\n          result,\n          this.generateExpression(expr.id, Precedence.Sequence, E_TTT)\n        );\n      }\n      if (expr.superClass) {\n        fragment = join(\n          \"extends\",\n          this.generateExpression(expr.superClass, Precedence.Unary, E_TTT)\n        );\n        result = join(result, fragment);\n      }\n      result.push(space);\n      result.push(this.generateStatement(expr.body, S_TFFT));\n      return result;\n    },\n\n    MethodDefinition: function(expr, precedence, flags) {\n      var result, fragment;\n      if (expr[\"static\"]) {\n        result = [\"static\" + space];\n      } else {\n        result = [];\n      }\n      if (expr.kind === \"get\" || expr.kind === \"set\") {\n        fragment = [\n          join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\n          this.generateFunctionBody(expr.value)\n        ];\n      } else {\n        fragment = [\n          generateMethodPrefix(expr),\n          this.generatePropertyKey(expr.key, expr.computed),\n          this.generateFunctionBody(expr.value)\n        ];\n      }\n      return join(result, fragment);\n    },\n\n    Property: function(expr, precedence, flags) {\n      if (expr.kind === \"get\" || expr.kind === \"set\") {\n        return [\n          expr.kind,\n          noEmptySpace(),\n          this.generatePropertyKey(expr.key, expr.computed),\n          this.generateFunctionBody(expr.value)\n        ];\n      }\n\n      if (expr.shorthand) {\n        if (expr.value.type === \"AssignmentPattern\") {\n          return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n        }\n        return this.generatePropertyKey(expr.key, expr.computed);\n      }\n\n      if (expr.method) {\n        return [\n          generateMethodPrefix(expr),\n          this.generatePropertyKey(expr.key, expr.computed),\n          this.generateFunctionBody(expr.value)\n        ];\n      }\n\n      return [\n        this.generatePropertyKey(expr.key, expr.computed),\n        \":\" + space,\n        this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\n      ];\n    },\n\n    ObjectExpression: function(expr, precedence, flags) {\n      var multiline,\n        result,\n        fragment,\n        that = this;\n\n      if (!expr.properties.length) {\n        return \"{}\";\n      }\n      multiline = expr.properties.length > 1;\n\n      withIndent(function() {\n        fragment = that.generateExpression(\n          expr.properties[0],\n          Precedence.Sequence,\n          E_TTT\n        );\n      });\n\n      if (!multiline) {\n        // issues 4\n        // Do not transform from\n        //   dejavu.Class.declare({\n        //       method2: function () {}\n        //   });\n        // to\n        //   dejavu.Class.declare({method2: function () {\n        //       }});\n        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          return [\"{\", space, fragment, space, \"}\"];\n        }\n      }\n\n      withIndent(function(indent) {\n        var i, iz;\n        result = [\"{\", newline, indent, fragment];\n\n        if (multiline) {\n          result.push(\",\" + newline);\n          for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n            result.push(indent);\n            result.push(\n              that.generateExpression(\n                expr.properties[i],\n                Precedence.Sequence,\n                E_TTT\n              )\n            );\n            if (i + 1 < iz) {\n              result.push(\",\" + newline);\n            }\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n      result.push(base);\n      result.push(\"}\");\n      return result;\n    },\n\n    AssignmentPattern: function(expr, precedence, flags) {\n      return this.generateAssignment(\n        expr.left,\n        expr.right,\n        \"=\",\n        precedence,\n        flags\n      );\n    },\n\n    ObjectPattern: function(expr, precedence, flags) {\n      var result,\n        i,\n        iz,\n        multiline,\n        property,\n        that = this;\n      if (!expr.properties.length) {\n        return \"{}\";\n      }\n\n      multiline = false;\n      if (expr.properties.length === 1) {\n        property = expr.properties[0];\n        if (property.value.type !== Syntax.Identifier) {\n          multiline = true;\n        }\n      } else {\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          property = expr.properties[i];\n          if (!property.shorthand) {\n            multiline = true;\n            break;\n          }\n        }\n      }\n      result = [\"{\", multiline ? newline : \"\"];\n\n      withIndent(function(indent) {\n        var i, iz;\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          result.push(multiline ? indent : \"\");\n          result.push(\n            that.generateExpression(\n              expr.properties[i],\n              Precedence.Sequence,\n              E_TTT\n            )\n          );\n          if (i + 1 < iz) {\n            result.push(\",\" + (multiline ? newline : space));\n          }\n        }\n      });\n\n      if (\n        multiline &&\n        !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())\n      ) {\n        result.push(newline);\n      }\n      result.push(multiline ? base : \"\");\n      result.push(\"}\");\n      return result;\n    },\n\n    ThisExpression: function(expr, precedence, flags) {\n      return \"this\";\n    },\n\n    Super: function(expr, precedence, flags) {\n      return \"super\";\n    },\n\n    Identifier: function(expr, precedence, flags) {\n      return generateIdentifier(expr);\n    },\n\n    ImportDefaultSpecifier: function(expr, precedence, flags) {\n      return generateIdentifier(expr.id || expr.local);\n    },\n\n    ImportNamespaceSpecifier: function(expr, precedence, flags) {\n      var result = [\"*\"];\n      var id = expr.id || expr.local;\n      if (id) {\n        result.push(space + \"as\" + noEmptySpace() + generateIdentifier(id));\n      }\n      return result;\n    },\n\n    ImportSpecifier: function(expr, precedence, flags) {\n      var imported = expr.imported;\n      var result = [imported.name];\n      var local = expr.local;\n      if (local && local.name !== imported.name) {\n        result.push(\n          noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(local)\n        );\n      }\n      return result;\n    },\n\n    ExportSpecifier: function(expr, precedence, flags) {\n      var local = expr.local;\n      var result = [local.name];\n      var exported = expr.exported;\n      if (exported && exported.name !== local.name) {\n        result.push(\n          noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(exported)\n        );\n      }\n      return result;\n    },\n\n    Literal: function(expr, precedence, flags) {\n      var raw;\n      if (expr.hasOwnProperty(\"raw\") && parse && extra.raw) {\n        try {\n          raw = parse(expr.raw).body[0].expression;\n          if (raw.type === Syntax.Literal) {\n            if (raw.value === expr.value) {\n              return expr.raw;\n            }\n          }\n        } catch (e) {\n          // not use raw property\n        }\n      }\n\n      if (expr.regex) {\n        return \"/\" + expr.regex.pattern + \"/\" + expr.regex.flags;\n      }\n\n      if (expr.value === null) {\n        return \"null\";\n      }\n\n      if (typeof expr.value === \"string\") {\n        return escapeString(expr.value);\n      }\n\n      if (typeof expr.value === \"number\") {\n        return generateNumber(expr.value);\n      }\n\n      if (typeof expr.value === \"boolean\") {\n        return expr.value ? \"true\" : \"false\";\n      }\n\n      return generateRegExp(expr.value);\n    },\n\n    GeneratorExpression: function(expr, precedence, flags) {\n      return this.ComprehensionExpression(expr, precedence, flags);\n    },\n\n    ComprehensionExpression: function(expr, precedence, flags) {\n      // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n      // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n\n      var result,\n        i,\n        iz,\n        fragment,\n        that = this;\n      result = expr.type === Syntax.GeneratorExpression ? [\"(\"] : [\"[\"];\n\n      if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(\n          expr.body,\n          Precedence.Assignment,\n          E_TTT\n        );\n        result.push(fragment);\n      }\n\n      if (expr.blocks) {\n        withIndent(function() {\n          for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n            fragment = that.generateExpression(\n              expr.blocks[i],\n              Precedence.Sequence,\n              E_TTT\n            );\n            if (\n              i > 0 ||\n              extra.moz.comprehensionExpressionStartsWithAssignment\n            ) {\n              result = join(result, fragment);\n            } else {\n              result.push(fragment);\n            }\n          }\n        });\n      }\n\n      if (expr.filter) {\n        result = join(result, \"if\" + space);\n        fragment = this.generateExpression(\n          expr.filter,\n          Precedence.Sequence,\n          E_TTT\n        );\n        result = join(result, [\"(\", fragment, \")\"]);\n      }\n\n      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(\n          expr.body,\n          Precedence.Assignment,\n          E_TTT\n        );\n\n        result = join(result, fragment);\n      }\n\n      result.push(expr.type === Syntax.GeneratorExpression ? \")\" : \"]\");\n      return result;\n    },\n\n    ComprehensionBlock: function(expr, precedence, flags) {\n      var fragment;\n      if (expr.left.type === Syntax.VariableDeclaration) {\n        fragment = [\n          expr.left.kind,\n          noEmptySpace(),\n          this.generateStatement(expr.left.declarations[0], S_FFFF)\n        ];\n      } else {\n        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n      }\n\n      fragment = join(fragment, expr.of ? \"of\" : \"in\");\n      fragment = join(\n        fragment,\n        this.generateExpression(expr.right, Precedence.Sequence, E_TTT)\n      );\n\n      return [\"for\" + space + \"(\", fragment, \")\"];\n    },\n\n    SpreadElement: function(expr, precedence, flags) {\n      return [\n        \"...\",\n        this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\n      ];\n    },\n\n    TaggedTemplateExpression: function(expr, precedence, flags) {\n      var itemFlags = E_TTF;\n      if (!(flags & F_ALLOW_CALL)) {\n        itemFlags = E_TFF;\n      }\n      var result = [\n        this.generateExpression(expr.tag, Precedence.Call, itemFlags),\n        this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\n      ];\n      return parenthesize(result, Precedence.TaggedTemplate, precedence);\n    },\n\n    TemplateElement: function(expr, precedence, flags) {\n      // Don't use \"cooked\". Since tagged template can use raw template\n      // representation. So if we do so, it breaks the script semantics.\n      return expr.value.raw;\n    },\n\n    TemplateLiteral: function(expr, precedence, flags) {\n      var result, i, iz;\n      result = [\"`\"];\n      for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n        result.push(\n          this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT)\n        );\n        if (i + 1 < iz) {\n          result.push(\"${\" + space);\n          result.push(\n            this.generateExpression(\n              expr.expressions[i],\n              Precedence.Sequence,\n              E_TTT\n            )\n          );\n          result.push(space + \"}\");\n        }\n      }\n      result.push(\"`\");\n      return result;\n    },\n\n    ModuleSpecifier: function(expr, precedence, flags) {\n      return this.Literal(expr, precedence, flags);\n    },\n\n    ImportExpression: function(expr, precedence, flag) {\n      return parenthesize(\n        [\n          \"import(\",\n          this.generateExpression(expr.source, Precedence.Assignment, E_TTT),\n          \")\"\n        ],\n        Precedence.Call,\n        precedence\n      );\n    }\n  };\n\n  merge(CodeGenerator.prototype, CodeGenerator.Expression);\n\n  CodeGenerator.prototype.generateExpression = function(\n    expr,\n    precedence,\n    flags\n  ) {\n    var result, type;\n\n    type = expr.type || Syntax.Property;\n\n    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n      return generateVerbatim(expr, precedence);\n    }\n\n    result = this[type](expr, precedence, flags);\n\n    if (extra.comment) {\n      result = addComments(expr, result);\n    }\n    return toSourceNodeWhenNeeded(result, expr);\n  };\n\n  CodeGenerator.prototype.generateStatement = function(stmt, flags) {\n    var result, fragment;\n\n    result = this[stmt.type](stmt, flags);\n\n    // Attach comments\n\n    if (extra.comment) {\n      result = addComments(stmt, result);\n    }\n\n    fragment = toSourceNodeWhenNeeded(result).toString();\n    if (\n      stmt.type === Syntax.Program &&\n      !safeConcatenation &&\n      newline === \"\" &&\n      fragment.charAt(fragment.length - 1) === \"\\n\"\n    ) {\n      result = sourceMap\n        ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, \"\")\n        : fragment.replace(/\\s+$/, \"\");\n    }\n\n    return toSourceNodeWhenNeeded(result, stmt);\n  };\n\n  function generateInternal(node) {\n    var codegen;\n\n    codegen = new CodeGenerator();\n    if (isStatement(node)) {\n      return codegen.generateStatement(node, S_TFFF);\n    }\n\n    if (isExpression(node)) {\n      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n    }\n\n    throw new Error(\"Unknown node type: \" + node.type);\n  }\n\n  function generate(node, options) {\n    var defaultOptions = getDefaultOptions(),\n      result,\n      pair;\n    if (options != null) {\n      // Obsolete options\n      //\n      //   `options.indent`\n      //   `options.base`\n      //\n      // Instead of them, we can use `option.format.indent`.\n      if (typeof options.indent === \"string\") {\n        defaultOptions.format.indent.style = options.indent;\n      }\n      if (typeof options.base === \"number\") {\n        defaultOptions.format.indent.base = options.base;\n      }\n      options = updateDeeply(defaultOptions, options);\n      indent = options.format.indent.style;\n      if (typeof options.base === \"string\") {\n        base = options.base;\n      } else {\n        base = stringRepeat(indent, options.format.indent.base);\n      }\n    } else {\n      options = defaultOptions;\n      indent = options.format.indent.style;\n      base = stringRepeat(indent, options.format.indent.base);\n    }\n    json = options.format.json;\n    renumber = options.format.renumber;\n    hexadecimal = json ? false : options.format.hexadecimal;\n    quotes = json ? \"double\" : options.format.quotes;\n    escapeless = options.format.escapeless;\n    newline = options.format.newline;\n    space = options.format.space;\n    if (options.format.compact) {\n      newline = space = indent = base = \"\";\n    }\n    parentheses = options.format.parentheses;\n    semicolons = options.format.semicolons;\n    safeConcatenation = options.format.safeConcatenation;\n    directive = options.directive;\n    parse = json ? null : options.parse;\n    sourceMap = options.sourceMap;\n    sourceCode = options.sourceCode;\n    preserveBlankLines =\n      options.format.preserveBlankLines && sourceCode !== null;\n    extra = options;\n\n    if (sourceMap) {\n      if (!exports.browser) {\n        // We assume environment is node.js\n        // And prevent from including source-map by browserify\n        SourceNode = require(\"source-map\").SourceNode;\n      } else {\n        SourceNode = global.sourceMap.SourceNode;\n      }\n    }\n\n    result = generateInternal(node);\n\n    if (!sourceMap) {\n      pair = { code: result.toString(), map: null };\n      return options.sourceMapWithCode ? pair : pair.code;\n    }\n\n    pair = result.toStringWithSourceMap({\n      file: options.file,\n      sourceRoot: options.sourceMapRoot\n    });\n\n    if (options.sourceContent) {\n      pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n    }\n\n    if (options.sourceMapWithCode) {\n      return pair;\n    }\n\n    return pair.map.toString();\n  }\n\n  FORMAT_MINIFY = {\n    indent: {\n      style: \"\",\n      base: 0\n    },\n    renumber: true,\n    hexadecimal: true,\n    quotes: \"auto\",\n    escapeless: true,\n    compact: true,\n    parentheses: false,\n    semicolons: false\n  };\n\n  FORMAT_DEFAULTS = getDefaultOptions().format;\n\n  exports.generate = generate;\n  exports.attachComments = estraverse.attachComments;\n  exports.Precedence = updateDeeply({}, Precedence);\n  exports.browser = false;\n  exports.FORMAT_MINIFY = FORMAT_MINIFY;\n  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"module"}