{"ast":null,"code":"/**\r\n * @author Andrew Redican <andrew.redican.mejia@gmail.com>\r\n */\n\n/**\r\n * Performs deep search on object tree, removes all properties with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\nfunction _deepRemoveAll_Key(identity, keyName, maxDepth) {\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var clonedIdentity = _deepClone2(identity);\n\n  var paths = _locateAll_Key2(clonedIdentity, keyName, maxDepth);\n\n  if (paths === [] || paths === false) return clonedIdentity;\n  paths.forEach(function (path) {\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var ref = clonedIdentity;\n    if (!Array.isArray(path)) delete ref[path];\n\n    for (var i = 0; i < path.length; i++) {\n      var key = path[i];\n\n      if (key in ref) {\n        if (i < path.length - 1) ref = ref[key];else delete ref[key];\n      } else break;\n    }\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, removes the first property with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _deepRemove_Key(identity, keyName, maxDepth) {\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var clonedIdentity = _deepClone2(identity);\n\n  var path = _locate_Key2(clonedIdentity, keyName, maxDepth);\n\n  if (path === false) return clonedIdentity;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var ref = clonedIdentity;\n  if (!Array.isArray(path)) delete ref[path];\n  path.forEach(function (key, i) {\n    if (i < path.length - 1) ref = ref[key];else delete ref[key];\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, and renames the all matching keys\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _renameKeys2(identity, keyName, newKeyName) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (_getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n\n  function _renameKeys(identity, keyName, newKeyName, maxDepth) {\n    var currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var keys;\n\n    switch (_getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var _key = keys[i],\n              _subIdentity = identity[_key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (_key === keyName) _key = newKeyName;\n          Obj[_key] = _renameKeys(_subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKeys(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Performs deep search on object tree, then renames the first matching key\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _renameKey2(identity, keyName, newKeyName) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (_getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n  var applied = false;\n\n  function _renameKey(identity, keyName, newKeyName, maxDepth) {\n    var currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var keys;\n\n    switch (_getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var _key2 = keys[i],\n              _subIdentity2 = identity[_key2];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (!applied) if (_key2 === keyName) {\n            _key2 = newKeyName;\n            applied = true;\n          }\n          Obj[_key2] = _renameKey(_subIdentity2, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKey(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Creates a non-reference clone that is an exact copy to the identity provided.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @param {Optional Number} startDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _deepClone2(identity) {\n  var maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var startDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var R = [];\n\n  function _deepClone(identity, maxDepth, startDepth) {\n    var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var keys;\n\n    if (startDepth !== null ? currentDepth < startDepth : false) {\n      if (_isIterable(identity)) {\n        keys = Object.keys(identity);\n        keys.forEach(function (key) {\n          _deepClone(identity[key], maxDepth, startDepth, currentDepth + 1);\n        });\n      }\n\n      return;\n    }\n\n    if (startDepth !== null ? currentDepth == startDepth : false) {\n      if (startDepth == 0) {\n        R = _deepClone(identity, maxDepth, null, currentDepth);\n        return;\n      }\n\n      if (_isIterable(identity)) R.push(_deepClone(identity, maxDepth, startDepth, currentDepth + 1));\n      return;\n    }\n\n    switch (_getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          var key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          var _key3 = keys[i],\n              _subIdentity3 = identity[_key3];\n          Obj[_key3] = _deepClone(_subIdentity3, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  if (startDepth === null) return _deepClone(identity, maxDepth, startDepth, 0);\n\n  _deepClone(identity, maxDepth, startDepth, 0);\n\n  return R;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, and returns a list of identities containing the matched instances. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} Identities\r\n */\n\n\nfunction _deepFilter_Key(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var paths = _locateAll_Key2(collection, keyName, maxDepth);\n\n  if (paths === false) return undefined;\n  var results = paths.map(function (path) {\n    if (path === false) return undefined;\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(function (key) {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, returns the location of each match in a string array. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction _locateAll_Key2(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var R = [];\n\n  function _locateAll_Key(collection, keyName) {\n    var xKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    var maxDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var currentDepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    if (xKey === keyName) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key];\n\n      _locateAll_Key(subcollection, keyName, key, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll_Key(collection, keyName, '', '', maxDepth);\n\n  R = R.map(function (path) {\n    if (_getType(path) === 'boolean') return path;\n    if (path === '') return path;\n    path = path.split('.');\n    path.pop();\n    path = path.join('.');\n    return path;\n  });\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, and returns the first identity containing the match. If no match found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {Identity || undefined} identity\r\n */\n\n\nfunction _deepGet_Key(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var path = _locate_Key2(collection, keyName, maxDepth);\n\n  if (path === false) return undefined;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(function (key) {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, will return the path of the first instance matched. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {String || false} Path\r\n */\n\n\nfunction _locate_Key2(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  function _locate_Key(collection, keyName) {\n    var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var maxDepth = arguments.length > 3 ? arguments[3] : undefined;\n    var currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (path === keyName) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _locate_Key(subcollection, keyName, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  var path = _locate_Key(collection, keyName, '', maxDepth, 0);\n\n  if (_getType(path) === 'boolean') return path;\n  if (path === '') return path;\n  path = path.split('.');\n  path.pop();\n  path = path.join('.');\n  return path;\n}\n/**\r\n * Performs deep search for identity on collection to return the location's depth of the first match. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean}\r\n */\n\n\nfunction _matchDepth(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  var path = _locate2(collection, identity, maxDepth);\n\n  if (path === false) return false;\n  if (path === '') return 0;\n  path = path.split('.');\n  return path.length;\n}\n/**\r\n * Walks through the entire object tree to return the maximum number of layers it contains.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n */\n\n\nfunction _maxDepth2(identity) {\n  var maxLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var R = 0;\n\n  function _maxDepth(identity, maxLayer) {\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (R < currentDepth) R = currentDepth;\n    if (maxLayer !== null) if (currentDepth >= maxLayer) return;\n\n    if (_isIterable(identity)) {\n      var keys = Object.keys(identity);\n      keys.forEach(function (key) {\n        var subIdentity = identity[key];\n\n        _maxDepth(subIdentity, maxLayer, currentDepth + 1);\n      });\n    }\n  }\n\n  _maxDepth(identity, maxLayer);\n\n  return R;\n}\n/**\r\n * Performs deep search for identity on collection, returns the number of matches found.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Number} nthDepth\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns number of matches found.\r\n */\n\n\nfunction _countMatches(collection, identity) {\n  var nthDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var depth,\n      nthDepth_isNull = nthDepth === null,\n      maxDepth_isNull = maxDepth === null;\n  if (nthDepth_isNull && maxDepth_isNull) depth = null;else if (!nthDepth_isNull && !maxDepth_isNull) {\n    if (nthDepth < maxDepth) depth = nthDepth;else depth = maxDepth;\n  } else if (nthDepth) depth = nthDepth;else depth = maxDepth;\n\n  var paths = _locateAll2(collection, identity, depth);\n\n  if (paths === false) return 0;\n  if (nthDepth === null) return paths.length;\n\n  if (_getType(nthDepth) === 'number') {\n    var count = 0;\n    paths.forEach(function (path) {\n      path = path.split('.');\n      if (path.length === nthDepth) count++;\n    });\n    return count;\n  }\n\n  return undefined;\n}\n/**\r\n* Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n* @param {Any} collection\r\n* @param {Any} identities\r\n* @param {Any} property\r\n* @param {Optional Number} maxDepth\r\n* @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n*/\n\n\nfunction _onlyFalsy(collection, identities, property) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      var subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundFalsy2(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key],\n          subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundFalsy2(subCollection, property, maxDepth)) _result[key] = identity;\n    });\n    return _result;\n  }\n\n  if (_foundFalsy2(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction _foundFalsy2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  identity = singleProperty(identity);\n  if (_isFalsy(identity)) return undefined;\n\n  function _foundFalsy(collection, identity, maxDepth) {\n    var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (_containsKeys(collection, [identity])) return _isFalsy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _foundFalsy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundFalsy(collection, identity, maxDepth);\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Any} property\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction _onlyTruthy(collection, identities, property) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      var subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundTruthy2(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result2 = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key],\n          subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundTruthy2(subCollection, property, maxDepth)) _result2[key] = identity;\n    });\n    return _result2;\n  }\n\n  if (_foundTruthy2(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction _foundTruthy2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  identity = singleProperty(identity);\n  if (_isFalsy(identity)) return undefined;\n\n  function _foundTruthy(collection, identity, maxDepth) {\n    var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (_containsKeys(collection, [identity])) return _isTruthy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _foundTruthy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundTruthy(collection, identity, maxDepth, 0);\n}\n/**\r\n * Validates if identity is equal to a property definition or contains a single property key.\r\n * @param {Property} identity\r\n * @return {String || boolean} If criteria matched will return property name as string, otherwise false\r\n */\n\n\nfunction singleProperty(identity) {\n  var propCount = _length(identity);\n\n  if (propCount > 1) return false;\n  if (propCount === 1) return Object.keys(identity)[0];\n  if (propCount === 0) if (['string', 'number'].indexOf(_getType(identity)) > -1) return identity;\n  return false;\n}\n/**\r\n * Determines if identity is non-falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction _isTruthy(identity) {\n  return !_isFalsy(identity);\n}\n/**\r\n * Determines if identity is falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction _isFalsy(identity) {\n  if (falser(identity) === false) return true;\n  return false;\n}\n/**\r\n * Converts false-like values into actual boolean value of false\r\n * @param {Any} identity\r\n * @return {Any || boolean} Returns false is value is falsy, otherwise returns original value.\r\n */\n\n\nfunction falser(identity) {\n  if (_isIterable(identity)) return identity;\n  if (['null', 'undefined'].indexOf(_getType(identity)) > -1) return false;\n  if (['', 0, false].indexOf(identity) > -1) return false;\n  return identity;\n}\n/**\r\n * Check the length of the top-most depth of the identity\r\n * @param {Any} identity\r\n * @return {integer} Greater than or equal to 0.\r\n */\n\n\nfunction _length(identity) {\n  if (['array', 'object'].indexOf(_getType(identity)) === -1) return 0;\n  return Object.keys(identity).length;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that does meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that were not matched.\r\n */\n\n\nfunction _onlyMissing(collection, identities) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      if (!_exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result3 = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key];\n      if (!_exists(collection, identity, maxDepth)) _result3[key] = identity;\n    });\n    return _result3;\n  }\n\n  if (!_exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction _onlyExisting(collection, identities) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      if (_exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result4 = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key];\n      if (_exists(collection, identity, maxDepth)) _result4[key] = identity;\n    });\n    return _result4;\n  }\n\n  if (_exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the identity\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If a match is confirmed will return true, otherwise false\r\n */\n\n\nfunction _exists(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (_identical(collection, identity)) return true;\n  if (_isIterable(identity)) if (_sameType(collection, identity)) if (_containsKeys(collection, Object.keys(identity))) {\n    var trimmed = _trim(collection, Object.keys(identity));\n\n    if (_identical(trimmed, identity)) return true;\n  }\n  if (maxDepth === null ? true : currentDepth < maxDepth) if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n    var key = keys[i],\n        subcollection = collection[key],\n        res = _exists(subcollection, identity, maxDepth, currentDepth + 1);\n\n    if (res) return true;\n  }\n  return false;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, will return a list of identities containing the match. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} identities\r\n */\n\n\nfunction _deepFilter(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  var paths = _locateAll2(collection, identity, maxDepth);\n\n  if (paths === false) return undefined;\n  var results = paths.map(function (path) {\n    if (path === '') return collection;\n    path = path.split('.');\n    if (['array', 'object'].indexOf(_getType(identity)) === -1) path.splice(-1, 1);\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(function (key) {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, returns a string array containing the location of all matches. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction _locateAll2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var R = [];\n\n  function _locateAll(collection, identity) {\n    var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var maxDepth = arguments.length > 3 ? arguments[3] : undefined;\n    var currentDepth = arguments.length > 4 ? arguments[4] : undefined;\n    if (_isIterable(identity)) if (_sameType(collection, identity)) if (_containsKeys(collection, Object.keys(identity))) {\n      var trimmed = _trim(collection, Object.keys(identity));\n\n      if (_identical(trimmed, identity)) R[R.length] = path;\n    }\n    if (_identical(collection, identity)) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key];\n\n      _locateAll(subcollection, identity, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll(collection, identity, '', maxDepth, 0);\n\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the identity containing of the first instance matched. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {identity || undefined} identity\r\n */\n\n\nfunction _deepGet(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  var path = _locate2(collection, identity, maxDepth);\n\n  if (path === false) return undefined;\n  if (path === '') return collection;\n  path = path.split('.');\n  if (['array', 'object'].indexOf(_getType(identity)) === -1) path.splice(-1, 1);\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(function (key) {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the path of the first instance matched as string. If no matches found, returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional number} maxDepth\r\n * @return {string || false} path\r\n */\n\n\nfunction _locate2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  function _locate(collection, identity) {\n    var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var maxDepth = arguments.length > 3 ? arguments[3] : undefined;\n    var currentDepth = arguments.length > 4 ? arguments[4] : undefined;\n    if (_isIterable(identity)) if (_sameType(collection, identity)) if (_containsKeys(collection, Object.keys(identity))) {\n      var trimmed = _trim(collection, Object.keys(identity));\n\n      if (_identical(trimmed, identity)) return path;\n    }\n    if (_identical(collection, identity)) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _locate(subcollection, identity, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  return _locate(collection, identity, '', maxDepth, 0);\n}\n/**\r\n * Trims an identity to only contain the specified properties.\r\n * @param {Any} identity\r\n * @param {Any} keyList\r\n * @return {Object or Array} Returns , otherwise false\r\n */\n\n\nfunction _trim(identity, keyList) {\n  var identityType = _getType(identity);\n\n  if (['array', 'object'].indexOf(identityType) === -1) return undefined;\n  var keyCount = keyList.length;\n  if (keyCount === 0) return undefined;\n  var newIdentity;\n\n  switch (identityType) {\n    case 'object':\n      newIdentity = {};\n      keyList.forEach(function (key) {\n        if (key in identity) newIdentity[key] = identity[key];\n      });\n      break;\n\n    case 'array':\n      newIdentity = [];\n      keyList.forEach(function (key) {\n        if (key in identity) newIdentity.push(identity[key]);\n      });\n      break;\n  }\n\n  return newIdentity;\n}\n/**\r\n * Check if identity contains all of the specified keys\r\n * @param {Any} identity\r\n * @param {Array} keyList\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _containsKeys(identity, keyList) {\n  var keyCount = keyList.length;\n  if (keyCount === 0 || !_isIterable(identity)) return false;\n  var identitykeys = Object.keys(identity);\n  var result = true;\n\n  for (var i = 0; i < keyCount; i++) {\n    var key = '' + keyList[i];\n\n    if (identitykeys.indexOf(key) === -1) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Check if identity has one or more keys to iterate\r\n * @param {Any} identity\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _isIterable(identity) {\n  if (['array', 'object'].indexOf(_getType(identity)) === -1) return false;\n  if (Object.keys(identity).length === 0) return false;\n  return true;\n}\n/**\r\n * Compares two identities, will return either true if identical, otherwise false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _identical(identityA, identityB) {\n  var structureMatch = _sameStructure(identityA, identityB);\n\n  if (structureMatch === false) return structureMatch;\n  if (['array', 'object'].indexOf(structureMatch) === -1) return identityA === identityB;\n  var Keys = Object.keys(identityA),\n      KeyCount = Keys.length;\n  var childMatch = true;\n\n  for (var i = 0; i < KeyCount; i++) {\n    var Key = Keys[i],\n        identicalMatch = _identical(identityA[Key], identityB[Key]);\n\n    if (identicalMatch === false) {\n      childMatch = identicalMatch;\n      break;\n    }\n\n    ;\n  }\n\n  return childMatch;\n}\n/**\r\n * Compares data structure of two identities, will return either the dataType or true/false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {String || False} DataType as string for positive match, otherwise false\r\n */\n\n\nfunction _sameStructure(identityA, identityB) {\n  var typeMatch = _sameType(identityA, identityB);\n\n  if (typeMatch === false) return false;\n\n  if (['array', 'object'].indexOf(typeMatch) > -1) {\n    var AKeys = Object.keys(identityA),\n        BKeys = Object.keys(identityB),\n        AKeyCount = AKeys.length,\n        BKeyCount = BKeys.length;\n    if (!(AKeyCount === BKeyCount)) return false;\n    if (AKeyCount === 0) return true;\n\n    for (var i = 0; i < AKeyCount; i++) {\n      if (AKeys[i] !== BKeys[i]) return false;\n    }\n  }\n\n  return typeMatch;\n}\n/**\r\n * Compares data type of two identities, will dataType if true.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _sameType(identityA, identityB) {\n  var typeA = _getType(identityA);\n\n  return typeA === _getType(identityB) ? typeA : false;\n}\n/**\r\n * Gets data type; makes distintion between object, array, and null.\r\n * @param {Any} identity\r\n * @return {String} dataType\r\n */\n\n\nfunction _getType(identity) {\n  if (identity === null) return 'null';\n  var it = typeof identity;\n  if (it === 'object') if (Array.isArray(identity)) return 'array';\n  return it;\n}\n\nvar mitsuketa = {\n  getType: function getType(identity) {\n    return _getType(identity);\n  },\n  sameType: function sameType(identityA, identityB) {\n    return _sameType(identityA, identityB);\n  },\n  sameStructure: function sameStructure(identityA, identityB) {\n    return _sameStructure(identityA, identityB);\n  },\n  identical: function identical(identityA, identityB) {\n    return _identical(identityA, identityB);\n  },\n  isIterable: function isIterable(identity) {\n    return _isIterable(identity);\n  },\n  containsKeys: function containsKeys(identity, keyList) {\n    return _containsKeys(identity, keyList);\n  },\n  trim: function trim(identity, keyList) {\n    return _trim(identity, keyList);\n  },\n  locate: function locate(collection, identity, maxDepth) {\n    return _locate2(collection, identity, maxDepth);\n  },\n  deepGet: function deepGet(collection, identity, maxDepth) {\n    return _deepGet(collection, identity, maxDepth);\n  },\n  locateAll: function locateAll(collection, identity, maxDepth) {\n    return _locateAll2(collection, identity, maxDepth);\n  },\n  deepFilter: function deepFilter(collection, identity, maxDepth) {\n    return _deepFilter(collection, identity, maxDepth);\n  },\n  exists: function exists(collection, identity, maxDepth) {\n    return _exists(collection, identity, maxDepth);\n  },\n  onlyExisting: function onlyExisting(collection, identities, maxDepth) {\n    return _onlyExisting(collection, identities, maxDepth);\n  },\n  onlyMissing: function onlyMissing(collection, identities, maxDepth) {\n    return _onlyMissing(collection, identities, maxDepth);\n  },\n  length: function length(identity) {\n    return _length(identity);\n  },\n  isFalsy: function isFalsy(identity) {\n    return _isFalsy(identity);\n  },\n  isTruthy: function isTruthy(identity) {\n    return _isTruthy(identity);\n  },\n  foundTruthy: function foundTruthy(collection, identity, maxDepth) {\n    return _foundTruthy2(collection, identity, maxDepth);\n  },\n  onlyTruthy: function onlyTruthy(collection, identities, property, maxDepth) {\n    return _onlyTruthy(collection, identities, property, maxDepth);\n  },\n  foundFalsy: function foundFalsy(collection, identity, maxDepth) {\n    return _foundFalsy2(collection, identity, maxDepth);\n  },\n  onlyFalsy: function onlyFalsy(collection, identities, property, maxDepth) {\n    return _onlyFalsy(collection, identities, property, maxDepth);\n  },\n  countMatches: function countMatches(collection, identity, nthDepth, maxDepth) {\n    return _countMatches(collection, identity, nthDepth, maxDepth);\n  },\n  matchDepth: function matchDepth(collection, identity, maxDepth) {\n    return _matchDepth(collection, identity, maxDepth);\n  },\n  maxDepth: function maxDepth(identity, maxLayer) {\n    return _maxDepth2(identity, maxLayer);\n  },\n  locate_Key: function locate_Key(collection, keyName, maxDepth) {\n    return _locate_Key2(collection, keyName, maxDepth);\n  },\n  deepGet_Key: function deepGet_Key(collection, keyName, maxDepth) {\n    return _deepGet_Key(collection, keyName, maxDepth);\n  },\n  locateAll_Key: function locateAll_Key(collection, keyName, maxDepth) {\n    return _locateAll_Key2(collection, keyName, maxDepth);\n  },\n  deepFilter_Key: function deepFilter_Key(collection, keyName, maxDepth) {\n    return _deepFilter_Key(collection, keyName, maxDepth);\n  },\n  deepClone: function deepClone(identity, maxDepth, startDepth) {\n    return _deepClone2(identity, maxDepth, startDepth);\n  },\n  renameKey: function renameKey(identity, keyName, newKeyName, maxDepth) {\n    return _renameKey2(identity, keyName, newKeyName, maxDepth);\n  },\n  renameKeys: function renameKeys(identity, keyName, newKeyName, maxDepth) {\n    return _renameKeys2(identity, keyName, newKeyName, maxDepth);\n  },\n  deepRemove_Key: function deepRemove_Key(identity, keyName, maxDepth) {\n    return _deepRemove_Key(identity, keyName, maxDepth);\n  },\n  deepRemoveAll_Key: function deepRemoveAll_Key(identity, keyName, maxDepth) {\n    return _deepRemoveAll_Key(identity, keyName, maxDepth);\n  }\n};\nmodule.exports = exports = mitsuketa;","map":null,"metadata":{},"sourceType":"script"}