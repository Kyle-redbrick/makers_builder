{"ast":null,"code":"/*!\n * wavesurfer.js regions plugin 5.1.0 (2021-06-20)\n * https://wavesurfer-js.org\n * @license BSD-3-Clause\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"WaveSurfer\", [], factory);else if (typeof exports === 'object') exports[\"WaveSurfer\"] = factory();else root[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"regions\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function () {\n      // webpackBootstrap\n\n      /******/\n      \"use strict\";\n      /******/\n\n      var __webpack_modules__ = {\n        /***/\n        \"./src/plugin/regions/index.js\":\n        /*!*************************************!*\\\n          !*** ./src/plugin/regions/index.js ***!\n          \\*************************************/\n\n        /***/\n        function srcPluginRegionsIndexJs(module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.default = void 0;\n\n          var _region = __webpack_require__(\n          /*! ./region.js */\n          \"./src/plugin/regions/region.js\");\n\n          function ownKeys(object, enumerableOnly) {\n            var keys = Object.keys(object);\n\n            if (Object.getOwnPropertySymbols) {\n              var symbols = Object.getOwnPropertySymbols(object);\n\n              if (enumerableOnly) {\n                symbols = symbols.filter(function (sym) {\n                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                });\n              }\n\n              keys.push.apply(keys, symbols);\n            }\n\n            return keys;\n          }\n\n          function _objectSpread(target) {\n            for (var i = 1; i < arguments.length; i++) {\n              var source = arguments[i] != null ? arguments[i] : {};\n\n              if (i % 2) {\n                ownKeys(Object(source), true).forEach(function (key) {\n                  _defineProperty(target, key, source[key]);\n                });\n              } else if (Object.getOwnPropertyDescriptors) {\n                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n              } else {\n                ownKeys(Object(source)).forEach(function (key) {\n                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                });\n              }\n            }\n\n            return target;\n          }\n\n          function _defineProperty(obj, key, value) {\n            if (key in obj) {\n              Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n            } else {\n              obj[key] = value;\n            }\n\n            return obj;\n          }\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n          /**\n           * Regions are visual overlays on waveform that can be used to play and loop\n           * portions of audio. Regions can be dragged and resized.\n           *\n           * Visual customization is possible via CSS (using the selectors\n           * `.wavesurfer-region` and `.wavesurfer-handle`).\n           *\n           * @implements {PluginClass}\n           * @extends {Observer}\n           *\n           * @example\n           * // es6\n           * import RegionsPlugin from 'wavesurfer.regions.js';\n           *\n           * // commonjs\n           * var RegionsPlugin = require('wavesurfer.regions.js');\n           *\n           * // if you are using <script> tags\n           * var RegionsPlugin = window.WaveSurfer.regions;\n           *\n           * // ... initialising wavesurfer with the plugin\n           * var wavesurfer = WaveSurfer.create({\n           *   // wavesurfer options ...\n           *   plugins: [\n           *     RegionsPlugin.create({\n           *       // plugin options ...\n           *     })\n           *   ]\n           * });\n           */\n\n\n          var RegionsPlugin =\n          /*#__PURE__*/\n          function () {\n            function RegionsPlugin(params, ws) {\n              var _this = this;\n\n              _classCallCheck(this, RegionsPlugin);\n\n              this.params = params;\n              this.wavesurfer = ws;\n              this.util = _objectSpread(_objectSpread({}, ws.util), {}, {\n                getRegionSnapToGridValue: function getRegionSnapToGridValue(value) {\n                  return _this.getRegionSnapToGridValue(value, params);\n                }\n              });\n              this.maxRegions = params.maxRegions;\n              this.regionsMinLength = params.regionsMinLength || null; // turn the plugin instance into an observer\n\n              var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);\n              observerPrototypeKeys.forEach(function (key) {\n                _region.Region.prototype[key] = _this.util.Observer.prototype[key];\n              });\n              this.wavesurfer.Region = _region.Region; // By default, scroll the container if the user drags a region\n              // within 5% of its edge\n\n              var scrollWidthProportion = 0.05;\n\n              this._onBackendCreated = function () {\n                _this.wrapper = _this.wavesurfer.drawer.wrapper;\n                _this.orientation = _this.wavesurfer.drawer.orientation;\n\n                if (_this.params.regions) {\n                  _this.params.regions.forEach(function (region) {\n                    region.edgeScrollWidth = _this.params.edgeScrollWidth || _this.wrapper.clientWidth * scrollWidthProportion;\n\n                    _this.add(region);\n                  });\n                }\n              }; // Id-based hash of regions\n\n\n              this.list = {};\n\n              this._onReady = function () {\n                _this.wrapper = _this.wavesurfer.drawer.wrapper;\n                _this.vertical = _this.wavesurfer.drawer.params.vertical;\n\n                if (_this.params.dragSelection) {\n                  _this.enableDragSelection(_this.params);\n                }\n\n                Object.keys(_this.list).forEach(function (id) {\n                  _this.list[id].updateRender();\n                });\n              };\n            }\n\n            _createClass(RegionsPlugin, [{\n              key: \"init\",\n              value: function init() {\n                // Check if ws is ready\n                if (this.wavesurfer.isReady) {\n                  this._onBackendCreated();\n\n                  this._onReady();\n                } else {\n                  this.wavesurfer.once('ready', this._onReady);\n                  this.wavesurfer.once('backend-created', this._onBackendCreated);\n                }\n              }\n            }, {\n              key: \"destroy\",\n              value: function destroy() {\n                this.wavesurfer.un('ready', this._onReady);\n                this.wavesurfer.un('backend-created', this._onBackendCreated);\n                this.disableDragSelection();\n                this.clear();\n              }\n              /**\n               * check to see if adding a new region would exceed maxRegions\n               * @return {boolean} whether we should proceed and create a region\n               * @private\n               */\n\n            }, {\n              key: \"wouldExceedMaxRegions\",\n              value: function wouldExceedMaxRegions() {\n                return this.maxRegions && Object.keys(this.list).length >= this.maxRegions;\n              }\n              /**\n               * Add a region\n               *\n               * @param {object} params Region parameters\n               * @return {Region} The created region\n               */\n\n            }, {\n              key: \"add\",\n              value: function add(params) {\n                var _this2 = this;\n\n                if (this.wouldExceedMaxRegions()) {\n                  return null;\n                }\n\n                if (!params.minLength && this.regionsMinLength) {\n                  params = _objectSpread(_objectSpread({}, params), {}, {\n                    minLength: this.regionsMinLength\n                  });\n                }\n\n                var region = new this.wavesurfer.Region(params, this.util, this.wavesurfer);\n                this.list[region.id] = region;\n                region.on('remove', function () {\n                  delete _this2.list[region.id];\n                });\n                return region;\n              }\n              /**\n               * Remove all regions\n               */\n\n            }, {\n              key: \"clear\",\n              value: function clear() {\n                var _this3 = this;\n\n                Object.keys(this.list).forEach(function (id) {\n                  _this3.list[id].remove();\n                });\n              }\n            }, {\n              key: \"enableDragSelection\",\n              value: function enableDragSelection(params) {\n                var _this4 = this;\n\n                this.disableDragSelection();\n                var slop = params.slop || 2;\n                var container = this.wavesurfer.drawer.container;\n                var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;\n                var scrollSpeed = params.scrollSpeed || 1;\n                var scrollThreshold = params.scrollThreshold || 10;\n                var drag;\n                var duration = this.wavesurfer.getDuration();\n                var maxScroll;\n                var start;\n                var region;\n                var touchId;\n                var pxMove = 0;\n                var scrollDirection;\n                var wrapperRect; // Scroll when the user is dragging within the threshold\n\n                var edgeScroll = function edgeScroll(e) {\n                  if (!region || !scrollDirection) {\n                    return;\n                  } // Update scroll position\n\n\n                  var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n                  _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update range\n\n                  var end = _this4.wavesurfer.drawer.handleEvent(e);\n\n                  region.update({\n                    start: Math.min(end * duration, start * duration),\n                    end: Math.max(end * duration, start * duration)\n                  }); // Check that there is more to scroll and repeat\n\n                  if (scrollLeft < maxScroll && scrollLeft > 0) {\n                    window.requestAnimationFrame(function () {\n                      edgeScroll(e);\n                    });\n                  }\n                };\n\n                var eventDown = function eventDown(e) {\n                  if (e.touches && e.touches.length > 1) {\n                    return;\n                  }\n\n                  duration = _this4.wavesurfer.getDuration();\n                  touchId = e.targetTouches ? e.targetTouches[0].identifier : null; // Store for scroll calculations\n\n                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;\n                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);\n                  drag = true;\n                  start = _this4.wavesurfer.drawer.handleEvent(e, true);\n                  region = null;\n                  scrollDirection = null;\n                };\n\n                this.wrapper.addEventListener('mousedown', eventDown);\n                this.wrapper.addEventListener('touchstart', eventDown);\n                this.on('disable-drag-selection', function () {\n                  _this4.wrapper.removeEventListener('touchstart', eventDown);\n\n                  _this4.wrapper.removeEventListener('mousedown', eventDown);\n                });\n\n                var eventUp = function eventUp(e) {\n                  if (e.touches && e.touches.length > 1) {\n                    return;\n                  }\n\n                  drag = false;\n                  pxMove = 0;\n                  scrollDirection = null;\n\n                  if (region) {\n                    _this4.util.preventClick();\n\n                    region.fireEvent('update-end', e);\n\n                    _this4.wavesurfer.fireEvent('region-update-end', region, e);\n                  }\n\n                  region = null;\n                };\n\n                this.wrapper.addEventListener('mouseleave', eventUp);\n                this.wrapper.addEventListener('mouseup', eventUp);\n                this.wrapper.addEventListener('touchend', eventUp);\n                document.body.addEventListener('mouseup', eventUp);\n                document.body.addEventListener('touchend', eventUp);\n                this.on('disable-drag-selection', function () {\n                  document.body.removeEventListener('mouseup', eventUp);\n                  document.body.removeEventListener('touchend', eventUp);\n\n                  _this4.wrapper.removeEventListener('touchend', eventUp);\n\n                  _this4.wrapper.removeEventListener('mouseup', eventUp);\n\n                  _this4.wrapper.removeEventListener('mouseleave', eventUp);\n                });\n\n                var eventMove = function eventMove(event) {\n                  if (!drag) {\n                    return;\n                  }\n\n                  if (++pxMove <= slop) {\n                    return;\n                  }\n\n                  if (event.touches && event.touches.length > 1) {\n                    return;\n                  }\n\n                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\n                    return;\n                  } // auto-create a region during mouse drag, unless region-count would exceed \"maxRegions\"\n\n\n                  if (!region) {\n                    region = _this4.add(params || {});\n\n                    if (!region) {\n                      return;\n                    }\n                  }\n\n                  var end = _this4.wavesurfer.drawer.handleEvent(event);\n\n                  var startUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(start * duration);\n\n                  var endUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(end * duration);\n\n                  region.update({\n                    start: Math.min(endUpdate, startUpdate),\n                    end: Math.max(endUpdate, startUpdate)\n                  });\n\n                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical); // If scrolling is enabled\n\n\n                  if (scroll && container.clientWidth < _this4.wrapper.scrollWidth) {\n                    // Check threshold based on mouse\n                    var x = orientedEvent.clientX - wrapperRect.left;\n\n                    if (x <= scrollThreshold) {\n                      scrollDirection = -1;\n                    } else if (x >= wrapperRect.right - scrollThreshold) {\n                      scrollDirection = 1;\n                    } else {\n                      scrollDirection = null;\n                    }\n\n                    scrollDirection && edgeScroll(event);\n                  }\n                };\n\n                this.wrapper.addEventListener('mousemove', eventMove);\n                this.wrapper.addEventListener('touchmove', eventMove);\n                this.on('disable-drag-selection', function () {\n                  _this4.wrapper.removeEventListener('touchmove', eventMove);\n\n                  _this4.wrapper.removeEventListener('mousemove', eventMove);\n                });\n                this.wavesurfer.on('region-created', function (region) {\n                  if (_this4.regionsMinLength) {\n                    region.minLength = _this4.regionsMinLength;\n                  }\n                });\n              }\n            }, {\n              key: \"disableDragSelection\",\n              value: function disableDragSelection() {\n                this.fireEvent('disable-drag-selection');\n              }\n              /**\n               * Get current region\n               *\n               * The smallest region that contains the current time. If several such\n               * regions exist, take the first. Return `null` if none exist.\n               *\n               * @returns {Region} The current region\n               */\n\n            }, {\n              key: \"getCurrentRegion\",\n              value: function getCurrentRegion() {\n                var _this5 = this;\n\n                var time = this.wavesurfer.getCurrentTime();\n                var min = null;\n                Object.keys(this.list).forEach(function (id) {\n                  var cur = _this5.list[id];\n\n                  if (cur.start <= time && cur.end >= time) {\n                    if (!min || cur.end - cur.start < min.end - min.start) {\n                      min = cur;\n                    }\n                  }\n                });\n                return min;\n              }\n              /**\n               * Match the value to the grid, if required\n               *\n               * If the regions plugin params have a snapToGridInterval set, return the\n               * value matching the nearest grid interval. If no snapToGridInterval is set,\n               * the passed value will be returned without modification.\n               *\n               * @param {number} value the value to snap to the grid, if needed\n               * @param {Object} params the regions plugin params\n               * @returns {number} value\n               */\n\n            }, {\n              key: \"getRegionSnapToGridValue\",\n              value: function getRegionSnapToGridValue(value, params) {\n                if (params.snapToGridInterval) {\n                  // the regions should snap to a grid\n                  var offset = params.snapToGridOffset || 0;\n                  return Math.round((value - offset) / params.snapToGridInterval) * params.snapToGridInterval + offset;\n                } // no snap-to-grid\n\n\n                return value;\n              }\n            }], [{\n              key: \"create\",\n              value:\n              /**\n               * Regions plugin definition factory\n               *\n               * This function must be used to create a plugin definition which can be\n               * used by wavesurfer to correctly instantiate the plugin.\n               *\n               * @param {RegionsPluginParams} params parameters use to initialise the plugin\n               * @return {PluginDefinition} an object representing the plugin\n               */\n              function create(params) {\n                return {\n                  name: 'regions',\n                  deferInit: params && params.deferInit ? params.deferInit : false,\n                  params: params,\n                  staticProps: {\n                    addRegion: function addRegion(options) {\n                      if (!this.initialisedPluginList.regions) {\n                        this.initPlugin('regions');\n                      }\n\n                      return this.regions.add(options);\n                    },\n                    clearRegions: function clearRegions() {\n                      this.regions && this.regions.clear();\n                    },\n                    enableDragSelection: function enableDragSelection(options) {\n                      if (!this.initialisedPluginList.regions) {\n                        this.initPlugin('regions');\n                      }\n\n                      this.regions.enableDragSelection(options);\n                    },\n                    disableDragSelection: function disableDragSelection() {\n                      this.regions.disableDragSelection();\n                    }\n                  },\n                  instance: RegionsPlugin\n                };\n              }\n            }]);\n\n            return RegionsPlugin;\n          }();\n\n          exports.default = RegionsPlugin;\n          module.exports = exports.default;\n          /***/\n        },\n\n        /***/\n        \"./src/plugin/regions/region.js\":\n        /*!**************************************!*\\\n          !*** ./src/plugin/regions/region.js ***!\n          \\**************************************/\n\n        /***/\n        function srcPluginRegionsRegionJs(__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.Region = void 0;\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n          /**\n           *  @since 4.0.0\n           *\n           * (Single) Region plugin class\n           *\n           * Must be turned into an observer before instantiating. This is done in\n           * `RegionsPlugin` (main plugin class).\n           *\n           * @extends {Observer}\n           */\n\n\n          var Region =\n          /*#__PURE__*/\n          function () {\n            function Region(params, regionsUtils, ws) {\n              var _params$showTooltip,\n                  _this = this;\n\n              _classCallCheck(this, Region);\n\n              this.wavesurfer = ws;\n              this.wrapper = ws.drawer.wrapper;\n              this.util = ws.util;\n              this.style = this.util.style;\n              this.regionsUtil = regionsUtils;\n              this.vertical = ws.drawer.params.vertical;\n              this.id = params.id == null ? ws.util.getId() : params.id;\n              this.start = Number(params.start) || 0;\n              this.end = params.end == null ? // small marker-like region\n              this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);\n              this.resize = params.resize === undefined ? true : Boolean(params.resize);\n              this.drag = params.drag === undefined ? true : Boolean(params.drag); // reflect resize and drag state of region for region-updated listener\n\n              this.isResizing = false;\n              this.isDragging = false;\n              this.loop = Boolean(params.loop);\n              this.color = params.color || 'rgba(0, 0, 0, 0.1)'; // The left and right handleStyle properties can be set to 'none' for\n              // no styling or can be assigned an object containing CSS properties.\n\n              this.handleStyle = params.handleStyle || {\n                left: {},\n                right: {}\n              };\n              this.handleLeftEl = null;\n              this.handleRightEl = null;\n              this.data = params.data || {};\n              this.attributes = params.attributes || {};\n              this.showTooltip = (_params$showTooltip = params.showTooltip) !== null && _params$showTooltip !== void 0 ? _params$showTooltip : true;\n              this.maxLength = params.maxLength; // It assumes the minLength parameter value, or the regionsMinLength parameter value, if the first one not provided\n\n              this.minLength = params.minLength;\n\n              this._onRedraw = function () {\n                return _this.updateRender();\n              };\n\n              this.scroll = params.scroll !== false && ws.params.scrollParent;\n              this.scrollSpeed = params.scrollSpeed || 1;\n              this.scrollThreshold = params.scrollThreshold || 10; // Determines whether the context menu is prevented from being opened.\n\n              this.preventContextMenu = params.preventContextMenu === undefined ? false : Boolean(params.preventContextMenu); // select channel ID to set region\n\n              var channelIdx = params.channelIdx == null ? -1 : parseInt(params.channelIdx);\n              this.regionHeight = '100%';\n              this.marginTop = '0px';\n\n              if (channelIdx !== -1) {\n                var channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : -1;\n\n                if (channelCount >= 0 && channelIdx < channelCount) {\n                  this.regionHeight = Math.floor(1 / channelCount * 100) + '%';\n                  this.marginTop = this.wavesurfer.getHeight() * channelIdx + 'px';\n                }\n              }\n\n              this.formatTimeCallback = params.formatTimeCallback;\n              this.edgeScrollWidth = params.edgeScrollWidth;\n              this.bindInOut();\n              this.render();\n              this.wavesurfer.on('zoom', this._onRedraw);\n              this.wavesurfer.on('redraw', this._onRedraw);\n              this.wavesurfer.fireEvent('region-created', this);\n            }\n            /* Update region params. */\n\n\n            _createClass(Region, [{\n              key: \"update\",\n              value: function update(params) {\n                if (params.start != null) {\n                  this.start = Number(params.start);\n                }\n\n                if (params.end != null) {\n                  this.end = Number(params.end);\n                }\n\n                if (params.loop != null) {\n                  this.loop = Boolean(params.loop);\n                }\n\n                if (params.color != null) {\n                  this.color = params.color;\n                }\n\n                if (params.handleStyle != null) {\n                  this.handleStyle = params.handleStyle;\n                }\n\n                if (params.data != null) {\n                  this.data = params.data;\n                }\n\n                if (params.resize != null) {\n                  this.resize = Boolean(params.resize);\n                  this.updateHandlesResize(this.resize);\n                }\n\n                if (params.drag != null) {\n                  this.drag = Boolean(params.drag);\n                }\n\n                if (params.maxLength != null) {\n                  this.maxLength = Number(params.maxLength);\n                }\n\n                if (params.minLength != null) {\n                  this.minLength = Number(params.minLength);\n                }\n\n                if (params.attributes != null) {\n                  this.attributes = params.attributes;\n                }\n\n                this.updateRender();\n                this.fireEvent('update');\n                this.wavesurfer.fireEvent('region-updated', this);\n              }\n              /* Remove a single region. */\n\n            }, {\n              key: \"remove\",\n              value: function remove() {\n                if (this.element) {\n                  this.wrapper.removeChild(this.element.domElement);\n                  this.element = null;\n                  this.fireEvent('remove');\n                  this.wavesurfer.un('zoom', this._onRedraw);\n                  this.wavesurfer.un('redraw', this._onRedraw);\n                  this.wavesurfer.fireEvent('region-removed', this);\n                }\n              }\n              /**\n               * Play the audio region.\n               * @param {number} start Optional offset to start playing at\n               */\n\n            }, {\n              key: \"play\",\n              value: function play(start) {\n                var s = start || this.start;\n                this.wavesurfer.play(s, this.end);\n                this.fireEvent('play');\n                this.wavesurfer.fireEvent('region-play', this);\n              }\n              /**\n               * Play the audio region in a loop.\n               * @param {number} start Optional offset to start playing at\n               * */\n\n            }, {\n              key: \"playLoop\",\n              value: function playLoop(start) {\n                this.loop = true;\n                this.play(start);\n              }\n              /**\n               * Set looping on/off.\n               * @param {boolean} loop True if should play in loop\n               */\n\n            }, {\n              key: \"setLoop\",\n              value: function setLoop(loop) {\n                this.loop = loop;\n              }\n              /* Render a region as a DOM element. */\n\n            }, {\n              key: \"render\",\n              value: function render() {\n                this.element = this.util.withOrientation(this.wrapper.appendChild(document.createElement('region')), this.vertical);\n                this.element.className = 'wavesurfer-region';\n\n                if (this.showTooltip) {\n                  this.element.title = this.formatTime(this.start, this.end);\n                }\n\n                this.element.setAttribute('data-id', this.id);\n\n                for (var attrname in this.attributes) {\n                  this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n                }\n\n                this.style(this.element, {\n                  position: 'absolute',\n                  zIndex: 2,\n                  height: this.regionHeight,\n                  top: this.marginTop\n                });\n                /* Resize handles */\n\n                if (this.resize) {\n                  this.handleLeftEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);\n                  this.handleRightEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);\n                  this.handleLeftEl.className = 'wavesurfer-handle wavesurfer-handle-start';\n                  this.handleRightEl.className = 'wavesurfer-handle wavesurfer-handle-end'; // Default CSS properties for both handles.\n\n                  var css = {\n                    cursor: this.vertical ? 'row-resize' : 'col-resize',\n                    position: 'absolute',\n                    top: '0px',\n                    width: '2px',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 1)'\n                  }; // Merge CSS properties per handle.\n\n                  var handleLeftCss = this.handleStyle.left !== 'none' ? Object.assign({\n                    left: '0px'\n                  }, css, this.handleStyle.left) : null;\n                  var handleRightCss = this.handleStyle.right !== 'none' ? Object.assign({\n                    right: '0px'\n                  }, css, this.handleStyle.right) : null;\n\n                  if (handleLeftCss) {\n                    this.style(this.handleLeftEl, handleLeftCss);\n                  }\n\n                  if (handleRightCss) {\n                    this.style(this.handleRightEl, handleRightCss);\n                  }\n                }\n\n                this.updateRender();\n                this.bindEvents();\n              }\n            }, {\n              key: \"formatTime\",\n              value: function formatTime(start, end) {\n                if (this.formatTimeCallback) {\n                  return this.formatTimeCallback(start, end);\n                }\n\n                return (start == end ? [start] : [start, end]).map(function (time) {\n                  return [Math.floor(time % 3600 / 60), // minutes\n                  ('00' + Math.floor(time % 60)).slice(-2) // seconds\n                  ].join(':');\n                }).join('-');\n              }\n            }, {\n              key: \"getWidth\",\n              value: function getWidth() {\n                return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;\n              }\n              /* Update element's position, width, color. */\n\n            }, {\n              key: \"updateRender\",\n              value: function updateRender() {\n                // duration varies during loading process, so don't overwrite important data\n                var dur = this.wavesurfer.getDuration();\n                var width = this.getWidth();\n                var startLimited = this.start;\n                var endLimited = this.end;\n\n                if (startLimited < 0) {\n                  startLimited = 0;\n                  endLimited = endLimited - startLimited;\n                }\n\n                if (endLimited > dur) {\n                  endLimited = dur;\n                  startLimited = dur - (endLimited - startLimited);\n                }\n\n                if (this.minLength != null) {\n                  endLimited = Math.max(startLimited + this.minLength, endLimited);\n                }\n\n                if (this.maxLength != null) {\n                  endLimited = Math.min(startLimited + this.maxLength, endLimited);\n                }\n\n                if (this.element != null) {\n                  // Calculate the left and width values of the region such that\n                  // no gaps appear between regions.\n                  var left = Math.round(startLimited / dur * width);\n                  var regionWidth = Math.round(endLimited / dur * width) - left;\n                  this.style(this.element, {\n                    left: left + 'px',\n                    width: regionWidth + 'px',\n                    backgroundColor: this.color,\n                    cursor: this.drag ? 'move' : 'default'\n                  });\n\n                  for (var attrname in this.attributes) {\n                    this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n                  }\n\n                  if (this.showTooltip) {\n                    this.element.title = this.formatTime(this.start, this.end);\n                  }\n                }\n              }\n              /* Bind audio events. */\n\n            }, {\n              key: \"bindInOut\",\n              value: function bindInOut() {\n                var _this2 = this;\n\n                this.firedIn = false;\n                this.firedOut = false;\n\n                var onProcess = function onProcess(time) {\n                  var start = Math.round(_this2.start * 10) / 10;\n                  var end = Math.round(_this2.end * 10) / 10;\n                  time = Math.round(time * 10) / 10;\n\n                  if (!_this2.firedOut && _this2.firedIn && (start > time || end <= time)) {\n                    _this2.firedOut = true;\n                    _this2.firedIn = false;\n\n                    _this2.fireEvent('out');\n\n                    _this2.wavesurfer.fireEvent('region-out', _this2);\n                  }\n\n                  if (!_this2.firedIn && start <= time && end > time) {\n                    _this2.firedIn = true;\n                    _this2.firedOut = false;\n\n                    _this2.fireEvent('in');\n\n                    _this2.wavesurfer.fireEvent('region-in', _this2);\n                  }\n                };\n\n                this.wavesurfer.backend.on('audioprocess', onProcess);\n                this.on('remove', function () {\n                  _this2.wavesurfer.backend.un('audioprocess', onProcess);\n                });\n                /* Loop playback. */\n\n                this.on('out', function () {\n                  if (_this2.loop) {\n                    var realTime = _this2.wavesurfer.getCurrentTime();\n\n                    if (realTime >= _this2.start && realTime <= _this2.end) {\n                      _this2.wavesurfer.play(_this2.start);\n                    }\n                  }\n                });\n              }\n              /* Bind DOM events. */\n\n            }, {\n              key: \"bindEvents\",\n              value: function bindEvents() {\n                var _this3 = this;\n\n                var preventContextMenu = this.preventContextMenu;\n                this.element.addEventListener('mouseenter', function (e) {\n                  _this3.fireEvent('mouseenter', e);\n\n                  _this3.wavesurfer.fireEvent('region-mouseenter', _this3, e);\n                });\n                this.element.addEventListener('mouseleave', function (e) {\n                  _this3.fireEvent('mouseleave', e);\n\n                  _this3.wavesurfer.fireEvent('region-mouseleave', _this3, e);\n                });\n                this.element.addEventListener('click', function (e) {\n                  e.preventDefault();\n\n                  _this3.fireEvent('click', e);\n\n                  _this3.wavesurfer.fireEvent('region-click', _this3, e);\n                });\n                this.element.addEventListener('dblclick', function (e) {\n                  e.stopPropagation();\n                  e.preventDefault();\n\n                  _this3.fireEvent('dblclick', e);\n\n                  _this3.wavesurfer.fireEvent('region-dblclick', _this3, e);\n                });\n                this.element.addEventListener('contextmenu', function (e) {\n                  if (preventContextMenu) {\n                    e.preventDefault();\n                  }\n\n                  _this3.fireEvent('contextmenu', e);\n\n                  _this3.wavesurfer.fireEvent('region-contextmenu', _this3, e);\n                });\n                /* Drag or resize on mousemove. */\n\n                if (this.drag || this.resize) {\n                  this.bindDragEvents();\n                }\n              }\n            }, {\n              key: \"bindDragEvents\",\n              value: function bindDragEvents() {\n                var _this4 = this;\n\n                var container = this.wavesurfer.drawer.container;\n                var scrollSpeed = this.scrollSpeed;\n                var scrollThreshold = this.scrollThreshold;\n                var startTime;\n                var touchId;\n                var drag;\n                var maxScroll;\n                var resize;\n                var updated = false;\n                var scrollDirection;\n                var wrapperRect;\n                var regionLeftHalfTime;\n                var regionRightHalfTime; // Scroll when the user is dragging within the threshold\n\n                var edgeScroll = function edgeScroll(event) {\n                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);\n\n                  var duration = _this4.wavesurfer.getDuration();\n\n                  if (!scrollDirection || !drag && !resize) {\n                    return;\n                  }\n\n                  var x = orientedEvent.clientX;\n                  var distanceBetweenCursorAndWrapperEdge = 0;\n                  var regionHalfTimeWidth = 0;\n                  var adjustment = 0; // Get the currently selected time according to the mouse position\n\n                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);\n\n                  if (drag) {\n                    // Considering the point of contact with the region while edgescrolling\n                    if (scrollDirection === -1) {\n                      regionHalfTimeWidth = regionLeftHalfTime * _this4.wavesurfer.params.minPxPerSec;\n                      distanceBetweenCursorAndWrapperEdge = x - wrapperRect.left;\n                    } else {\n                      regionHalfTimeWidth = regionRightHalfTime * _this4.wavesurfer.params.minPxPerSec;\n                      distanceBetweenCursorAndWrapperEdge = wrapperRect.right - x;\n                    }\n                  } else {\n                    // Considering minLength while edgescroll\n                    var minLength = _this4.minLength;\n\n                    if (!minLength) {\n                      minLength = 0;\n                    }\n\n                    if (resize === 'start') {\n                      if (time > _this4.end - minLength) {\n                        time = _this4.end - minLength;\n                        adjustment = scrollSpeed * scrollDirection;\n                      }\n\n                      if (time < 0) {\n                        time = 0;\n                      }\n                    } else if (resize === 'end') {\n                      if (time < _this4.start + minLength) {\n                        time = _this4.start + minLength;\n                        adjustment = scrollSpeed * scrollDirection;\n                      }\n\n                      if (time > duration) {\n                        time = duration;\n                      }\n                    }\n                  } // Don't edgescroll if region has reached min or max limit\n\n\n                  var wrapperScrollLeft = _this4.wrapper.scrollLeft;\n\n                  if (scrollDirection === -1) {\n                    if (Math.round(wrapperScrollLeft) === 0) {\n                      return;\n                    }\n\n                    if (Math.round(wrapperScrollLeft - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge) <= 0) {\n                      return;\n                    }\n                  } else {\n                    if (Math.round(wrapperScrollLeft) === maxScroll) {\n                      return;\n                    }\n\n                    if (Math.round(wrapperScrollLeft + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge) >= maxScroll) {\n                      return;\n                    }\n                  } // Update scroll position\n\n\n                  var scrollLeft = wrapperScrollLeft - adjustment + scrollSpeed * scrollDirection;\n\n                  if (scrollDirection === -1) {\n                    var calculatedLeft = Math.max(0 + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge, scrollLeft);\n                    _this4.wrapper.scrollLeft = scrollLeft = calculatedLeft;\n                  } else {\n                    var calculatedRight = Math.min(maxScroll - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge, scrollLeft);\n                    _this4.wrapper.scrollLeft = scrollLeft = calculatedRight;\n                  }\n\n                  var delta = time - startTime;\n                  startTime = time; // Continue dragging or resizing\n\n                  drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize); // Repeat\n\n                  window.requestAnimationFrame(function () {\n                    edgeScroll(event);\n                  });\n                };\n\n                var onDown = function onDown(event) {\n                  var duration = _this4.wavesurfer.getDuration();\n\n                  if (event.touches && event.touches.length > 1) {\n                    return;\n                  }\n\n                  touchId = event.targetTouches ? event.targetTouches[0].identifier : null; // stop the event propagation, if this region is resizable or draggable\n                  // and the event is therefore handled here.\n\n                  if (_this4.drag || _this4.resize) {\n                    event.stopPropagation();\n                  } // Store the selected startTime we begun dragging or resizing\n\n\n                  startTime = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event, true) * duration); // Store the selected point of contact when we begin dragging\n\n                  regionLeftHalfTime = startTime - _this4.start;\n                  regionRightHalfTime = _this4.end - startTime; // Store for scroll calculations\n\n                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;\n                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);\n                  _this4.isResizing = false;\n                  _this4.isDragging = false;\n\n                  if (event.target.tagName.toLowerCase() === 'handle') {\n                    _this4.isResizing = true;\n                    resize = event.target.classList.contains('wavesurfer-handle-start') ? 'start' : 'end';\n                  } else {\n                    _this4.isDragging = true;\n                    drag = true;\n                    resize = false;\n                  }\n                };\n\n                var onUp = function onUp(event) {\n                  if (event.touches && event.touches.length > 1) {\n                    return;\n                  }\n\n                  if (drag || resize) {\n                    _this4.isDragging = false;\n                    _this4.isResizing = false;\n                    drag = false;\n                    scrollDirection = null;\n                    resize = false;\n                  }\n\n                  if (updated) {\n                    updated = false;\n\n                    _this4.util.preventClick();\n\n                    _this4.fireEvent('update-end', event);\n\n                    _this4.wavesurfer.fireEvent('region-update-end', _this4, event);\n                  }\n                };\n\n                var onMove = function onMove(event) {\n                  var duration = _this4.wavesurfer.getDuration();\n\n                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);\n\n                  if (event.touches && event.touches.length > 1) {\n                    return;\n                  }\n\n                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\n                    return;\n                  }\n\n                  if (!drag && !resize) {\n                    return;\n                  }\n\n                  var oldTime = startTime;\n\n                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);\n\n                  if (drag) {\n                    // To maintain relative cursor start point while dragging\n                    var maxEnd = _this4.wavesurfer.getDuration();\n\n                    if (time > maxEnd - regionRightHalfTime) {\n                      time = maxEnd - regionRightHalfTime;\n                    }\n\n                    if (time - regionLeftHalfTime < 0) {\n                      time = regionLeftHalfTime;\n                    }\n                  }\n\n                  if (resize) {\n                    // To maintain relative cursor start point while resizing\n                    // we have to handle for minLength\n                    var minLength = _this4.minLength;\n\n                    if (!minLength) {\n                      minLength = 0;\n                    }\n\n                    if (resize === 'start') {\n                      if (time > _this4.end - minLength) {\n                        time = _this4.end - minLength;\n                      }\n\n                      if (time < 0) {\n                        time = 0;\n                      }\n                    } else if (resize === 'end') {\n                      if (time < _this4.start + minLength) {\n                        time = _this4.start + minLength;\n                      }\n\n                      if (time > duration) {\n                        time = duration;\n                      }\n                    }\n                  }\n\n                  var delta = time - startTime;\n                  startTime = time; // Drag\n\n                  if (_this4.drag && drag) {\n                    updated = updated || !!delta;\n\n                    _this4.onDrag(delta);\n                  } // Resize\n\n\n                  if (_this4.resize && resize) {\n                    updated = updated || !!delta;\n\n                    _this4.onResize(delta, resize);\n                  }\n\n                  if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {\n                    // Triggering edgescroll from within edgeScrollWidth\n                    var x = orientedEvent.clientX; // Check direction\n\n                    if (x < wrapperRect.left + _this4.edgeScrollWidth) {\n                      scrollDirection = -1;\n                    } else if (x > wrapperRect.right - _this4.edgeScrollWidth) {\n                      scrollDirection = 1;\n                    } else {\n                      scrollDirection = null;\n                    }\n\n                    if (scrollDirection) {\n                      edgeScroll(event);\n                    }\n                  }\n                };\n\n                this.element.addEventListener('mousedown', onDown);\n                this.element.addEventListener('touchstart', onDown);\n                document.body.addEventListener('mousemove', onMove);\n                document.body.addEventListener('touchmove', onMove, {\n                  passive: false\n                });\n                document.addEventListener('mouseup', onUp);\n                document.body.addEventListener('touchend', onUp);\n                this.on('remove', function () {\n                  document.removeEventListener('mouseup', onUp);\n                  document.body.removeEventListener('touchend', onUp);\n                  document.body.removeEventListener('mousemove', onMove);\n                  document.body.removeEventListener('touchmove', onMove);\n                });\n                this.wavesurfer.on('destroy', function () {\n                  document.removeEventListener('mouseup', onUp);\n                  document.body.removeEventListener('touchend', onUp);\n                });\n              }\n            }, {\n              key: \"onDrag\",\n              value: function onDrag(delta) {\n                var maxEnd = this.wavesurfer.getDuration();\n\n                if (this.end + delta > maxEnd) {\n                  delta = maxEnd - this.end;\n                }\n\n                if (this.start + delta < 0) {\n                  delta = this.start * -1;\n                }\n\n                this.update({\n                  start: this.start + delta,\n                  end: this.end + delta\n                });\n              }\n              /**\n               * @example\n               * onResize(-5, 'start') // Moves the start point 5 seconds back\n               * onResize(0.5, 'end') // Moves the end point 0.5 seconds forward\n               *\n               * @param {number} delta How much to add or subtract, given in seconds\n               * @param {string} direction 'start 'or 'end'\n               */\n\n            }, {\n              key: \"onResize\",\n              value: function onResize(delta, direction) {\n                var duration = this.wavesurfer.getDuration();\n\n                if (direction === 'start') {\n                  // Check if changing the start by the given delta would result in the region being smaller than minLength\n                  // Ignore cases where we are making the region wider rather than shrinking it\n                  if (delta > 0 && this.end - (this.start + delta) < this.minLength) {\n                    delta = this.end - this.minLength - this.start;\n                  }\n\n                  if (delta < 0 && this.start + delta < 0) {\n                    delta = this.start * -1;\n                  }\n\n                  this.update({\n                    start: Math.min(this.start + delta, this.end),\n                    end: Math.max(this.start + delta, this.end)\n                  });\n                } else {\n                  // Check if changing the end by the given delta would result in the region being smaller than minLength\n                  // Ignore cases where we are making the region wider rather than shrinking it\n                  if (delta < 0 && this.end + delta - this.start < this.minLength) {\n                    delta = this.start + this.minLength - this.end;\n                  }\n\n                  if (delta > 0 && this.end + delta > duration) {\n                    delta = duration - this.end;\n                  }\n\n                  this.update({\n                    start: Math.min(this.end + delta, this.start),\n                    end: Math.max(this.end + delta, this.start)\n                  });\n                }\n              }\n            }, {\n              key: \"updateHandlesResize\",\n              value: function updateHandlesResize(resize) {\n                var cursorStyle;\n\n                if (resize) {\n                  cursorStyle = this.vertical ? 'row-resize' : 'col-resize';\n                } else {\n                  cursorStyle = 'auto';\n                }\n\n                this.handleLeftEl && this.style(this.handleLeftEl, {\n                  cursor: cursorStyle\n                });\n                this.handleRightEl && this.style(this.handleRightEl, {\n                  cursor: cursorStyle\n                });\n              }\n            }]);\n\n            return Region;\n          }();\n\n          exports.Region = Region;\n          /***/\n        }\n        /******/\n\n      };\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        var cachedModule = __webpack_module_cache__[moduleId];\n        /******/\n\n        if (cachedModule !== undefined) {\n          /******/\n          return cachedModule.exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n\n          /******/\n          // no module.loaded needed\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /******/\n      // startup\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n      // This entry module is referenced by other modules so it can't be inlined\n\n      /******/\n\n\n      var __webpack_exports__ = __webpack_require__(\"./src/plugin/regions/index.js\");\n      /******/\n\n      /******/\n\n\n      return __webpack_exports__;\n      /******/\n    }()\n  );\n});","map":null,"metadata":{},"sourceType":"script"}