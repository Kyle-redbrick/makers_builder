{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"babylonjs\")) : \"function\" == typeof define && define.amd ? define(\"babylonjs-loaders\", [\"babylonjs\"], t) : \"object\" == typeof exports ? exports[\"babylonjs-loaders\"] = t(require(\"babylonjs\")) : e.LOADERS = t(e.BABYLON);\n}(\"undefined\" != typeof self ? self : \"undefined\" != typeof global ? global : this, function (e) {\n  return function (e) {\n    var t = {};\n\n    function n(r) {\n      if (t[r]) return t[r].exports;\n      var o = t[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, r) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: r\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var r = Object.create(null);\n      if (n.r(r), Object.defineProperty(r, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var o in e) {\n        n.d(r, o, function (t) {\n          return e[t];\n        }.bind(null, o));\n      }\n      return r;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 20);\n  }([function (t, n) {\n    t.exports = e;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.d(t, \"a\", function () {\n      return a;\n    }), n.d(t, \"b\", function () {\n      return i;\n    });\n\n    var r = n(0),\n        o = n(2),\n        a = function () {\n      function e() {}\n\n      return e.Get = function (e, t, n) {\n        if (!t || null == n || !t[n]) throw new Error(e + \": Failed to find index (\" + n + \")\");\n        return t[n];\n      }, e.Assign = function (e) {\n        if (e) for (var t = 0; t < e.length; t++) {\n          e[t].index = t;\n        }\n      }, e;\n    }(),\n        i = function () {\n      function e(e) {\n        this._completePromises = new Array(), this._forAssetContainer = !1, this._babylonLights = [], this._disableInstancedMesh = 0, this._disposed = !1, this._state = null, this._extensions = new Array(), this._defaultBabylonMaterialData = {}, this._parent = e;\n      }\n\n      return e.RegisterExtension = function (t, n) {\n        e.UnregisterExtension(t) && r.Logger.Warn(\"Extension with the name '\" + t + \"' already exists\"), e._RegisteredExtensions[t] = {\n          factory: n\n        };\n      }, e.UnregisterExtension = function (t) {\n        return !!e._RegisteredExtensions[t] && (delete e._RegisteredExtensions[t], !0);\n      }, Object.defineProperty(e.prototype, \"state\", {\n        get: function get() {\n          return this._state;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"gltf\", {\n        get: function get() {\n          return this._gltf;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"bin\", {\n        get: function get() {\n          return this._bin;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"parent\", {\n        get: function get() {\n          return this._parent;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"babylonScene\", {\n        get: function get() {\n          return this._babylonScene;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"rootBabylonMesh\", {\n        get: function get() {\n          return this._rootBabylonMesh;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), e.prototype.dispose = function () {\n        if (!this._disposed) {\n          for (var e in this._disposed = !0, this._completePromises.length = 0, this._extensions) {\n            var t = this._extensions[e];\n            t.dispose && t.dispose(), delete this._extensions[e];\n          }\n\n          this._gltf = null, this._babylonScene = null, this._rootBabylonMesh = null, this._parent.dispose();\n        }\n      }, e.prototype.importMeshAsync = function (e, t, n, r, o, a, i) {\n        var s = this;\n        return Promise.resolve().then(function () {\n          s._babylonScene = t, s._rootUrl = o, s._fileName = i || \"scene\", s._forAssetContainer = n, s._loadData(r);\n          var a = null;\n\n          if (e) {\n            var l = {};\n            if (s._gltf.nodes) for (var u = 0, c = s._gltf.nodes; u < c.length; u++) {\n              var d = c[u];\n              d.name && (l[d.name] = d.index);\n            }\n            a = (e instanceof Array ? e : [e]).map(function (e) {\n              var t = l[e];\n              if (void 0 === t) throw new Error(\"Failed to find node '\" + e + \"'\");\n              return t;\n            });\n          }\n\n          return s._loadAsync(a, function () {\n            return {\n              meshes: s._getMeshes(),\n              particleSystems: [],\n              skeletons: s._getSkeletons(),\n              animationGroups: s._getAnimationGroups(),\n              lights: s._babylonLights,\n              transformNodes: s._getTransformNodes(),\n              geometries: s._getGeometries()\n            };\n          });\n        });\n      }, e.prototype.loadAsync = function (e, t, n, r, o) {\n        var a = this;\n        return Promise.resolve().then(function () {\n          return a._babylonScene = e, a._rootUrl = n, a._fileName = o || \"scene\", a._loadData(t), a._loadAsync(null, function () {});\n        });\n      }, e.prototype._loadAsync = function (e, t) {\n        var n = this;\n        return Promise.resolve().then(function () {\n          n._uniqueRootUrl = -1 === n._rootUrl.indexOf(\"file:\") && n._fileName ? n._rootUrl : \"\" + n._rootUrl + Date.now() + \"/\", n._loadExtensions(), n._checkExtensions();\n          var i = o.GLTFLoaderState[o.GLTFLoaderState.LOADING] + \" => \" + o.GLTFLoaderState[o.GLTFLoaderState.READY],\n              s = o.GLTFLoaderState[o.GLTFLoaderState.LOADING] + \" => \" + o.GLTFLoaderState[o.GLTFLoaderState.COMPLETE];\n          n._parent._startPerformanceCounter(i), n._parent._startPerformanceCounter(s), n._setState(o.GLTFLoaderState.LOADING), n._extensionsOnLoading();\n          var l = new Array(),\n              u = n._babylonScene.blockMaterialDirtyMechanism;\n          if (n._babylonScene.blockMaterialDirtyMechanism = !0, e) l.push(n.loadSceneAsync(\"/nodes\", {\n            nodes: e,\n            index: -1\n          }));else if (null != n._gltf.scene || n._gltf.scenes && n._gltf.scenes[0]) {\n            var c = a.Get(\"/scene\", n._gltf.scenes, n._gltf.scene || 0);\n            l.push(n.loadSceneAsync(\"/scenes/\" + c.index, c));\n          }\n          if (n.parent.loadAllMaterials && n._gltf.materials) for (var d = 0; d < n._gltf.materials.length; ++d) {\n            var f = n._gltf.materials[d],\n                h = \"/materials/\" + d,\n                p = r.Material.TriangleFillMode;\n            l.push(n._loadMaterialAsync(h, f, null, p, function (e) {}));\n          }\n          n._babylonScene.blockMaterialDirtyMechanism = u, n._parent.compileMaterials && l.push(n._compileMaterialsAsync()), n._parent.compileShadowGenerators && l.push(n._compileShadowGeneratorsAsync());\n\n          var _ = Promise.all(l).then(function () {\n            return n._rootBabylonMesh && n._rootBabylonMesh.setEnabled(!0), n._extensionsOnReady(), n._setState(o.GLTFLoaderState.READY), n._startAnimations(), t();\n          });\n\n          return _.then(function () {\n            n._parent._endPerformanceCounter(i), r.Tools.SetImmediate(function () {\n              n._disposed || Promise.all(n._completePromises).then(function () {\n                n._parent._endPerformanceCounter(s), n._setState(o.GLTFLoaderState.COMPLETE), n._parent.onCompleteObservable.notifyObservers(void 0), n._parent.onCompleteObservable.clear(), n.dispose();\n              }, function (e) {\n                n._parent.onErrorObservable.notifyObservers(e), n._parent.onErrorObservable.clear(), n.dispose();\n              });\n            });\n          }), _;\n        }).catch(function (e) {\n          throw n._disposed || (n._parent.onErrorObservable.notifyObservers(e), n._parent.onErrorObservable.clear(), n.dispose()), e;\n        });\n      }, e.prototype._loadData = function (e) {\n        if (this._gltf = e.json, this._setupData(), e.bin) {\n          var t = this._gltf.buffers;\n\n          if (t && t[0] && !t[0].uri) {\n            var n = t[0];\n            (n.byteLength < e.bin.byteLength - 3 || n.byteLength > e.bin.byteLength) && r.Logger.Warn(\"Binary buffer length (\" + n.byteLength + \") from JSON does not match chunk length (\" + e.bin.byteLength + \")\"), this._bin = e.bin;\n          } else r.Logger.Warn(\"Unexpected BIN chunk\");\n        }\n      }, e.prototype._setupData = function () {\n        if (a.Assign(this._gltf.accessors), a.Assign(this._gltf.animations), a.Assign(this._gltf.buffers), a.Assign(this._gltf.bufferViews), a.Assign(this._gltf.cameras), a.Assign(this._gltf.images), a.Assign(this._gltf.materials), a.Assign(this._gltf.meshes), a.Assign(this._gltf.nodes), a.Assign(this._gltf.samplers), a.Assign(this._gltf.scenes), a.Assign(this._gltf.skins), a.Assign(this._gltf.textures), this._gltf.nodes) {\n          for (var e = {}, t = 0, n = this._gltf.nodes; t < n.length; t++) {\n            if ((u = n[t]).children) for (var r = 0, o = u.children; r < o.length; r++) {\n              e[o[r]] = u.index;\n            }\n          }\n\n          for (var i = this._createRootNode(), s = 0, l = this._gltf.nodes; s < l.length; s++) {\n            var u,\n                c = e[(u = l[s]).index];\n            u.parent = void 0 === c ? i : this._gltf.nodes[c];\n          }\n        }\n      }, e.prototype._loadExtensions = function () {\n        for (var t in e._RegisteredExtensions) {\n          var n = e._RegisteredExtensions[t].factory(this);\n\n          n.name !== t && r.Logger.Warn(\"The name of the glTF loader extension instance does not match the registered name: \" + n.name + \" !== \" + t), this._extensions.push(n), this._parent.onExtensionLoadedObservable.notifyObservers(n);\n        }\n\n        this._extensions.sort(function (e, t) {\n          return (e.order || Number.MAX_VALUE) - (t.order || Number.MAX_VALUE);\n        }), this._parent.onExtensionLoadedObservable.clear();\n      }, e.prototype._checkExtensions = function () {\n        if (this._gltf.extensionsRequired) for (var e = function e(_e) {\n          if (!t._extensions.some(function (t) {\n            return t.name === _e && t.enabled;\n          })) throw new Error(\"Require extension \" + _e + \" is not available\");\n        }, t = this, n = 0, r = this._gltf.extensionsRequired; n < r.length; n++) {\n          e(r[n]);\n        }\n      }, e.prototype._setState = function (e) {\n        this._state = e, this.log(o.GLTFLoaderState[this._state]);\n      }, e.prototype._createRootNode = function () {\n        this._babylonScene._blockEntityCollection = this._forAssetContainer, this._rootBabylonMesh = new r.Mesh(\"__root__\", this._babylonScene), this._babylonScene._blockEntityCollection = !1, this._rootBabylonMesh.setEnabled(!1);\n        var t = {\n          _babylonTransformNode: this._rootBabylonMesh,\n          index: -1\n        };\n\n        switch (this._parent.coordinateSystemMode) {\n          case o.GLTFLoaderCoordinateSystemMode.AUTO:\n            this._babylonScene.useRightHandedSystem || (t.rotation = [0, 1, 0, 0], t.scale = [1, 1, -1], e._LoadTransform(t, this._rootBabylonMesh));\n            break;\n\n          case o.GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED:\n            this._babylonScene.useRightHandedSystem = !0;\n            break;\n\n          default:\n            throw new Error(\"Invalid coordinate system mode (\" + this._parent.coordinateSystemMode + \")\");\n        }\n\n        return this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh), t;\n      }, e.prototype.loadSceneAsync = function (e, t) {\n        var n = this,\n            r = this._extensionsLoadSceneAsync(e, t);\n\n        if (r) return r;\n        var o = new Array();\n        if (this.logOpen(e + \" \" + (t.name || \"\")), t.nodes) for (var i = 0, s = t.nodes; i < s.length; i++) {\n          var l = s[i],\n              u = a.Get(e + \"/nodes/\" + l, this._gltf.nodes, l);\n          o.push(this.loadNodeAsync(\"/nodes/\" + u.index, u, function (e) {\n            e.parent = n._rootBabylonMesh;\n          }));\n        }\n        if (this._gltf.nodes) for (var c = 0, d = this._gltf.nodes; c < d.length; c++) {\n          if ((u = d[c])._babylonTransformNode && u._babylonBones) for (var f = 0, h = u._babylonBones; f < h.length; f++) {\n            h[f].linkTransformNode(u._babylonTransformNode);\n          }\n        }\n        return o.push(this._loadAnimationsAsync()), this.logClose(), Promise.all(o).then(function () {});\n      }, e.prototype._forEachPrimitive = function (e, t) {\n        if (e._primitiveBabylonMeshes) for (var n = 0, r = e._primitiveBabylonMeshes; n < r.length; n++) {\n          t(r[n]);\n        }\n      }, e.prototype._getGeometries = function () {\n        var e = new Array(),\n            t = this._gltf.nodes;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n\n          this._forEachPrimitive(o, function (t) {\n            var n = t.geometry;\n            n && -1 === e.indexOf(n) && e.push(n);\n          });\n        }\n        return e;\n      }, e.prototype._getMeshes = function () {\n        var e = new Array();\n        e.push(this._rootBabylonMesh);\n        var t = this._gltf.nodes;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n\n          this._forEachPrimitive(o, function (t) {\n            e.push(t);\n          });\n        }\n        return e;\n      }, e.prototype._getTransformNodes = function () {\n        var e = new Array(),\n            t = this._gltf.nodes;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n          o._babylonTransformNode && \"TransformNode\" === o._babylonTransformNode.getClassName() && e.push(o._babylonTransformNode);\n        }\n        return e;\n      }, e.prototype._getSkeletons = function () {\n        var e = new Array(),\n            t = this._gltf.skins;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n          o._data && e.push(o._data.babylonSkeleton);\n        }\n        return e;\n      }, e.prototype._getAnimationGroups = function () {\n        var e = new Array(),\n            t = this._gltf.animations;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n          o._babylonAnimationGroup && e.push(o._babylonAnimationGroup);\n        }\n        return e;\n      }, e.prototype._startAnimations = function () {\n        switch (this._parent.animationStartMode) {\n          case o.GLTFLoaderAnimationStartMode.NONE:\n            break;\n\n          case o.GLTFLoaderAnimationStartMode.FIRST:\n            0 !== (e = this._getAnimationGroups()).length && e[0].start(!0);\n            break;\n\n          case o.GLTFLoaderAnimationStartMode.ALL:\n            for (var e, t = 0, n = e = this._getAnimationGroups(); t < n.length; t++) {\n              n[t].start(!0);\n            }\n\n            break;\n\n          default:\n            return void r.Logger.Error(\"Invalid animation start mode (\" + this._parent.animationStartMode + \")\");\n        }\n      }, e.prototype.loadNodeAsync = function (t, n, o) {\n        var i = this;\n        void 0 === o && (o = function o() {});\n\n        var s = this._extensionsLoadNodeAsync(t, n, o);\n\n        if (s) return s;\n        if (n._babylonTransformNode) throw new Error(t + \": Invalid recursive node hierarchy\");\n        var l = new Array();\n        this.logOpen(t + \" \" + (n.name || \"\"));\n\n        var u = function u(r) {\n          if (e.AddPointerMetadata(r, t), e._LoadTransform(n, r), null != n.camera) {\n            var s = a.Get(t + \"/camera\", i._gltf.cameras, n.camera);\n            l.push(i.loadCameraAsync(\"/cameras/\" + s.index, s, function (e) {\n              e.parent = r;\n            }));\n          }\n\n          if (n.children) for (var u = 0, c = n.children; u < c.length; u++) {\n            var d = c[u],\n                f = a.Get(t + \"/children/\" + d, i._gltf.nodes, d);\n            l.push(i.loadNodeAsync(\"/nodes/\" + f.index, f, function (e) {\n              e.parent = r;\n            }));\n          }\n          o(r);\n        };\n\n        if (null == n.mesh) {\n          var c = n.name || \"node\" + n.index;\n          this._babylonScene._blockEntityCollection = this._forAssetContainer, n._babylonTransformNode = new r.TransformNode(c, this._babylonScene), this._babylonScene._blockEntityCollection = !1, u(n._babylonTransformNode);\n        } else {\n          var d = a.Get(t + \"/mesh\", this._gltf.meshes, n.mesh);\n          l.push(this._loadMeshAsync(\"/meshes/\" + d.index, n, d, u));\n        }\n\n        return this.logClose(), Promise.all(l).then(function () {\n          return i._forEachPrimitive(n, function (e) {\n            e.geometry && e.geometry.useBoundingInfoFromGeometry ? e._updateBoundingInfo() : e.refreshBoundingInfo(!0);\n          }), n._babylonTransformNode;\n        });\n      }, e.prototype._loadMeshAsync = function (e, t, n, o) {\n        var i = n.primitives;\n        if (!i || !i.length) throw new Error(e + \": Primitives are missing\");\n        null == i[0].index && a.Assign(i);\n        var s = new Array();\n        this.logOpen(e + \" \" + (n.name || \"\"));\n        var l = t.name || \"node\" + t.index;\n\n        if (1 === i.length) {\n          var u = n.primitives[0];\n          s.push(this._loadMeshPrimitiveAsync(e + \"/primitives/\" + u.index, l, t, n, u, function (e) {\n            t._babylonTransformNode = e, t._primitiveBabylonMeshes = [e];\n          }));\n        } else {\n          this._babylonScene._blockEntityCollection = this._forAssetContainer, t._babylonTransformNode = new r.TransformNode(l, this._babylonScene), this._babylonScene._blockEntityCollection = !1, t._primitiveBabylonMeshes = [];\n\n          for (var c = 0, d = i; c < d.length; c++) {\n            u = d[c];\n            s.push(this._loadMeshPrimitiveAsync(e + \"/primitives/\" + u.index, l + \"_primitive\" + u.index, t, n, u, function (e) {\n              e.parent = t._babylonTransformNode, t._primitiveBabylonMeshes.push(e);\n            }));\n          }\n        }\n\n        if (null != t.skin) {\n          var f = a.Get(e + \"/skin\", this._gltf.skins, t.skin);\n          s.push(this._loadSkinAsync(\"/skins/\" + f.index, t, f));\n        }\n\n        return o(t._babylonTransformNode), this.logClose(), Promise.all(s).then(function () {\n          return t._babylonTransformNode;\n        });\n      }, e.prototype._loadMeshPrimitiveAsync = function (t, n, o, i, s, l) {\n        var u = this,\n            c = this._extensionsLoadMeshPrimitiveAsync(t, n, o, i, s, l);\n\n        if (c) return c;\n        this.logOpen(\"\" + t);\n        var d,\n            f,\n            h = 0 === this._disableInstancedMesh && this._parent.createInstances && null == o.skin && !i.primitives[0].targets;\n        if (h && s._instanceData) d = s._instanceData.babylonSourceMesh.createInstance(n), f = s._instanceData.promise;else {\n          var p = new Array();\n          this._babylonScene._blockEntityCollection = this._forAssetContainer;\n\n          var _ = new r.Mesh(n, this._babylonScene);\n\n          this._babylonScene._blockEntityCollection = !1, _.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? r.Material.CounterClockWiseSideOrientation : r.Material.ClockWiseSideOrientation, this._createMorphTargets(t, o, i, s, _), p.push(this._loadVertexDataAsync(t, s, _).then(function (e) {\n            return u._loadMorphTargetsAsync(t, s, _, e).then(function () {\n              u._babylonScene._blockEntityCollection = u._forAssetContainer, e.applyToMesh(_), u._babylonScene._blockEntityCollection = !1;\n            });\n          }));\n\n          var m = e._GetDrawMode(t, s.mode);\n\n          if (null == s.material) {\n            var y = this._defaultBabylonMaterialData[m];\n            y || (y = this._createDefaultMaterial(\"__GLTFLoader._default\", m), this._parent.onMaterialLoadedObservable.notifyObservers(y), this._defaultBabylonMaterialData[m] = y), _.material = y;\n          } else {\n            var b = a.Get(t + \"/material\", this._gltf.materials, s.material);\n            p.push(this._loadMaterialAsync(\"/materials/\" + b.index, b, _, m, function (e) {\n              _.material = e;\n            }));\n          }\n\n          f = Promise.all(p), h && (s._instanceData = {\n            babylonSourceMesh: _,\n            promise: f\n          }), d = _;\n        }\n        return e.AddPointerMetadata(d, t), this._parent.onMeshLoadedObservable.notifyObservers(d), l(d), this.logClose(), f.then(function () {\n          return d;\n        });\n      }, e.prototype._loadVertexDataAsync = function (e, t, n) {\n        var o = this,\n            i = this._extensionsLoadVertexDataAsync(e, t, n);\n\n        if (i) return i;\n        var s = t.attributes;\n        if (!s) throw new Error(e + \": Attributes are missing\");\n        var l = new Array(),\n            u = new r.Geometry(n.name, this._babylonScene);\n        if (null == t.indices) n.isUnIndexed = !0;else {\n          var c = a.Get(e + \"/indices\", this._gltf.accessors, t.indices);\n          l.push(this._loadIndicesAccessorAsync(\"/accessors/\" + c.index, c).then(function (e) {\n            u.setIndices(e);\n          }));\n        }\n\n        var d = function d(t, i, c) {\n          if (null != s[t]) {\n            n._delayInfo = n._delayInfo || [], -1 === n._delayInfo.indexOf(i) && n._delayInfo.push(i);\n            var d = a.Get(e + \"/attributes/\" + t, o._gltf.accessors, s[t]);\n            l.push(o._loadVertexAccessorAsync(\"/accessors/\" + d.index, d, i).then(function (e) {\n              if (e.getKind() === r.VertexBuffer.PositionKind && !o.parent.alwaysComputeBoundingBox && !n.skeleton) {\n                var t = d.min,\n                    a = d.max;\n\n                if (void 0 !== t && void 0 !== a) {\n                  var i = r.TmpVectors.Vector3[0],\n                      s = r.TmpVectors.Vector3[1];\n                  i.copyFromFloats.apply(i, t), s.copyFromFloats.apply(s, a), u._boundingInfo = new r.BoundingInfo(i, s), u.useBoundingInfoFromGeometry = !0;\n                }\n              }\n\n              u.setVerticesBuffer(e, d.count);\n            })), i == r.VertexBuffer.MatricesIndicesExtraKind && (n.numBoneInfluencers = 8), c && c(d);\n          }\n        };\n\n        return d(\"POSITION\", r.VertexBuffer.PositionKind), d(\"NORMAL\", r.VertexBuffer.NormalKind), d(\"TANGENT\", r.VertexBuffer.TangentKind), d(\"TEXCOORD_0\", r.VertexBuffer.UVKind), d(\"TEXCOORD_1\", r.VertexBuffer.UV2Kind), d(\"JOINTS_0\", r.VertexBuffer.MatricesIndicesKind), d(\"WEIGHTS_0\", r.VertexBuffer.MatricesWeightsKind), d(\"JOINTS_1\", r.VertexBuffer.MatricesIndicesExtraKind), d(\"WEIGHTS_1\", r.VertexBuffer.MatricesWeightsExtraKind), d(\"COLOR_0\", r.VertexBuffer.ColorKind, function (e) {\n          \"VEC4\" === e.type && (n.hasVertexAlpha = !0);\n        }), Promise.all(l).then(function () {\n          return u;\n        });\n      }, e.prototype._createMorphTargets = function (e, t, n, o, a) {\n        if (o.targets) {\n          if (null == t._numMorphTargets) t._numMorphTargets = o.targets.length;else if (o.targets.length !== t._numMorphTargets) throw new Error(e + \": Primitives do not have the same number of targets\");\n          var i = n.extras ? n.extras.targetNames : null;\n          a.morphTargetManager = new r.MorphTargetManager(a.getScene());\n\n          for (var s = 0; s < o.targets.length; s++) {\n            var l = t.weights ? t.weights[s] : n.weights ? n.weights[s] : 0,\n                u = i ? i[s] : \"morphTarget\" + s;\n            a.morphTargetManager.addTarget(new r.MorphTarget(u, l, a.getScene()));\n          }\n        }\n      }, e.prototype._loadMorphTargetsAsync = function (e, t, n, r) {\n        if (!t.targets) return Promise.resolve();\n\n        for (var o = new Array(), a = n.morphTargetManager, i = 0; i < a.numTargets; i++) {\n          var s = a.getTarget(i);\n          o.push(this._loadMorphTargetVertexDataAsync(e + \"/targets/\" + i, r, t.targets[i], s));\n        }\n\n        return Promise.all(o).then(function () {});\n      }, e.prototype._loadMorphTargetVertexDataAsync = function (e, t, n, o) {\n        var i = this,\n            s = new Array(),\n            l = function l(r, o, _l) {\n          if (null != n[r]) {\n            var u = t.getVertexBuffer(o);\n\n            if (u) {\n              var c = a.Get(e + \"/\" + r, i._gltf.accessors, n[r]);\n              s.push(i._loadFloatAccessorAsync(\"/accessors/\" + c.index, c).then(function (e) {\n                _l(u, e);\n              }));\n            }\n          }\n        };\n\n        return l(\"POSITION\", r.VertexBuffer.PositionKind, function (e, t) {\n          var n = new Float32Array(t.length);\n          e.forEach(t.length, function (e, r) {\n            n[r] = t[r] + e;\n          }), o.setPositions(n);\n        }), l(\"NORMAL\", r.VertexBuffer.NormalKind, function (e, t) {\n          var n = new Float32Array(t.length);\n          e.forEach(n.length, function (e, r) {\n            n[r] = t[r] + e;\n          }), o.setNormals(n);\n        }), l(\"TANGENT\", r.VertexBuffer.TangentKind, function (e, t) {\n          var n = new Float32Array(t.length / 3 * 4),\n              r = 0;\n          e.forEach(t.length / 3 * 4, function (e, o) {\n            (o + 1) % 4 != 0 && (n[r] = t[r] + e, r++);\n          }), o.setTangents(n);\n        }), Promise.all(s).then(function () {});\n      }, e._LoadTransform = function (e, t) {\n        if (null == e.skin) {\n          var n = r.Vector3.Zero(),\n              o = r.Quaternion.Identity(),\n              a = r.Vector3.One();\n          if (e.matrix) r.Matrix.FromArray(e.matrix).decompose(a, o, n);else e.translation && (n = r.Vector3.FromArray(e.translation)), e.rotation && (o = r.Quaternion.FromArray(e.rotation)), e.scale && (a = r.Vector3.FromArray(e.scale));\n          t.position = n, t.rotationQuaternion = o, t.scaling = a;\n        }\n      }, e.prototype._loadSkinAsync = function (e, t, n) {\n        var o = this,\n            a = this._extensionsLoadSkinAsync(e, t, n);\n\n        if (a) return a;\n\n        var i = function i(e) {\n          o._forEachPrimitive(t, function (t) {\n            t.skeleton = e;\n          });\n        };\n\n        if (n._data) return i(n._data.babylonSkeleton), n._data.promise;\n        var s = \"skeleton\" + n.index;\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        var l = new r.Skeleton(n.name || s, s, this._babylonScene);\n        this._babylonScene._blockEntityCollection = !1, l.overrideMesh = this._rootBabylonMesh, this._loadBones(e, n, l), i(l);\n\n        var u = this._loadSkinInverseBindMatricesDataAsync(e, n).then(function (e) {\n          o._updateBoneMatrices(l, e);\n        });\n\n        return n._data = {\n          babylonSkeleton: l,\n          promise: u\n        }, u;\n      }, e.prototype._loadBones = function (e, t, n) {\n        for (var r = {}, o = 0, i = t.joints; o < i.length; o++) {\n          var s = i[o],\n              l = a.Get(e + \"/joints/\" + s, this._gltf.nodes, s);\n\n          this._loadBone(l, t, n, r);\n        }\n      }, e.prototype._loadBone = function (e, t, n, o) {\n        var a = o[e.index];\n        if (a) return a;\n        var i = null;\n        e.parent && e.parent._babylonTransformNode !== this._rootBabylonMesh && (i = this._loadBone(e.parent, t, n, o));\n        var s = t.joints.indexOf(e.index);\n        return a = new r.Bone(e.name || \"joint\" + e.index, n, i, this._getNodeMatrix(e), null, null, s), o[e.index] = a, e._babylonBones = e._babylonBones || [], e._babylonBones.push(a), a;\n      }, e.prototype._loadSkinInverseBindMatricesDataAsync = function (e, t) {\n        if (null == t.inverseBindMatrices) return Promise.resolve(null);\n        var n = a.Get(e + \"/inverseBindMatrices\", this._gltf.accessors, t.inverseBindMatrices);\n        return this._loadFloatAccessorAsync(\"/accessors/\" + n.index, n);\n      }, e.prototype._updateBoneMatrices = function (e, t) {\n        for (var n = 0, o = e.bones; n < o.length; n++) {\n          var a = o[n],\n              i = r.Matrix.Identity(),\n              s = a._index;\n          t && -1 !== s && (r.Matrix.FromArrayToRef(t, 16 * s, i), i.invertToRef(i));\n          var l = a.getParent();\n          l && i.multiplyToRef(l.getInvertedAbsoluteTransform(), i), a.setBindPose(i), a.updateMatrix(i, !1, !1), a._updateDifferenceMatrix(void 0, !1);\n        }\n      }, e.prototype._getNodeMatrix = function (e) {\n        return e.matrix ? r.Matrix.FromArray(e.matrix) : r.Matrix.Compose(e.scale ? r.Vector3.FromArray(e.scale) : r.Vector3.One(), e.rotation ? r.Quaternion.FromArray(e.rotation) : r.Quaternion.Identity(), e.translation ? r.Vector3.FromArray(e.translation) : r.Vector3.Zero());\n      }, e.prototype.loadCameraAsync = function (t, n, o) {\n        void 0 === o && (o = function o() {});\n\n        var a = this._extensionsLoadCameraAsync(t, n, o);\n\n        if (a) return a;\n        var i = new Array();\n        this.logOpen(t + \" \" + (n.name || \"\")), this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        var s = new r.FreeCamera(n.name || \"camera\" + n.index, r.Vector3.Zero(), this._babylonScene, !1);\n\n        switch (this._babylonScene._blockEntityCollection = !1, s.ignoreParentScaling = !0, s.rotation = new r.Vector3(0, Math.PI, 0), n.type) {\n          case \"perspective\":\n            var l = n.perspective;\n            if (!l) throw new Error(t + \": Camera perspective properties are missing\");\n            s.fov = l.yfov, s.minZ = l.znear, s.maxZ = l.zfar || Number.MAX_VALUE;\n            break;\n\n          case \"orthographic\":\n            if (!n.orthographic) throw new Error(t + \": Camera orthographic properties are missing\");\n            s.mode = r.Camera.ORTHOGRAPHIC_CAMERA, s.orthoLeft = -n.orthographic.xmag, s.orthoRight = n.orthographic.xmag, s.orthoBottom = -n.orthographic.ymag, s.orthoTop = n.orthographic.ymag, s.minZ = n.orthographic.znear, s.maxZ = n.orthographic.zfar;\n            break;\n\n          default:\n            throw new Error(t + \": Invalid camera type (\" + n.type + \")\");\n        }\n\n        return e.AddPointerMetadata(s, t), this._parent.onCameraLoadedObservable.notifyObservers(s), o(s), this.logClose(), Promise.all(i).then(function () {\n          return s;\n        });\n      }, e.prototype._loadAnimationsAsync = function () {\n        var e = this._gltf.animations;\n        if (!e) return Promise.resolve();\n\n        for (var t = new Array(), n = 0; n < e.length; n++) {\n          var r = e[n];\n          t.push(this.loadAnimationAsync(\"/animations/\" + r.index, r));\n        }\n\n        return Promise.all(t).then(function () {});\n      }, e.prototype.loadAnimationAsync = function (e, t) {\n        var n = this._extensionsLoadAnimationAsync(e, t);\n\n        if (n) return n;\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        var o = new r.AnimationGroup(t.name || \"animation\" + t.index, this._babylonScene);\n        this._babylonScene._blockEntityCollection = !1, t._babylonAnimationGroup = o;\n        var i = new Array();\n        a.Assign(t.channels), a.Assign(t.samplers);\n\n        for (var s = 0, l = t.channels; s < l.length; s++) {\n          var u = l[s];\n          i.push(this._loadAnimationChannelAsync(e + \"/channels/\" + u.index, e, t, u, o));\n        }\n\n        return Promise.all(i).then(function () {\n          return o.normalize(0), o;\n        });\n      }, e.prototype._loadAnimationChannelAsync = function (e, t, n, o, i, s) {\n        var l = this;\n        if (void 0 === s && (s = null), null == o.target.node) return Promise.resolve();\n        var u = a.Get(e + \"/target/node\", this._gltf.nodes, o.target.node);\n        if (\"weights\" === o.target.path && !u._numMorphTargets || \"weights\" !== o.target.path && !u._babylonTransformNode) return Promise.resolve();\n        var c = a.Get(e + \"/sampler\", n.samplers, o.sampler);\n        return this._loadAnimationSamplerAsync(t + \"/samplers/\" + o.sampler, c).then(function (t) {\n          var n, a;\n\n          switch (o.target.path) {\n            case \"translation\":\n              n = \"position\", a = r.Animation.ANIMATIONTYPE_VECTOR3;\n              break;\n\n            case \"rotation\":\n              n = \"rotationQuaternion\", a = r.Animation.ANIMATIONTYPE_QUATERNION;\n              break;\n\n            case \"scale\":\n              n = \"scaling\", a = r.Animation.ANIMATIONTYPE_VECTOR3;\n              break;\n\n            case \"weights\":\n              n = \"influence\", a = r.Animation.ANIMATIONTYPE_FLOAT;\n              break;\n\n            default:\n              throw new Error(e + \"/target/path: Invalid value (\" + o.target.path + \")\");\n          }\n\n          var c,\n              d,\n              f = 0;\n\n          switch (n) {\n            case \"position\":\n              c = function c() {\n                var e = r.Vector3.FromArray(t.output, f);\n                return f += 3, e;\n              };\n\n              break;\n\n            case \"rotationQuaternion\":\n              c = function c() {\n                var e = r.Quaternion.FromArray(t.output, f);\n                return f += 4, e;\n              };\n\n              break;\n\n            case \"scaling\":\n              c = function c() {\n                var e = r.Vector3.FromArray(t.output, f);\n                return f += 3, e;\n              };\n\n              break;\n\n            case \"influence\":\n              c = function c() {\n                for (var e = new Array(u._numMorphTargets), n = 0; n < u._numMorphTargets; n++) {\n                  e[n] = t.output[f++];\n                }\n\n                return e;\n              };\n\n          }\n\n          switch (t.interpolation) {\n            case \"STEP\":\n              d = function d(e) {\n                return {\n                  frame: t.input[e],\n                  value: c(),\n                  interpolation: r.AnimationKeyInterpolation.STEP\n                };\n              };\n\n              break;\n\n            case \"LINEAR\":\n              d = function d(e) {\n                return {\n                  frame: t.input[e],\n                  value: c()\n                };\n              };\n\n              break;\n\n            case \"CUBICSPLINE\":\n              d = function d(e) {\n                return {\n                  frame: t.input[e],\n                  inTangent: c(),\n                  value: c(),\n                  outTangent: c()\n                };\n              };\n\n          }\n\n          for (var h = new Array(t.input.length), p = 0; p < t.input.length; p++) {\n            h[p] = d(p);\n          }\n\n          if (\"influence\" === n) for (var _ = function _(e) {\n            var t = i.name + \"_channel\" + i.targetedAnimations.length,\n                o = new r.Animation(t, n, 1, a);\n            o.setKeys(h.map(function (t) {\n              return {\n                frame: t.frame,\n                inTangent: t.inTangent ? t.inTangent[e] : void 0,\n                value: t.value[e],\n                outTangent: t.outTangent ? t.outTangent[e] : void 0\n              };\n            })), l._forEachPrimitive(u, function (t) {\n              var n = t.morphTargetManager.getTarget(e),\n                  r = o.clone();\n              n.animations.push(r), i.addTargetedAnimation(r, n);\n            });\n          }, m = 0; m < u._numMorphTargets; m++) {\n            _(m);\n          } else {\n            var y = i.name + \"_channel\" + i.targetedAnimations.length,\n                b = new r.Animation(y, n, 1, a);\n            b.setKeys(h), null != s && null != s.animations ? (s.animations.push(b), i.addTargetedAnimation(b, s)) : (u._babylonTransformNode.animations.push(b), i.addTargetedAnimation(b, u._babylonTransformNode));\n          }\n        });\n      }, e.prototype._loadAnimationSamplerAsync = function (e, t) {\n        if (t._data) return t._data;\n        var n = t.interpolation || \"LINEAR\";\n\n        switch (n) {\n          case \"STEP\":\n          case \"LINEAR\":\n          case \"CUBICSPLINE\":\n            break;\n\n          default:\n            throw new Error(e + \"/interpolation: Invalid value (\" + t.interpolation + \")\");\n        }\n\n        var r = a.Get(e + \"/input\", this._gltf.accessors, t.input),\n            o = a.Get(e + \"/output\", this._gltf.accessors, t.output);\n        return t._data = Promise.all([this._loadFloatAccessorAsync(\"/accessors/\" + r.index, r), this._loadFloatAccessorAsync(\"/accessors/\" + o.index, o)]).then(function (e) {\n          var t = e[0],\n              r = e[1];\n          return {\n            input: t,\n            interpolation: n,\n            output: r\n          };\n        }), t._data;\n      }, e.prototype._loadBufferAsync = function (e, t, n, r) {\n        var o = this._extensionsLoadBufferAsync(e, t, n, r);\n\n        if (o) return o;\n        if (!t._data) if (t.uri) t._data = this.loadUriAsync(e + \"/uri\", t, t.uri);else {\n          if (!this._bin) throw new Error(e + \": Uri is missing or the binary glTF is missing its binary chunk\");\n          t._data = this._bin.readAsync(0, t.byteLength);\n        }\n        return t._data.then(function (t) {\n          try {\n            return new Uint8Array(t.buffer, t.byteOffset + n, r);\n          } catch (t) {\n            throw new Error(e + \": \" + t.message);\n          }\n        });\n      }, e.prototype.loadBufferViewAsync = function (e, t) {\n        var n = this._extensionsLoadBufferViewAsync(e, t);\n\n        if (n) return n;\n        if (t._data) return t._data;\n        var r = a.Get(e + \"/buffer\", this._gltf.buffers, t.buffer);\n        return t._data = this._loadBufferAsync(\"/buffers/\" + r.index, r, t.byteOffset || 0, t.byteLength), t._data;\n      }, e.prototype._loadAccessorAsync = function (t, n, o) {\n        var i = this;\n        if (n._data) return n._data;\n\n        var s = e._GetNumComponents(t, n.type),\n            l = s * r.VertexBuffer.GetTypeByteLength(n.componentType),\n            u = s * n.count;\n\n        if (null == n.bufferView) n._data = Promise.resolve(new o(u));else {\n          var c = a.Get(t + \"/bufferView\", this._gltf.bufferViews, n.bufferView);\n          n._data = this.loadBufferViewAsync(\"/bufferViews/\" + c.index, c).then(function (a) {\n            if (5126 !== n.componentType || n.normalized || c.byteStride && c.byteStride !== l) {\n              var i = new o(u);\n              return r.VertexBuffer.ForEach(a, n.byteOffset || 0, c.byteStride || l, s, n.componentType, i.length, n.normalized || !1, function (e, t) {\n                i[t] = e;\n              }), i;\n            }\n\n            return e._GetTypedArray(t, n.componentType, a, n.byteOffset, u);\n          });\n        }\n\n        if (n.sparse) {\n          var d = n.sparse;\n          n._data = n._data.then(function (u) {\n            var c = u,\n                f = a.Get(t + \"/sparse/indices/bufferView\", i._gltf.bufferViews, d.indices.bufferView),\n                h = a.Get(t + \"/sparse/values/bufferView\", i._gltf.bufferViews, d.values.bufferView);\n            return Promise.all([i.loadBufferViewAsync(\"/bufferViews/\" + f.index, f), i.loadBufferViewAsync(\"/bufferViews/\" + h.index, h)]).then(function (a) {\n              var i,\n                  u = a[0],\n                  f = a[1],\n                  h = e._GetTypedArray(t + \"/sparse/indices\", d.indices.componentType, u, d.indices.byteOffset, d.count),\n                  p = s * d.count;\n\n              if (5126 !== n.componentType || n.normalized) {\n                var _ = e._GetTypedArray(t + \"/sparse/values\", n.componentType, f, d.values.byteOffset, p);\n\n                i = new o(p), r.VertexBuffer.ForEach(_, 0, l, s, n.componentType, i.length, n.normalized || !1, function (e, t) {\n                  i[t] = e;\n                });\n              } else i = e._GetTypedArray(t + \"/sparse/values\", n.componentType, f, d.values.byteOffset, p);\n\n              for (var m = 0, y = 0; y < h.length; y++) {\n                for (var b = h[y] * s, v = 0; v < s; v++) {\n                  c[b++] = i[m++];\n                }\n              }\n\n              return c;\n            });\n          });\n        }\n\n        return n._data;\n      }, e.prototype._loadFloatAccessorAsync = function (e, t) {\n        return this._loadAccessorAsync(e, t, Float32Array);\n      }, e.prototype._loadIndicesAccessorAsync = function (t, n) {\n        if (\"SCALAR\" !== n.type) throw new Error(t + \"/type: Invalid value \" + n.type);\n        if (5121 !== n.componentType && 5123 !== n.componentType && 5125 !== n.componentType) throw new Error(t + \"/componentType: Invalid value \" + n.componentType);\n        if (n._data) return n._data;\n\n        if (n.sparse) {\n          var r = e._GetTypedArrayConstructor(t + \"/componentType\", n.componentType);\n\n          n._data = this._loadAccessorAsync(t, n, r);\n        } else {\n          var o = a.Get(t + \"/bufferView\", this._gltf.bufferViews, n.bufferView);\n          n._data = this.loadBufferViewAsync(\"/bufferViews/\" + o.index, o).then(function (r) {\n            return e._GetTypedArray(t, n.componentType, r, n.byteOffset, n.count);\n          });\n        }\n\n        return n._data;\n      }, e.prototype._loadVertexBufferViewAsync = function (e, t) {\n        var n = this;\n        return e._babylonBuffer || (e._babylonBuffer = this.loadBufferViewAsync(\"/bufferViews/\" + e.index, e).then(function (e) {\n          return new r.Buffer(n._babylonScene.getEngine(), e, !1);\n        })), e._babylonBuffer;\n      }, e.prototype._loadVertexAccessorAsync = function (t, n, o) {\n        var i = this;\n        if (n._babylonVertexBuffer) return n._babylonVertexBuffer;\n        if (n.sparse) n._babylonVertexBuffer = this._loadFloatAccessorAsync(\"/accessors/\" + n.index, n).then(function (e) {\n          return new r.VertexBuffer(i._babylonScene.getEngine(), e, o, !1);\n        });else if (n.byteOffset && n.byteOffset % r.VertexBuffer.GetTypeByteLength(n.componentType) != 0) r.Logger.Warn(\"Accessor byte offset is not a multiple of component type byte length\"), n._babylonVertexBuffer = this._loadFloatAccessorAsync(\"/accessors/\" + n.index, n).then(function (e) {\n          return new r.VertexBuffer(i._babylonScene.getEngine(), e, o, !1);\n        });else if (o === r.VertexBuffer.MatricesIndicesKind || o === r.VertexBuffer.MatricesIndicesExtraKind) n._babylonVertexBuffer = this._loadFloatAccessorAsync(\"/accessors/\" + n.index, n).then(function (e) {\n          return new r.VertexBuffer(i._babylonScene.getEngine(), e, o, !1);\n        });else {\n          var s = a.Get(t + \"/bufferView\", this._gltf.bufferViews, n.bufferView);\n          n._babylonVertexBuffer = this._loadVertexBufferViewAsync(s, o).then(function (a) {\n            var l = e._GetNumComponents(t, n.type);\n\n            return new r.VertexBuffer(i._babylonScene.getEngine(), a, o, !1, !1, s.byteStride, !1, n.byteOffset, l, n.componentType, n.normalized, !0, 1, !0);\n          });\n        }\n        return n._babylonVertexBuffer;\n      }, e.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function (e, t, n) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var o = new Array();\n        return t && (t.baseColorFactor ? (n.albedoColor = r.Color3.FromArray(t.baseColorFactor), n.alpha = t.baseColorFactor[3]) : n.albedoColor = r.Color3.White(), n.metallic = null == t.metallicFactor ? 1 : t.metallicFactor, n.roughness = null == t.roughnessFactor ? 1 : t.roughnessFactor, t.baseColorTexture && o.push(this.loadTextureInfoAsync(e + \"/baseColorTexture\", t.baseColorTexture, function (e) {\n          e.name = n.name + \" (Base Color)\", n.albedoTexture = e;\n        })), t.metallicRoughnessTexture && (t.metallicRoughnessTexture.nonColorData = !0, o.push(this.loadTextureInfoAsync(e + \"/metallicRoughnessTexture\", t.metallicRoughnessTexture, function (e) {\n          e.name = n.name + \" (Metallic Roughness)\", n.metallicTexture = e;\n        })), n.useMetallnessFromMetallicTextureBlue = !0, n.useRoughnessFromMetallicTextureGreen = !0, n.useRoughnessFromMetallicTextureAlpha = !1)), Promise.all(o).then(function () {});\n      }, e.prototype._loadMaterialAsync = function (t, n, r, o, a) {\n        void 0 === a && (a = function a() {});\n\n        var i = this._extensionsLoadMaterialAsync(t, n, r, o, a);\n\n        if (i) return i;\n        n._data = n._data || {};\n        var s = n._data[o];\n\n        if (!s) {\n          this.logOpen(t + \" \" + (n.name || \"\"));\n          var l = this.createMaterial(t, n, o);\n          s = {\n            babylonMaterial: l,\n            babylonMeshes: [],\n            promise: this.loadMaterialPropertiesAsync(t, n, l)\n          }, n._data[o] = s, e.AddPointerMetadata(l, t), this._parent.onMaterialLoadedObservable.notifyObservers(l), this.logClose();\n        }\n\n        return r && (s.babylonMeshes.push(r), r.onDisposeObservable.addOnce(function () {\n          var e = s.babylonMeshes.indexOf(r);\n          -1 !== e && s.babylonMeshes.splice(e, 1);\n        })), a(s.babylonMaterial), s.promise.then(function () {\n          return s.babylonMaterial;\n        });\n      }, e.prototype._createDefaultMaterial = function (e, t) {\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        var n = new r.PBRMaterial(e, this._babylonScene);\n        return this._babylonScene._blockEntityCollection = !1, n.fillMode = t, n.enableSpecularAntiAliasing = !0, n.useRadianceOverAlpha = !this._parent.transparencyAsCoverage, n.useSpecularOverAlpha = !this._parent.transparencyAsCoverage, n.transparencyMode = r.PBRMaterial.PBRMATERIAL_OPAQUE, n.metallic = 1, n.roughness = 1, n;\n      }, e.prototype.createMaterial = function (e, t, n) {\n        var r = this._extensionsCreateMaterial(e, t, n);\n\n        if (r) return r;\n        var o = t.name || \"material\" + t.index;\n        return this._createDefaultMaterial(o, n);\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this._extensionsLoadMaterialPropertiesAsync(e, t, n);\n\n        if (r) return r;\n        var o = new Array();\n        return o.push(this.loadMaterialBasePropertiesAsync(e, t, n)), t.pbrMetallicRoughness && o.push(this._loadMaterialMetallicRoughnessPropertiesAsync(e + \"/pbrMetallicRoughness\", t.pbrMetallicRoughness, n)), this.loadMaterialAlphaProperties(e, t, n), Promise.all(o).then(function () {});\n      }, e.prototype.loadMaterialBasePropertiesAsync = function (e, t, n) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var o = new Array();\n        return n.emissiveColor = t.emissiveFactor ? r.Color3.FromArray(t.emissiveFactor) : new r.Color3(0, 0, 0), t.doubleSided && (n.backFaceCulling = !1, n.twoSidedLighting = !0), t.normalTexture && (t.normalTexture.nonColorData = !0, o.push(this.loadTextureInfoAsync(e + \"/normalTexture\", t.normalTexture, function (e) {\n          e.name = n.name + \" (Normal)\", n.bumpTexture = e;\n        })), n.invertNormalMapX = !this._babylonScene.useRightHandedSystem, n.invertNormalMapY = this._babylonScene.useRightHandedSystem, null != t.normalTexture.scale && (n.bumpTexture.level = t.normalTexture.scale), n.forceIrradianceInFragment = !0), t.occlusionTexture && (t.occlusionTexture.nonColorData = !0, o.push(this.loadTextureInfoAsync(e + \"/occlusionTexture\", t.occlusionTexture, function (e) {\n          e.name = n.name + \" (Occlusion)\", n.ambientTexture = e;\n        })), n.useAmbientInGrayScale = !0, null != t.occlusionTexture.strength && (n.ambientTextureStrength = t.occlusionTexture.strength)), t.emissiveTexture && o.push(this.loadTextureInfoAsync(e + \"/emissiveTexture\", t.emissiveTexture, function (e) {\n          e.name = n.name + \" (Emissive)\", n.emissiveTexture = e;\n        })), Promise.all(o).then(function () {});\n      }, e.prototype.loadMaterialAlphaProperties = function (e, t, n) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n\n        switch (t.alphaMode || \"OPAQUE\") {\n          case \"OPAQUE\":\n            n.transparencyMode = r.PBRMaterial.PBRMATERIAL_OPAQUE;\n            break;\n\n          case \"MASK\":\n            n.transparencyMode = r.PBRMaterial.PBRMATERIAL_ALPHATEST, n.alphaCutOff = null == t.alphaCutoff ? .5 : t.alphaCutoff, n.albedoTexture && (n.albedoTexture.hasAlpha = !0);\n            break;\n\n          case \"BLEND\":\n            n.transparencyMode = r.PBRMaterial.PBRMATERIAL_ALPHABLEND, n.albedoTexture && (n.albedoTexture.hasAlpha = !0, n.useAlphaFromAlbedoTexture = !0);\n            break;\n\n          default:\n            throw new Error(e + \"/alphaMode: Invalid value (\" + t.alphaMode + \")\");\n        }\n      }, e.prototype.loadTextureInfoAsync = function (t, n, r) {\n        var o = this;\n        void 0 === r && (r = function r() {});\n\n        var i = this._extensionsLoadTextureInfoAsync(t, n, r);\n\n        if (i) return i;\n        if (this.logOpen(\"\" + t), n.texCoord >= 2) throw new Error(t + \"/texCoord: Invalid value (\" + n.texCoord + \")\");\n        var s = a.Get(t + \"/index\", this._gltf.textures, n.index);\n        s._textureInfo = n;\n\n        var l = this._loadTextureAsync(\"/textures/\" + n.index, s, function (a) {\n          a.coordinatesIndex = n.texCoord || 0, e.AddPointerMetadata(a, t), o._parent.onTextureLoadedObservable.notifyObservers(a), r(a);\n        });\n\n        return this.logClose(), l;\n      }, e.prototype._loadTextureAsync = function (t, n, r) {\n        void 0 === r && (r = function r() {});\n\n        var o = this._extensionsLoadTextureAsync(t, n, r);\n\n        if (o) return o;\n        this.logOpen(t + \" \" + (n.name || \"\"));\n\n        var i = null == n.sampler ? e.DefaultSampler : a.Get(t + \"/sampler\", this._gltf.samplers, n.sampler),\n            s = a.Get(t + \"/source\", this._gltf.images, n.source),\n            l = this._createTextureAsync(t, i, s, r);\n\n        return this.logClose(), l;\n      }, e.prototype._createTextureAsync = function (e, t, n, o, a) {\n        var i = this;\n        void 0 === o && (o = function o() {});\n\n        var s = this._loadSampler(\"/samplers/\" + t.index, t),\n            l = new Array(),\n            u = new r.Deferred();\n\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        var c = new r.Texture(null, this._babylonScene, s.noMipMaps, !1, s.samplingMode, function () {\n          i._disposed || u.resolve();\n        }, function (t, n) {\n          i._disposed || u.reject(new Error(e + \": \" + (n && n.message ? n.message : t || \"Failed to load texture\")));\n        }, void 0, void 0, void 0, n.mimeType, a);\n        return this._babylonScene._blockEntityCollection = !1, l.push(u.promise), l.push(this.loadImageAsync(\"/images/\" + n.index, n).then(function (e) {\n          var t = n.uri || i._fileName + \"#image\" + n.index,\n              r = \"data:\" + i._uniqueRootUrl + t;\n          c.updateURL(r, e);\n        })), c.wrapU = s.wrapU, c.wrapV = s.wrapV, o(c), Promise.all(l).then(function () {\n          return c;\n        });\n      }, e.prototype._loadSampler = function (t, n) {\n        return n._data || (n._data = {\n          noMipMaps: 9728 === n.minFilter || 9729 === n.minFilter,\n          samplingMode: e._GetTextureSamplingMode(t, n),\n          wrapU: e._GetTextureWrapMode(t + \"/wrapS\", n.wrapS),\n          wrapV: e._GetTextureWrapMode(t + \"/wrapT\", n.wrapT)\n        }), n._data;\n      }, e.prototype.loadImageAsync = function (e, t) {\n        if (!t._data) {\n          if (this.logOpen(e + \" \" + (t.name || \"\")), t.uri) t._data = this.loadUriAsync(e + \"/uri\", t, t.uri);else {\n            var n = a.Get(e + \"/bufferView\", this._gltf.bufferViews, t.bufferView);\n            t._data = this.loadBufferViewAsync(\"/bufferViews/\" + n.index, n);\n          }\n          this.logClose();\n        }\n\n        return t._data;\n      }, e.prototype.loadUriAsync = function (t, n, o) {\n        var a = this,\n            i = this._extensionsLoadUriAsync(t, n, o);\n\n        if (i) return i;\n        if (!e._ValidateUri(o)) throw new Error(t + \": '\" + o + \"' is invalid\");\n\n        if (r.Tools.IsBase64(o)) {\n          var s = new Uint8Array(r.Tools.DecodeBase64(o));\n          return this.log(\"Decoded \" + o.substr(0, 64) + \"... (\" + s.length + \" bytes)\"), Promise.resolve(s);\n        }\n\n        return this.log(\"Loading \" + o), this._parent.preprocessUrlAsync(this._rootUrl + o).then(function (e) {\n          return new Promise(function (n, i) {\n            a._parent._loadFile(e, a._babylonScene, function (e) {\n              a._disposed || (a.log(\"Loaded \" + o + \" (\" + e.byteLength + \" bytes)\"), n(new Uint8Array(e)));\n            }, !0, function (e) {\n              i(new r.LoadFileError(t + \": Failed to load '\" + o + \"'\" + (e ? \": \" + e.status + \" \" + e.statusText : \"\"), e));\n            });\n          });\n        });\n      }, e.AddPointerMetadata = function (e, t) {\n        var n = e.metadata = e.metadata || {},\n            r = n.gltf = n.gltf || {};\n        (r.pointers = r.pointers || []).push(t);\n      }, e._GetTextureWrapMode = function (e, t) {\n        switch (t = null == t ? 10497 : t) {\n          case 33071:\n            return r.Texture.CLAMP_ADDRESSMODE;\n\n          case 33648:\n            return r.Texture.MIRROR_ADDRESSMODE;\n\n          case 10497:\n            return r.Texture.WRAP_ADDRESSMODE;\n\n          default:\n            return r.Logger.Warn(e + \": Invalid value (\" + t + \")\"), r.Texture.WRAP_ADDRESSMODE;\n        }\n      }, e._GetTextureSamplingMode = function (e, t) {\n        var n = null == t.magFilter ? 9729 : t.magFilter,\n            o = null == t.minFilter ? 9987 : t.minFilter;\n        if (9729 === n) switch (o) {\n          case 9728:\n            return r.Texture.LINEAR_NEAREST;\n\n          case 9729:\n            return r.Texture.LINEAR_LINEAR;\n\n          case 9984:\n            return r.Texture.LINEAR_NEAREST_MIPNEAREST;\n\n          case 9985:\n            return r.Texture.LINEAR_LINEAR_MIPNEAREST;\n\n          case 9986:\n            return r.Texture.LINEAR_NEAREST_MIPLINEAR;\n\n          case 9987:\n            return r.Texture.LINEAR_LINEAR_MIPLINEAR;\n\n          default:\n            return r.Logger.Warn(e + \"/minFilter: Invalid value (\" + o + \")\"), r.Texture.LINEAR_LINEAR_MIPLINEAR;\n        } else switch (9728 !== n && r.Logger.Warn(e + \"/magFilter: Invalid value (\" + n + \")\"), o) {\n          case 9728:\n            return r.Texture.NEAREST_NEAREST;\n\n          case 9729:\n            return r.Texture.NEAREST_LINEAR;\n\n          case 9984:\n            return r.Texture.NEAREST_NEAREST_MIPNEAREST;\n\n          case 9985:\n            return r.Texture.NEAREST_LINEAR_MIPNEAREST;\n\n          case 9986:\n            return r.Texture.NEAREST_NEAREST_MIPLINEAR;\n\n          case 9987:\n            return r.Texture.NEAREST_LINEAR_MIPLINEAR;\n\n          default:\n            return r.Logger.Warn(e + \"/minFilter: Invalid value (\" + o + \")\"), r.Texture.NEAREST_NEAREST_MIPNEAREST;\n        }\n      }, e._GetTypedArrayConstructor = function (e, t) {\n        switch (t) {\n          case 5120:\n            return Int8Array;\n\n          case 5121:\n            return Uint8Array;\n\n          case 5122:\n            return Int16Array;\n\n          case 5123:\n            return Uint16Array;\n\n          case 5125:\n            return Uint32Array;\n\n          case 5126:\n            return Float32Array;\n\n          default:\n            throw new Error(e + \": Invalid component type \" + t);\n        }\n      }, e._GetTypedArray = function (t, n, r, o, a) {\n        var i = r.buffer;\n        o = r.byteOffset + (o || 0);\n\n        var s = e._GetTypedArrayConstructor(t + \"/componentType\", n);\n\n        try {\n          return new s(i, o, a);\n        } catch (e) {\n          throw new Error(t + \": \" + e);\n        }\n      }, e._GetNumComponents = function (e, t) {\n        switch (t) {\n          case \"SCALAR\":\n            return 1;\n\n          case \"VEC2\":\n            return 2;\n\n          case \"VEC3\":\n            return 3;\n\n          case \"VEC4\":\n          case \"MAT2\":\n            return 4;\n\n          case \"MAT3\":\n            return 9;\n\n          case \"MAT4\":\n            return 16;\n        }\n\n        throw new Error(e + \": Invalid type (\" + t + \")\");\n      }, e._ValidateUri = function (e) {\n        return r.Tools.IsBase64(e) || -1 === e.indexOf(\"..\");\n      }, e._GetDrawMode = function (e, t) {\n        switch (null == t && (t = 4), t) {\n          case 0:\n            return r.Material.PointListDrawMode;\n\n          case 1:\n            return r.Material.LineListDrawMode;\n\n          case 2:\n            return r.Material.LineLoopDrawMode;\n\n          case 3:\n            return r.Material.LineStripDrawMode;\n\n          case 4:\n            return r.Material.TriangleFillMode;\n\n          case 5:\n            return r.Material.TriangleStripDrawMode;\n\n          case 6:\n            return r.Material.TriangleFanDrawMode;\n        }\n\n        throw new Error(e + \": Invalid mesh primitive mode (\" + t + \")\");\n      }, e.prototype._compileMaterialsAsync = function () {\n        var e = this;\n\n        this._parent._startPerformanceCounter(\"Compile materials\");\n\n        var t = new Array();\n        if (this._gltf.materials) for (var n = 0, r = this._gltf.materials; n < r.length; n++) {\n          var o = r[n];\n          if (o._data) for (var a in o._data) {\n            for (var i = o._data[a], s = 0, l = i.babylonMeshes; s < l.length; s++) {\n              var u = l[s];\n              u.computeWorldMatrix(!0);\n              var c = i.babylonMaterial;\n              t.push(c.forceCompilationAsync(u)), t.push(c.forceCompilationAsync(u, {\n                useInstances: !0\n              })), this._parent.useClipPlane && (t.push(c.forceCompilationAsync(u, {\n                clipPlane: !0\n              })), t.push(c.forceCompilationAsync(u, {\n                clipPlane: !0,\n                useInstances: !0\n              })));\n            }\n          }\n        }\n        return Promise.all(t).then(function () {\n          e._parent._endPerformanceCounter(\"Compile materials\");\n        });\n      }, e.prototype._compileShadowGeneratorsAsync = function () {\n        var e = this;\n\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\n\n        for (var t = new Array(), n = 0, r = this._babylonScene.lights; n < r.length; n++) {\n          var o = r[n].getShadowGenerator();\n          o && t.push(o.forceCompilationAsync());\n        }\n\n        return Promise.all(t).then(function () {\n          e._parent._endPerformanceCounter(\"Compile shadow generators\");\n        });\n      }, e.prototype._forEachExtensions = function (e) {\n        for (var t = 0, n = this._extensions; t < n.length; t++) {\n          var r = n[t];\n          r.enabled && e(r);\n        }\n      }, e.prototype._applyExtensions = function (e, t, n) {\n        for (var r = 0, o = this._extensions; r < o.length; r++) {\n          var a = o[r];\n\n          if (a.enabled) {\n            var i = a.name + \".\" + t,\n                s = e;\n            s._activeLoaderExtensionFunctions = s._activeLoaderExtensionFunctions || {};\n            var l = s._activeLoaderExtensionFunctions;\n\n            if (!l[i]) {\n              l[i] = !0;\n\n              try {\n                var u = n(a);\n                if (u) return u;\n              } finally {\n                delete l[i];\n              }\n            }\n          }\n        }\n\n        return null;\n      }, e.prototype._extensionsOnLoading = function () {\n        this._forEachExtensions(function (e) {\n          return e.onLoading && e.onLoading();\n        });\n      }, e.prototype._extensionsOnReady = function () {\n        this._forEachExtensions(function (e) {\n          return e.onReady && e.onReady();\n        });\n      }, e.prototype._extensionsLoadSceneAsync = function (e, t) {\n        return this._applyExtensions(t, \"loadScene\", function (n) {\n          return n.loadSceneAsync && n.loadSceneAsync(e, t);\n        });\n      }, e.prototype._extensionsLoadNodeAsync = function (e, t, n) {\n        return this._applyExtensions(t, \"loadNode\", function (r) {\n          return r.loadNodeAsync && r.loadNodeAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadCameraAsync = function (e, t, n) {\n        return this._applyExtensions(t, \"loadCamera\", function (r) {\n          return r.loadCameraAsync && r.loadCameraAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadVertexDataAsync = function (e, t, n) {\n        return this._applyExtensions(t, \"loadVertexData\", function (r) {\n          return r._loadVertexDataAsync && r._loadVertexDataAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadMeshPrimitiveAsync = function (e, t, n, r, o, a) {\n        return this._applyExtensions(o, \"loadMeshPrimitive\", function (i) {\n          return i._loadMeshPrimitiveAsync && i._loadMeshPrimitiveAsync(e, t, n, r, o, a);\n        });\n      }, e.prototype._extensionsLoadMaterialAsync = function (e, t, n, r, o) {\n        return this._applyExtensions(t, \"loadMaterial\", function (a) {\n          return a._loadMaterialAsync && a._loadMaterialAsync(e, t, n, r, o);\n        });\n      }, e.prototype._extensionsCreateMaterial = function (e, t, n) {\n        return this._applyExtensions(t, \"createMaterial\", function (r) {\n          return r.createMaterial && r.createMaterial(e, t, n);\n        });\n      }, e.prototype._extensionsLoadMaterialPropertiesAsync = function (e, t, n) {\n        return this._applyExtensions(t, \"loadMaterialProperties\", function (r) {\n          return r.loadMaterialPropertiesAsync && r.loadMaterialPropertiesAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadTextureInfoAsync = function (e, t, n) {\n        return this._applyExtensions(t, \"loadTextureInfo\", function (r) {\n          return r.loadTextureInfoAsync && r.loadTextureInfoAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadTextureAsync = function (e, t, n) {\n        return this._applyExtensions(t, \"loadTexture\", function (r) {\n          return r._loadTextureAsync && r._loadTextureAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadAnimationAsync = function (e, t) {\n        return this._applyExtensions(t, \"loadAnimation\", function (n) {\n          return n.loadAnimationAsync && n.loadAnimationAsync(e, t);\n        });\n      }, e.prototype._extensionsLoadSkinAsync = function (e, t, n) {\n        return this._applyExtensions(n, \"loadSkin\", function (r) {\n          return r._loadSkinAsync && r._loadSkinAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadUriAsync = function (e, t, n) {\n        return this._applyExtensions(t, \"loadUri\", function (r) {\n          return r._loadUriAsync && r._loadUriAsync(e, t, n);\n        });\n      }, e.prototype._extensionsLoadBufferViewAsync = function (e, t) {\n        return this._applyExtensions(t, \"loadBufferView\", function (n) {\n          return n.loadBufferViewAsync && n.loadBufferViewAsync(e, t);\n        });\n      }, e.prototype._extensionsLoadBufferAsync = function (e, t, n, r) {\n        return this._applyExtensions(t, \"loadBuffer\", function (o) {\n          return o.loadBufferAsync && o.loadBufferAsync(e, t, n, r);\n        });\n      }, e.LoadExtensionAsync = function (e, t, n, r) {\n        if (!t.extensions) return null;\n        var o = t.extensions[n];\n        return o ? r(e + \"/extensions/\" + n, o) : null;\n      }, e.LoadExtraAsync = function (e, t, n, r) {\n        if (!t.extras) return null;\n        var o = t.extras[n];\n        return o ? r(e + \"/extras/\" + n, o) : null;\n      }, e.prototype.isExtensionUsed = function (e) {\n        return !!this._gltf.extensionsUsed && -1 !== this._gltf.extensionsUsed.indexOf(e);\n      }, e.prototype.logOpen = function (e) {\n        this._parent._logOpen(e);\n      }, e.prototype.logClose = function () {\n        this._parent._logClose();\n      }, e.prototype.log = function (e) {\n        this._parent._log(e);\n      }, e.prototype.startPerformanceCounter = function (e) {\n        this._parent._startPerformanceCounter(e);\n      }, e.prototype.endPerformanceCounter = function (e) {\n        this._parent._endPerformanceCounter(e);\n      }, e._RegisteredExtensions = {}, e.DefaultSampler = {\n        index: -1\n      }, e;\n    }();\n\n    o.GLTFFileLoader._CreateGLTF2Loader = function (e) {\n      return new i(e);\n    };\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"GLTFLoaderCoordinateSystemMode\", function () {\n      return r;\n    }), n.d(t, \"GLTFLoaderAnimationStartMode\", function () {\n      return o;\n    }), n.d(t, \"GLTFLoaderState\", function () {\n      return a;\n    }), n.d(t, \"GLTFFileLoader\", function () {\n      return l;\n    });\n    var r,\n        o,\n        a,\n        i = n(0),\n        s = n(3);\n    !function (e) {\n      e[e.AUTO = 0] = \"AUTO\", e[e.FORCE_RIGHT_HANDED = 1] = \"FORCE_RIGHT_HANDED\";\n    }(r || (r = {})), function (e) {\n      e[e.NONE = 0] = \"NONE\", e[e.FIRST = 1] = \"FIRST\", e[e.ALL = 2] = \"ALL\";\n    }(o || (o = {})), function (e) {\n      e[e.LOADING = 0] = \"LOADING\", e[e.READY = 1] = \"READY\", e[e.COMPLETE = 2] = \"COMPLETE\";\n    }(a || (a = {}));\n\n    var l = function () {\n      function e() {\n        this.onParsedObservable = new i.Observable(), this.coordinateSystemMode = r.AUTO, this.animationStartMode = o.FIRST, this.compileMaterials = !1, this.useClipPlane = !1, this.compileShadowGenerators = !1, this.transparencyAsCoverage = !1, this.useRangeRequests = !1, this.createInstances = !0, this.alwaysComputeBoundingBox = !1, this.loadAllMaterials = !1, this.preprocessUrlAsync = function (e) {\n          return Promise.resolve(e);\n        }, this.onMeshLoadedObservable = new i.Observable(), this.onTextureLoadedObservable = new i.Observable(), this.onMaterialLoadedObservable = new i.Observable(), this.onCameraLoadedObservable = new i.Observable(), this.onCompleteObservable = new i.Observable(), this.onErrorObservable = new i.Observable(), this.onDisposeObservable = new i.Observable(), this.onExtensionLoadedObservable = new i.Observable(), this.validate = !1, this.onValidatedObservable = new i.Observable(), this._loader = null, this._requests = new Array(), this.name = \"gltf\", this.extensions = {\n          \".gltf\": {\n            isBinary: !1\n          },\n          \".glb\": {\n            isBinary: !0\n          }\n        }, this._logIndentLevel = 0, this._loggingEnabled = !1, this._log = this._logDisabled, this._capturePerformanceCounters = !1, this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n      }\n\n      return Object.defineProperty(e.prototype, \"onParsed\", {\n        set: function set(e) {\n          this._onParsedObserver && this.onParsedObservable.remove(this._onParsedObserver), this._onParsedObserver = this.onParsedObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onMeshLoaded\", {\n        set: function set(e) {\n          this._onMeshLoadedObserver && this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver), this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onTextureLoaded\", {\n        set: function set(e) {\n          this._onTextureLoadedObserver && this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver), this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onMaterialLoaded\", {\n        set: function set(e) {\n          this._onMaterialLoadedObserver && this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver), this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onCameraLoaded\", {\n        set: function set(e) {\n          this._onCameraLoadedObserver && this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver), this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onComplete\", {\n        set: function set(e) {\n          this._onCompleteObserver && this.onCompleteObservable.remove(this._onCompleteObserver), this._onCompleteObserver = this.onCompleteObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onError\", {\n        set: function set(e) {\n          this._onErrorObserver && this.onErrorObservable.remove(this._onErrorObserver), this._onErrorObserver = this.onErrorObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onDispose\", {\n        set: function set(e) {\n          this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onExtensionLoaded\", {\n        set: function set(e) {\n          this._onExtensionLoadedObserver && this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver), this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"loggingEnabled\", {\n        get: function get() {\n          return this._loggingEnabled;\n        },\n        set: function set(e) {\n          this._loggingEnabled !== e && (this._loggingEnabled = e, this._loggingEnabled ? this._log = this._logEnabled : this._log = this._logDisabled);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"capturePerformanceCounters\", {\n        get: function get() {\n          return this._capturePerformanceCounters;\n        },\n        set: function set(e) {\n          this._capturePerformanceCounters !== e && (this._capturePerformanceCounters = e, this._capturePerformanceCounters ? (this._startPerformanceCounter = this._startPerformanceCounterEnabled, this._endPerformanceCounter = this._endPerformanceCounterEnabled) : (this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled));\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"onValidated\", {\n        set: function set(e) {\n          this._onValidatedObserver && this.onValidatedObservable.remove(this._onValidatedObserver), this._onValidatedObserver = this.onValidatedObservable.add(e);\n        },\n        enumerable: !1,\n        configurable: !0\n      }), e.prototype.dispose = function () {\n        this._loader && (this._loader.dispose(), this._loader = null);\n\n        for (var e = 0, t = this._requests; e < t.length; e++) {\n          t[e].abort();\n        }\n\n        this._requests.length = 0, delete this._progressCallback, this.preprocessUrlAsync = function (e) {\n          return Promise.resolve(e);\n        }, this.onMeshLoadedObservable.clear(), this.onTextureLoadedObservable.clear(), this.onMaterialLoadedObservable.clear(), this.onCameraLoadedObservable.clear(), this.onCompleteObservable.clear(), this.onExtensionLoadedObservable.clear(), this.onDisposeObservable.notifyObservers(void 0), this.onDisposeObservable.clear();\n      }, e.prototype.requestFile = function (e, t, n, r, o, a) {\n        var s = this;\n\n        if (this._progressCallback = r, o) {\n          if (this.useRangeRequests) {\n            this.validate && i.Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\n            var l = {\n              abort: function abort() {},\n              onCompleteObservable: new i.Observable()\n            },\n                u = {\n              readAsync: function readAsync(n, r) {\n                return new Promise(function (o, a) {\n                  s._requestFile(t, e, function (e) {\n                    o(new Uint8Array(e));\n                  }, !0, function (e) {\n                    a(e);\n                  }, function (e) {\n                    e.setRequestHeader(\"Range\", \"bytes=\" + n + \"-\" + (n + r - 1));\n                  });\n                });\n              },\n              byteLength: 0\n            };\n            return this._unpackBinaryAsync(new i.DataReader(u)).then(function (e) {\n              l.onCompleteObservable.notifyObservers(l), n(e);\n            }, a), l;\n          }\n\n          return this._requestFile(t, e, function (e, t) {\n            var r = e;\n\n            s._unpackBinaryAsync(new i.DataReader({\n              readAsync: function readAsync(e, t) {\n                return Promise.resolve(new Uint8Array(r, e, t));\n              },\n              byteLength: r.byteLength\n            })).then(function (e) {\n              n(e, t);\n            }, a);\n          }, !0, a);\n        }\n\n        return this._requestFile(t, e, function (r, o) {\n          s._validate(e, r, i.Tools.GetFolderPath(t), i.Tools.GetFilename(t)), n({\n            json: s._parseJson(r)\n          }, o);\n        }, o, a);\n      }, e.prototype.readFile = function (e, t, n, r, o, a) {\n        var s = this;\n        return e._readFile(t, function (r) {\n          if (s._validate(e, r, \"file:\", t.name), o) {\n            var l = r;\n\n            s._unpackBinaryAsync(new i.DataReader({\n              readAsync: function readAsync(e, t) {\n                return Promise.resolve(new Uint8Array(l, e, t));\n              },\n              byteLength: l.byteLength\n            })).then(n, a);\n          } else n({\n            json: s._parseJson(r)\n          });\n        }, r, o, a);\n      }, e.prototype.importMeshAsync = function (e, t, n, r, o, a) {\n        var i = this;\n        return Promise.resolve().then(function () {\n          return i.onParsedObservable.notifyObservers(n), i.onParsedObservable.clear(), i._log(\"Loading \" + (a || \"\")), i._loader = i._getLoader(n), i._loader.importMeshAsync(e, t, !1, n, r, o, a);\n        });\n      }, e.prototype.loadAsync = function (e, t, n, r, o) {\n        var a = this;\n        return Promise.resolve().then(function () {\n          return a.onParsedObservable.notifyObservers(t), a.onParsedObservable.clear(), a._log(\"Loading \" + (o || \"\")), a._loader = a._getLoader(t), a._loader.loadAsync(e, t, n, r, o);\n        });\n      }, e.prototype.loadAssetContainerAsync = function (e, t, n, r, o) {\n        var a = this;\n        return Promise.resolve().then(function () {\n          a.onParsedObservable.notifyObservers(t), a.onParsedObservable.clear(), a._log(\"Loading \" + (o || \"\")), a._loader = a._getLoader(t);\n          var s = new i.AssetContainer(e),\n              l = [];\n          a.onMaterialLoadedObservable.add(function (e) {\n            l.push(e), e.onDisposeObservable.addOnce(function () {\n              var t = s.materials.indexOf(e);\n              t > -1 && s.materials.splice(t, 1), (t = l.indexOf(e)) > -1 && l.splice(t, 1);\n            });\n          });\n          var u = [];\n          a.onTextureLoadedObservable.add(function (e) {\n            u.push(e), e.onDisposeObservable.addOnce(function () {\n              var t = s.textures.indexOf(e);\n              t > -1 && s.textures.splice(t, 1), (t = u.indexOf(e)) > -1 && u.splice(t, 1);\n            });\n          });\n          var c = [];\n          return a.onCameraLoadedObservable.add(function (e) {\n            c.push(e);\n          }), a._loader.importMeshAsync(null, e, !0, t, n, r, o).then(function (e) {\n            return Array.prototype.push.apply(s.geometries, e.geometries), Array.prototype.push.apply(s.meshes, e.meshes), Array.prototype.push.apply(s.particleSystems, e.particleSystems), Array.prototype.push.apply(s.skeletons, e.skeletons), Array.prototype.push.apply(s.animationGroups, e.animationGroups), Array.prototype.push.apply(s.materials, l), Array.prototype.push.apply(s.textures, u), Array.prototype.push.apply(s.lights, e.lights), Array.prototype.push.apply(s.transformNodes, e.transformNodes), Array.prototype.push.apply(s.cameras, c), s;\n          });\n        });\n      }, e.prototype.canDirectLoad = function (t) {\n        return -1 !== t.indexOf(\"asset\") && -1 !== t.indexOf(\"version\") || i.StringTools.StartsWith(t, \"data:base64,\" + e.magicBase64Encoded) || i.StringTools.StartsWith(t, \"data:application/octet-stream;base64,\" + e.magicBase64Encoded) || i.StringTools.StartsWith(t, \"data:model/gltf-binary;base64,\" + e.magicBase64Encoded);\n      }, e.prototype.directLoad = function (t, n) {\n        if (i.StringTools.StartsWith(n, \"base64,\" + e.magicBase64Encoded) || i.StringTools.StartsWith(n, \"application/octet-stream;base64,\" + e.magicBase64Encoded) || i.StringTools.StartsWith(n, \"model/gltf-binary;base64,\" + e.magicBase64Encoded)) {\n          var r = i.Tools.DecodeBase64(n);\n          return this._validate(t, r), this._unpackBinaryAsync(new i.DataReader({\n            readAsync: function readAsync(e, t) {\n              return Promise.resolve(new Uint8Array(r, e, t));\n            },\n            byteLength: r.byteLength\n          }));\n        }\n\n        return this._validate(t, n), Promise.resolve({\n          json: this._parseJson(n)\n        });\n      }, e.prototype.createPlugin = function () {\n        return new e();\n      }, Object.defineProperty(e.prototype, \"loaderState\", {\n        get: function get() {\n          return this._loader ? this._loader.state : null;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), e.prototype.whenCompleteAsync = function () {\n        var e = this;\n        return new Promise(function (t, n) {\n          e.onCompleteObservable.addOnce(function () {\n            t();\n          }), e.onErrorObservable.addOnce(function (e) {\n            n(e);\n          });\n        });\n      }, e.prototype._loadFile = function (e, t, n, r, o) {\n        var a = this,\n            i = t._loadFile(e, n, function (e) {\n          a._onProgress(e, i);\n        }, void 0, r, o);\n\n        return i.onCompleteObservable.add(function (e) {\n          a._requests.splice(a._requests.indexOf(e), 1);\n        }), this._requests.push(i), i;\n      }, e.prototype._requestFile = function (e, t, n, r, o, a) {\n        var i = this,\n            s = t._requestFile(e, n, function (e) {\n          i._onProgress(e, s);\n        }, void 0, r, o, a);\n\n        return s.onCompleteObservable.add(function (e) {\n          i._requests.splice(i._requests.indexOf(e), 1);\n        }), this._requests.push(s), s;\n      }, e.prototype._onProgress = function (e, t) {\n        if (this._progressCallback) {\n          t._lengthComputable = e.lengthComputable, t._loaded = e.loaded, t._total = e.total;\n\n          for (var n = !0, r = 0, o = 0, a = 0, i = this._requests; a < i.length; a++) {\n            var s = i[a];\n            if (void 0 === s._lengthComputable || void 0 === s._loaded || void 0 === s._total) return;\n            n = n && s._lengthComputable, r += s._loaded, o += s._total;\n          }\n\n          this._progressCallback({\n            lengthComputable: n,\n            loaded: r,\n            total: n ? o : 0\n          });\n        }\n      }, e.prototype._validate = function (e, t, n, r) {\n        var o = this;\n        void 0 === n && (n = \"\"), void 0 === r && (r = \"\"), this.validate && (this._startPerformanceCounter(\"Validate JSON\"), s.GLTFValidation.ValidateAsync(t, n, r, function (t) {\n          return o.preprocessUrlAsync(n + t).then(function (t) {\n            return e._loadFileAsync(t, void 0, !0, !0);\n          });\n        }).then(function (e) {\n          o._endPerformanceCounter(\"Validate JSON\"), o.onValidatedObservable.notifyObservers(e), o.onValidatedObservable.clear();\n        }, function (e) {\n          o._endPerformanceCounter(\"Validate JSON\"), i.Tools.Warn(\"Failed to validate: \" + e.message), o.onValidatedObservable.clear();\n        }));\n      }, e.prototype._getLoader = function (t) {\n        var n = t.json.asset || {};\n        this._log(\"Asset version: \" + n.version), n.minVersion && this._log(\"Asset minimum version: \" + n.minVersion), n.generator && this._log(\"Asset generator: \" + n.generator);\n\n        var r = e._parseVersion(n.version);\n\n        if (!r) throw new Error(\"Invalid version: \" + n.version);\n\n        if (void 0 !== n.minVersion) {\n          var o = e._parseVersion(n.minVersion);\n\n          if (!o) throw new Error(\"Invalid minimum version: \" + n.minVersion);\n          if (e._compareVersion(o, {\n            major: 2,\n            minor: 0\n          }) > 0) throw new Error(\"Incompatible minimum version: \" + n.minVersion);\n        }\n\n        var a = {\n          1: e._CreateGLTF1Loader,\n          2: e._CreateGLTF2Loader\n        }[r.major];\n        if (!a) throw new Error(\"Unsupported version: \" + n.version);\n        return a(this);\n      }, e.prototype._parseJson = function (e) {\n        this._startPerformanceCounter(\"Parse JSON\"), this._log(\"JSON length: \" + e.length);\n        var t = JSON.parse(e);\n        return this._endPerformanceCounter(\"Parse JSON\"), t;\n      }, e.prototype._unpackBinaryAsync = function (e) {\n        var t = this;\n        return this._startPerformanceCounter(\"Unpack Binary\"), e.loadAsync(20).then(function () {\n          var n = e.readUint32();\n          if (1179937895 !== n) throw new Error(\"Unexpected magic: \" + n);\n          var r = e.readUint32();\n          t.loggingEnabled && t._log(\"Binary version: \" + r);\n          var o,\n              a = e.readUint32();\n          if (0 !== e.buffer.byteLength && a !== e.buffer.byteLength) throw new Error(\"Length in header does not match actual data length: \" + a + \" != \" + e.buffer.byteLength);\n\n          switch (r) {\n            case 1:\n              o = t._unpackBinaryV1Async(e, a);\n              break;\n\n            case 2:\n              o = t._unpackBinaryV2Async(e, a);\n              break;\n\n            default:\n              throw new Error(\"Unsupported version: \" + r);\n          }\n\n          return t._endPerformanceCounter(\"Unpack Binary\"), o;\n        });\n      }, e.prototype._unpackBinaryV1Async = function (e, t) {\n        var n = e.readUint32(),\n            r = e.readUint32();\n        if (0 !== r) throw new Error(\"Unexpected content format: \" + r);\n        var o = t - e.byteOffset,\n            a = {\n          json: this._parseJson(e.readString(n)),\n          bin: null\n        };\n\n        if (0 !== o) {\n          var i = e.byteOffset;\n          a.bin = {\n            readAsync: function readAsync(t, n) {\n              return e.buffer.readAsync(i + t, n);\n            },\n            byteLength: o\n          };\n        }\n\n        return Promise.resolve(a);\n      }, e.prototype._unpackBinaryV2Async = function (e, t) {\n        var n = this,\n            r = 1313821514,\n            o = 5130562,\n            a = e.readUint32();\n        if (e.readUint32() !== r) throw new Error(\"First chunk format is not JSON\");\n        return e.byteOffset + a === t ? e.loadAsync(a).then(function () {\n          return {\n            json: n._parseJson(e.readString(a)),\n            bin: null\n          };\n        }) : e.loadAsync(a + 8).then(function () {\n          var i = {\n            json: n._parseJson(e.readString(a)),\n            bin: null\n          },\n              s = function s() {\n            var n = e.readUint32();\n\n            switch (e.readUint32()) {\n              case r:\n                throw new Error(\"Unexpected JSON chunk\");\n\n              case o:\n                var a = e.byteOffset;\n                i.bin = {\n                  readAsync: function readAsync(t, n) {\n                    return e.buffer.readAsync(a + t, n);\n                  },\n                  byteLength: n\n                }, e.skipBytes(n);\n                break;\n\n              default:\n                e.skipBytes(n);\n            }\n\n            return e.byteOffset !== t ? e.loadAsync(8).then(s) : Promise.resolve(i);\n          };\n\n          return s();\n        });\n      }, e._parseVersion = function (e) {\n        if (\"1.0\" === e || \"1.0.1\" === e) return {\n          major: 1,\n          minor: 0\n        };\n        var t = (e + \"\").match(/^(\\d+)\\.(\\d+)/);\n        return t ? {\n          major: parseInt(t[1]),\n          minor: parseInt(t[2])\n        } : null;\n      }, e._compareVersion = function (e, t) {\n        return e.major > t.major ? 1 : e.major < t.major ? -1 : e.minor > t.minor ? 1 : e.minor < t.minor ? -1 : 0;\n      }, e.prototype._logOpen = function (e) {\n        this._log(e), this._logIndentLevel++;\n      }, e.prototype._logClose = function () {\n        --this._logIndentLevel;\n      }, e.prototype._logEnabled = function (t) {\n        var n = e._logSpaces.substr(0, 2 * this._logIndentLevel);\n\n        i.Logger.Log(\"\" + n + t);\n      }, e.prototype._logDisabled = function (e) {}, e.prototype._startPerformanceCounterEnabled = function (e) {\n        i.Tools.StartPerformanceCounter(e);\n      }, e.prototype._startPerformanceCounterDisabled = function (e) {}, e.prototype._endPerformanceCounterEnabled = function (e) {\n        i.Tools.EndPerformanceCounter(e);\n      }, e.prototype._endPerformanceCounterDisabled = function (e) {}, e.IncrementalLoading = !0, e.HomogeneousCoordinates = !1, e.magicBase64Encoded = \"Z2xURg\", e._logSpaces = \"                                \", e;\n    }();\n\n    i.SceneLoader && i.SceneLoader.RegisterPlugin(new l());\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"GLTFValidation\", function () {\n      return i;\n    });\n    var r = n(0);\n\n    function o(e, t, n, r) {\n      var o = {\n        externalResourceFunction: function externalResourceFunction(e) {\n          return r(e).then(function (e) {\n            return new Uint8Array(e);\n          });\n        }\n      };\n      return n && (o.uri = \"file:\" === t ? n : t + n), e instanceof ArrayBuffer ? GLTFValidator.validateBytes(new Uint8Array(e), o) : GLTFValidator.validateString(e, o);\n    }\n\n    function a() {\n      var e = [];\n\n      onmessage = function onmessage(t) {\n        var n = t.data;\n\n        switch (n.id) {\n          case \"init\":\n            importScripts(n.url);\n            break;\n\n          case \"validate\":\n            o(n.data, n.rootUrl, n.fileName, function (t) {\n              return new Promise(function (n, r) {\n                var o = e.length;\n                e.push({\n                  resolve: n,\n                  reject: r\n                }), postMessage({\n                  id: \"getExternalResource\",\n                  index: o,\n                  uri: t\n                });\n              });\n            }).then(function (e) {\n              postMessage({\n                id: \"validate.resolve\",\n                value: e\n              });\n            }, function (e) {\n              postMessage({\n                id: \"validate.reject\",\n                reason: e\n              });\n            });\n            break;\n\n          case \"getExternalResource.resolve\":\n            e[n.index].resolve(n.value);\n            break;\n\n          case \"getExternalResource.reject\":\n            e[n.index].reject(n.reason);\n        }\n      };\n    }\n\n    var i = function () {\n      function e() {}\n\n      return e.ValidateAsync = function (e, t, n, i) {\n        var s = this;\n        return \"function\" == typeof Worker ? new Promise(function (l, u) {\n          var c = o + \"(\" + a + \")()\",\n              d = URL.createObjectURL(new Blob([c], {\n            type: \"application/javascript\"\n          })),\n              f = new Worker(d),\n              h = function h(e) {\n            f.removeEventListener(\"error\", h), f.removeEventListener(\"message\", p), u(e);\n          },\n              p = function p(e) {\n            var t = e.data;\n\n            switch (t.id) {\n              case \"getExternalResource\":\n                i(t.uri).then(function (e) {\n                  f.postMessage({\n                    id: \"getExternalResource.resolve\",\n                    index: t.index,\n                    value: e\n                  }, [e]);\n                }, function (e) {\n                  f.postMessage({\n                    id: \"getExternalResource.reject\",\n                    index: t.index,\n                    reason: e\n                  });\n                });\n                break;\n\n              case \"validate.resolve\":\n                f.removeEventListener(\"error\", h), f.removeEventListener(\"message\", p), l(t.value);\n                break;\n\n              case \"validate.reject\":\n                f.removeEventListener(\"error\", h), f.removeEventListener(\"message\", p), u(t.reason);\n            }\n          };\n\n          f.addEventListener(\"error\", h), f.addEventListener(\"message\", p), f.postMessage({\n            id: \"init\",\n            url: r.Tools.GetAbsoluteUrl(s.Configuration.url)\n          }), f.postMessage({\n            id: \"validate\",\n            data: e,\n            rootUrl: t,\n            fileName: n\n          });\n        }) : (this._LoadScriptPromise || (this._LoadScriptPromise = r.Tools.LoadScriptAsync(this.Configuration.url)), this._LoadScriptPromise.then(function () {\n          return o(e, t, n, i);\n        }));\n      }, e.Configuration = {\n        url: \"https://preview.babylonjs.com/gltf_validator.js\"\n      }, e;\n    }();\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.d(t, \"b\", function () {\n      return o;\n    }), n.d(t, \"a\", function () {\n      return _a;\n    });\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation.\n    \n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted.\n    \n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    PERFORMANCE OF THIS SOFTWARE.\n    ***************************************************************************** */\n\n    var _r = function r(e, t) {\n      return (_r = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (e, t) {\n        e.__proto__ = t;\n      } || function (e, t) {\n        for (var n in t) {\n          Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n        }\n      })(e, t);\n    };\n\n    function o(e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n\n      function n() {\n        this.constructor = e;\n      }\n\n      _r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n    }\n\n    var _a = function a() {\n      return (_a = Object.assign || function (e) {\n        for (var t, n = 1, r = arguments.length; n < r; n++) {\n          for (var o in t = arguments[n]) {\n            Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n          }\n        }\n\n        return e;\n      }).apply(this, arguments);\n    };\n\n    Object.create;\n    Object.create;\n  }, function (e, t) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || new Function(\"return this\")();\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    e.exports = n;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t);\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"EXT_lights_image_based\", function () {\n      return i;\n    }), n.d(t, \"EXT_mesh_gpu_instancing\", function () {\n      return s;\n    }), n.d(t, \"EXT_texture_webp\", function () {\n      return l;\n    }), n.d(t, \"KHR_draco_mesh_compression\", function () {\n      return u;\n    }), n.d(t, \"KHR_lights\", function () {\n      return c;\n    }), n.d(t, \"KHR_materials_pbrSpecularGlossiness\", function () {\n      return d;\n    }), n.d(t, \"KHR_materials_unlit\", function () {\n      return f;\n    }), n.d(t, \"KHR_materials_clearcoat\", function () {\n      return h;\n    }), n.d(t, \"KHR_materials_sheen\", function () {\n      return p;\n    }), n.d(t, \"KHR_materials_specular\", function () {\n      return _;\n    }), n.d(t, \"KHR_materials_ior\", function () {\n      return m;\n    }), n.d(t, \"KHR_materials_variants\", function () {\n      return y;\n    }), n.d(t, \"KHR_materials_transmission\", function () {\n      return g;\n    }), n.d(t, \"KHR_materials_translucency\", function () {\n      return A;\n    }), n.d(t, \"KHR_mesh_quantization\", function () {\n      return T;\n    }), n.d(t, \"KHR_texture_basisu\", function () {\n      return x;\n    }), n.d(t, \"KHR_texture_transform\", function () {\n      return E;\n    }), n.d(t, \"MSFT_audio_emitter\", function () {\n      return L;\n    }), n.d(t, \"MSFT_lod\", function () {\n      return O;\n    }), n.d(t, \"MSFT_minecraftMesh\", function () {\n      return M;\n    }), n.d(t, \"MSFT_sRGBFactors\", function () {\n      return S;\n    }), n.d(t, \"ExtrasAsMetadata\", function () {\n      return w;\n    });\n\n    var r = n(0),\n        o = n(1),\n        a = \"EXT_lights_image_based\",\n        i = function () {\n      function e(e) {\n        this.name = a, this._loader = e, this.enabled = this._loader.isExtensionUsed(a);\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null, delete this._lights;\n      }, e.prototype.onLoading = function () {\n        var e = this._loader.gltf.extensions;\n\n        if (e && e[this.name]) {\n          var t = e[this.name];\n          this._lights = t.lights;\n        }\n      }, e.prototype.loadSceneAsync = function (e, t) {\n        var n = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (r, a) {\n          var i = new Array();\n          i.push(n._loader.loadSceneAsync(e, t)), n._loader.logOpen(\"\" + r);\n          var s = o.a.Get(r + \"/light\", n._lights, a.light);\n          return i.push(n._loadLightAsync(\"/extensions/\" + n.name + \"/lights/\" + a.light, s).then(function (e) {\n            n._loader.babylonScene.environmentTexture = e;\n          })), n._loader.logClose(), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadLightAsync = function (e, t) {\n        var n = this;\n\n        if (!t._loaded) {\n          var a = new Array();\n\n          this._loader.logOpen(\"\" + e);\n\n          for (var i = new Array(t.specularImages.length), s = function s(n) {\n            var r = t.specularImages[n];\n            i[n] = new Array(r.length);\n\n            for (var s = function s(t) {\n              var s = e + \"/specularImages/\" + n + \"/\" + t;\n\n              l._loader.logOpen(\"\" + s);\n\n              var u = r[t],\n                  c = o.a.Get(s, l._loader.gltf.images, u);\n              a.push(l._loader.loadImageAsync(\"/images/\" + u, c).then(function (e) {\n                i[n][t] = e;\n              })), l._loader.logClose();\n            }, u = 0; u < r.length; u++) {\n              s(u);\n            }\n          }, l = this, u = 0; u < t.specularImages.length; u++) {\n            s(u);\n          }\n\n          this._loader.logClose(), t._loaded = Promise.all(a).then(function () {\n            var e = new r.RawCubeTexture(n._loader.babylonScene, null, t.specularImageSize);\n\n            if (e.name = t.name || \"environment\", t._babylonTexture = e, null != t.intensity && (e.level = t.intensity), t.rotation) {\n              var o = r.Quaternion.FromArray(t.rotation);\n              n._loader.babylonScene.useRightHandedSystem || (o = r.Quaternion.Inverse(o)), r.Matrix.FromQuaternionToRef(o, e.getReflectionTextureMatrix());\n            }\n\n            var a = r.SphericalHarmonics.FromArray(t.irradianceCoefficients);\n            a.scaleInPlace(t.intensity), a.convertIrradianceToLambertianRadiance();\n            var s = r.SphericalPolynomial.FromHarmonics(a),\n                l = (i.length - 1) / r.Scalar.Log2(t.specularImageSize);\n            return e.updateRGBDAsync(i, s, l);\n          });\n        }\n\n        return t._loaded.then(function () {\n          return t._babylonTexture;\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(a, function (e) {\n      return new i(e);\n    });\n\n    var s = function () {\n      function e(e) {\n        this.name = \"EXT_mesh_gpu_instancing\", this._loader = e, this.enabled = this._loader.isExtensionUsed(\"EXT_mesh_gpu_instancing\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadNodeAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (e, i) {\n          a._loader._disableInstancedMesh++;\n\n          var s = a._loader.loadNodeAsync(\"/nodes/\" + t.index, t, n);\n\n          if (a._loader._disableInstancedMesh--, !t._primitiveBabylonMeshes) return s;\n\n          var l = new Array(),\n              u = 0,\n              c = function c(t) {\n            if (null != i.attributes[t]) {\n              var n = o.a.Get(e + \"/attributes/\" + t, a._loader.gltf.accessors, i.attributes[t]);\n              if (l.push(a._loader._loadFloatAccessorAsync(\"/accessors/\" + n.bufferView, n)), 0 === u) u = n.count;else if (u !== n.count) throw new Error(e + \"/attributes: Instance buffer accessors do not have the same count.\");\n            } else l.push(Promise.resolve(null));\n          };\n\n          return c(\"TRANSLATION\"), c(\"ROTATION\"), c(\"SCALE\"), s.then(function (e) {\n            return Promise.all(l).then(function (n) {\n              var o = n[0],\n                  a = n[1],\n                  i = n[2],\n                  s = new Float32Array(16 * u);\n              r.TmpVectors.Vector3[0].copyFromFloats(0, 0, 0), r.TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1), r.TmpVectors.Vector3[1].copyFromFloats(1, 1, 1);\n\n              for (var l = 0; l < u; ++l) {\n                o && r.Vector3.FromArrayToRef(o, 3 * l, r.TmpVectors.Vector3[0]), a && r.Quaternion.FromArrayToRef(a, 4 * l, r.TmpVectors.Quaternion[0]), i && r.Vector3.FromArrayToRef(i, 3 * l, r.TmpVectors.Vector3[1]), r.Matrix.ComposeToRef(r.TmpVectors.Vector3[1], r.TmpVectors.Quaternion[0], r.TmpVectors.Vector3[0], r.TmpVectors.Matrix[0]), r.TmpVectors.Matrix[0].copyToArray(s, 16 * l);\n              }\n\n              for (var c = 0, d = t._primitiveBabylonMeshes; c < d.length; c++) {\n                d[c].thinInstanceSetBuffer(\"matrix\", s, 16, !0);\n              }\n\n              return e;\n            });\n          });\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"EXT_mesh_gpu_instancing\", function (e) {\n      return new s(e);\n    });\n\n    var l = function () {\n      function e(e) {\n        this.name = \"EXT_texture_webp\", this._loader = e, this.enabled = e.isExtensionUsed(\"EXT_texture_webp\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype._loadTextureAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (a, i) {\n          var s = null == t.sampler ? o.b.DefaultSampler : o.a.Get(e + \"/sampler\", r._loader.gltf.samplers, t.sampler),\n              l = o.a.Get(a + \"/source\", r._loader.gltf.images, i.source);\n          return r._loader._createTextureAsync(e, s, l, function (e) {\n            n(e);\n          });\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"EXT_texture_webp\", function (e) {\n      return new l(e);\n    });\n\n    var u = function () {\n      function e(e) {\n        this.name = \"KHR_draco_mesh_compression\", this._loader = e, this.enabled = r.DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(\"KHR_draco_mesh_compression\");\n      }\n\n      return e.prototype.dispose = function () {\n        delete this.dracoCompression, this._loader = null;\n      }, e.prototype._loadVertexDataAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (i, s) {\n          if (null != t.mode) {\n            if (5 !== t.mode && 4 !== t.mode) throw new Error(e + \": Unsupported mode \" + t.mode);\n            if (5 === t.mode) throw new Error(e + \": Mode \" + t.mode + \" is not currently supported\");\n          }\n\n          var l = {},\n              u = function u(e, t) {\n            var r = s.attributes[e];\n            null != r && (n._delayInfo = n._delayInfo || [], -1 === n._delayInfo.indexOf(t) && n._delayInfo.push(t), l[t] = r);\n          };\n\n          u(\"POSITION\", r.VertexBuffer.PositionKind), u(\"NORMAL\", r.VertexBuffer.NormalKind), u(\"TANGENT\", r.VertexBuffer.TangentKind), u(\"TEXCOORD_0\", r.VertexBuffer.UVKind), u(\"TEXCOORD_1\", r.VertexBuffer.UV2Kind), u(\"JOINTS_0\", r.VertexBuffer.MatricesIndicesKind), u(\"WEIGHTS_0\", r.VertexBuffer.MatricesWeightsKind), u(\"COLOR_0\", r.VertexBuffer.ColorKind);\n          var c = o.a.Get(i, a._loader.gltf.bufferViews, s.bufferView);\n          return c._dracoBabylonGeometry || (c._dracoBabylonGeometry = a._loader.loadBufferViewAsync(\"/bufferViews/\" + c.index, c).then(function (t) {\n            return (a.dracoCompression || r.DracoCompression.Default).decodeMeshAsync(t, l).then(function (e) {\n              var t = new r.Geometry(n.name, a._loader.babylonScene);\n              return e.applyToGeometry(t), t;\n            }).catch(function (t) {\n              throw new Error(e + \": \" + t.message);\n            });\n          })), c._dracoBabylonGeometry;\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_draco_mesh_compression\", function (e) {\n      return new u(e);\n    });\n\n    var c = function () {\n      function e(e) {\n        this.name = \"KHR_lights_punctual\", this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_lights_punctual\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null, delete this._lights;\n      }, e.prototype.onLoading = function () {\n        var e = this._loader.gltf.extensions;\n\n        if (e && e[this.name]) {\n          var t = e[this.name];\n          this._lights = t.lights;\n        }\n      }, e.prototype.loadNodeAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (i, s) {\n          return a._loader.loadNodeAsync(e, t, function (e) {\n            var t,\n                l = o.a.Get(i, a._lights, s.light),\n                u = l.name || e.name;\n\n            switch (a._loader.babylonScene._blockEntityCollection = a._loader._forAssetContainer, l.type) {\n              case \"directional\":\n                t = new r.DirectionalLight(u, r.Vector3.Backward(), a._loader.babylonScene);\n                break;\n\n              case \"point\":\n                t = new r.PointLight(u, r.Vector3.Zero(), a._loader.babylonScene);\n                break;\n\n              case \"spot\":\n                var c = new r.SpotLight(u, r.Vector3.Zero(), r.Vector3.Backward(), 0, 1, a._loader.babylonScene);\n                c.angle = 2 * (l.spot && l.spot.outerConeAngle || Math.PI / 4), c.innerAngle = 2 * (l.spot && l.spot.innerConeAngle || 0), t = c;\n                break;\n\n              default:\n                throw a._loader.babylonScene._blockEntityCollection = !1, new Error(i + \": Invalid light type (\" + l.type + \")\");\n            }\n\n            a._loader.babylonScene._blockEntityCollection = !1, t.falloffType = r.Light.FALLOFF_GLTF, t.diffuse = l.color ? r.Color3.FromArray(l.color) : r.Color3.White(), t.intensity = null == l.intensity ? 1 : l.intensity, t.range = null == l.range ? Number.MAX_VALUE : l.range, t.parent = e, a._loader._babylonLights.push(t), o.b.AddPointerMetadata(t, i), n(e);\n          });\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_lights_punctual\", function (e) {\n      return new c(e);\n    });\n\n    var d = function () {\n      function e(e) {\n        this.name = \"KHR_materials_pbrSpecularGlossiness\", this.order = 200, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_pbrSpecularGlossiness\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, a) {\n          var i = new Array();\n          return i.push(r._loader.loadMaterialBasePropertiesAsync(e, t, n)), i.push(r._loadSpecularGlossinessPropertiesAsync(o, t, a, n)), r._loader.loadMaterialAlphaProperties(e, t, n), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadSpecularGlossinessPropertiesAsync = function (e, t, n, o) {\n        if (!(o instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var a = new Array();\n        return o.metallic = null, o.roughness = null, n.diffuseFactor ? (o.albedoColor = r.Color3.FromArray(n.diffuseFactor), o.alpha = n.diffuseFactor[3]) : o.albedoColor = r.Color3.White(), o.reflectivityColor = n.specularFactor ? r.Color3.FromArray(n.specularFactor) : r.Color3.White(), o.microSurface = null == n.glossinessFactor ? 1 : n.glossinessFactor, n.diffuseTexture && a.push(this._loader.loadTextureInfoAsync(e + \"/diffuseTexture\", n.diffuseTexture, function (e) {\n          e.name = o.name + \" (Diffuse)\", o.albedoTexture = e;\n        })), n.specularGlossinessTexture && (n.specularGlossinessTexture.nonColorData = !0, a.push(this._loader.loadTextureInfoAsync(e + \"/specularGlossinessTexture\", n.specularGlossinessTexture, function (e) {\n          e.name = o.name + \" (Specular Glossiness)\", o.reflectivityTexture = e;\n        })), o.reflectivityTexture.hasAlpha = !0, o.useMicroSurfaceFromReflectivityMapAlpha = !0), Promise.all(a).then(function () {});\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_pbrSpecularGlossiness\", function (e) {\n      return new d(e);\n    });\n\n    var f = function () {\n      function e(e) {\n        this.name = \"KHR_materials_unlit\", this.order = 210, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_unlit\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function () {\n          return r._loadUnlitPropertiesAsync(e, t, n);\n        });\n      }, e.prototype._loadUnlitPropertiesAsync = function (e, t, n) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var o = new Array();\n        n.unlit = !0;\n        var a = t.pbrMetallicRoughness;\n        return a && (a.baseColorFactor ? (n.albedoColor = r.Color3.FromArray(a.baseColorFactor), n.alpha = a.baseColorFactor[3]) : n.albedoColor = r.Color3.White(), a.baseColorTexture && o.push(this._loader.loadTextureInfoAsync(e + \"/baseColorTexture\", a.baseColorTexture, function (e) {\n          e.name = n.name + \" (Base Color)\", n.albedoTexture = e;\n        }))), t.doubleSided && (n.backFaceCulling = !1, n.twoSidedLighting = !0), this._loader.loadMaterialAlphaProperties(e, t, n), Promise.all(o).then(function () {});\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_unlit\", function (e) {\n      return new f(e);\n    });\n\n    var h = function () {\n      function e(e) {\n        this.name = \"KHR_materials_clearcoat\", this.order = 190, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_clearcoat\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, a) {\n          var i = new Array();\n          return i.push(r._loader.loadMaterialPropertiesAsync(e, t, n)), i.push(r._loadClearCoatPropertiesAsync(o, a, n)), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadClearCoatPropertiesAsync = function (e, t, n) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var o = new Array();\n        return n.clearCoat.isEnabled = !0, n.clearCoat.useRoughnessFromMainTexture = !1, n.clearCoat.remapF0OnInterfaceChange = !1, null != t.clearcoatFactor ? n.clearCoat.intensity = t.clearcoatFactor : n.clearCoat.intensity = 0, t.clearcoatTexture && o.push(this._loader.loadTextureInfoAsync(e + \"/clearcoatTexture\", t.clearcoatTexture, function (e) {\n          e.name = n.name + \" (ClearCoat Intensity)\", n.clearCoat.texture = e;\n        })), null != t.clearcoatRoughnessFactor ? n.clearCoat.roughness = t.clearcoatRoughnessFactor : n.clearCoat.roughness = 0, t.clearcoatRoughnessTexture && (t.clearcoatRoughnessTexture.nonColorData = !0, o.push(this._loader.loadTextureInfoAsync(e + \"/clearcoatRoughnessTexture\", t.clearcoatRoughnessTexture, function (e) {\n          e.name = n.name + \" (ClearCoat Roughness)\", n.clearCoat.textureRoughness = e;\n        }))), t.clearcoatNormalTexture && (t.clearcoatNormalTexture.nonColorData = !0, o.push(this._loader.loadTextureInfoAsync(e + \"/clearcoatNormalTexture\", t.clearcoatNormalTexture, function (e) {\n          e.name = n.name + \" (ClearCoat Normal)\", n.clearCoat.bumpTexture = e;\n        })), n.invertNormalMapX = !n.getScene().useRightHandedSystem, n.invertNormalMapY = n.getScene().useRightHandedSystem, null != t.clearcoatNormalTexture.scale && (n.clearCoat.bumpTexture.level = t.clearcoatNormalTexture.scale)), Promise.all(o).then(function () {});\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_clearcoat\", function (e) {\n      return new h(e);\n    });\n\n    var p = function () {\n      function e(e) {\n        this.name = \"KHR_materials_sheen\", this.order = 190, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_sheen\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, a) {\n          var i = new Array();\n          return i.push(r._loader.loadMaterialPropertiesAsync(e, t, n)), i.push(r._loadSheenPropertiesAsync(o, a, n)), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadSheenPropertiesAsync = function (e, t, n) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var o = new Array();\n        return n.sheen.isEnabled = !0, n.sheen.intensity = 1, null != t.sheenColorFactor ? n.sheen.color = r.Color3.FromArray(t.sheenColorFactor) : n.sheen.color = r.Color3.Black(), t.sheenColorTexture && o.push(this._loader.loadTextureInfoAsync(e + \"/sheenColorTexture\", t.sheenColorTexture, function (e) {\n          e.name = n.name + \" (Sheen Color)\", n.sheen.texture = e;\n        })), void 0 !== t.sheenRoughnessFactor ? n.sheen.roughness = t.sheenRoughnessFactor : n.sheen.roughness = 0, t.sheenRoughnessTexture && (t.sheenRoughnessTexture.nonColorData = !0, o.push(this._loader.loadTextureInfoAsync(e + \"/sheenRoughnessTexture\", t.sheenRoughnessTexture, function (e) {\n          e.name = n.name + \" (Sheen Roughness)\", n.sheen.textureRoughness = e;\n        }))), n.sheen.albedoScaling = !0, n.sheen.useRoughnessFromMainTexture = !1, Promise.all(o).then(function () {});\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_sheen\", function (e) {\n      return new p(e);\n    });\n\n    var _ = function () {\n      function e(e) {\n        this.name = \"KHR_materials_specular\", this.order = 190, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_specular\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, a) {\n          var i = new Array();\n          return i.push(r._loader.loadMaterialPropertiesAsync(e, t, n)), i.push(r._loadSpecularPropertiesAsync(o, a, n)), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadSpecularPropertiesAsync = function (e, t, n) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var o = new Array();\n        return void 0 !== t.specularFactor && (n.metallicF0Factor = t.specularFactor), void 0 !== t.specularColorFactor && (n.metallicReflectanceColor = r.Color3.FromArray(t.specularColorFactor)), t.specularTexture && (t.specularTexture.nonColorData = !0, o.push(this._loader.loadTextureInfoAsync(e + \"/specularTexture\", t.specularTexture, function (e) {\n          e.name = n.name + \" (Specular F0 Color)\", n.metallicReflectanceTexture = e;\n        }))), Promise.all(o).then(function () {});\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_specular\", function (e) {\n      return new _(e);\n    });\n\n    var m = function () {\n      function e(e) {\n        this.name = \"KHR_materials_ior\", this.order = 180, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_ior\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, a) {\n          var i = new Array();\n          return i.push(r._loader.loadMaterialPropertiesAsync(e, t, n)), i.push(r._loadIorPropertiesAsync(o, a, n)), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadIorPropertiesAsync = function (t, n, o) {\n        if (!(o instanceof r.PBRMaterial)) throw new Error(t + \": Material type not supported\");\n        return void 0 !== n.ior ? o.indexOfRefraction = n.ior : o.indexOfRefraction = e._DEFAULT_IOR, Promise.resolve();\n      }, e._DEFAULT_IOR = 1.5, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_ior\", function (e) {\n      return new m(e);\n    });\n\n    var y = function () {\n      function e(e) {\n        this.name = \"KHR_materials_variants\", this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_variants\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.GetAvailableVariants = function (e) {\n        var t = this._GetExtensionMetadata(e);\n\n        return t ? Object.keys(t.variants) : [];\n      }, e.prototype.getAvailableVariants = function (t) {\n        return e.GetAvailableVariants(t);\n      }, e.SelectVariant = function (e, t) {\n        var n = this._GetExtensionMetadata(e);\n\n        if (!n) throw new Error(\"Cannot select variant on a glTF mesh that does not have the KHR_materials_variants extension\");\n\n        var r = function r(e) {\n          var t = n.variants[e];\n          if (t) for (var r = 0, o = t; r < o.length; r++) {\n            var a = o[r];\n            a.mesh.material = a.material;\n          }\n        };\n\n        if (t instanceof Array) for (var o = 0, a = t; o < a.length; o++) {\n          r(a[o]);\n        } else r(t);\n        n.lastSelected = t;\n      }, e.prototype.selectVariant = function (t, n) {\n        return e.SelectVariant(t, n);\n      }, e.Reset = function (e) {\n        var t = this._GetExtensionMetadata(e);\n\n        if (!t) throw new Error(\"Cannot reset on a glTF mesh that does not have the KHR_materials_variants extension\");\n\n        for (var n = 0, r = t.original; n < r.length; n++) {\n          var o = r[n];\n          o.mesh.material = o.material;\n        }\n\n        t.lastSelected = null;\n      }, e.prototype.reset = function (t) {\n        return e.Reset(t);\n      }, e.GetLastSelectedVariant = function (e) {\n        var t = this._GetExtensionMetadata(e);\n\n        if (!t) throw new Error(\"Cannot get the last selected variant on a glTF mesh that does not have the KHR_materials_variants extension\");\n        return t.lastSelected;\n      }, e.prototype.getLastSelectedVariant = function (t) {\n        return e.GetLastSelectedVariant(t);\n      }, e._GetExtensionMetadata = function (e) {\n        var t, n;\n        return (null === (n = null === (t = null == e ? void 0 : e.metadata) || void 0 === t ? void 0 : t.gltf) || void 0 === n ? void 0 : n.KHR_materials_variants) || null;\n      }, e.prototype.onLoading = function () {\n        var e = this._loader.gltf.extensions;\n\n        if (e && e[this.name]) {\n          var t = e[this.name];\n          this._variants = t.variants;\n        }\n      }, e.prototype._loadMeshPrimitiveAsync = function (e, t, n, a, i, s) {\n        var l = this;\n        return o.b.LoadExtensionAsync(e, i, this.name, function (u, c) {\n          var d = new Array();\n          return d.push(l._loader._loadMeshPrimitiveAsync(e, t, n, a, i, function (t) {\n            if (s(t), t instanceof r.Mesh) {\n              var n = o.b._GetDrawMode(e, i.mode),\n                  a = l._loader.rootBabylonMesh,\n                  f = a.metadata = a.metadata || {},\n                  h = f.gltf = f.gltf || {},\n                  p = h.KHR_materials_variants = h.KHR_materials_variants || {\n                lastSelected: null,\n                original: [],\n                variants: {}\n              };\n\n              p.original.push({\n                mesh: t,\n                material: t.material\n              });\n\n              for (var _ = p.variants, m = 0, y = c.mappings; m < y.length; m++) {\n                for (var b = y[m], v = function v(e) {\n                  var r = o.a.Get(u + \"/mapping/\" + e, l._variants, e),\n                      a = o.a.Get(\"#/materials/\", l._loader.gltf.materials, b.material);\n                  d.push(l._loader._loadMaterialAsync(\"#/materials/\" + b.material, a, t, n, function (e) {\n                    _[r.name] = _[r.name] || [], _[r.name].push({\n                      mesh: t,\n                      material: e\n                    });\n                  }));\n                }, g = 0, A = b.variants; g < A.length; g++) {\n                  v(A[g]);\n                }\n              }\n            }\n          })), Promise.all(d).then(function (e) {\n            return e[0];\n          });\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_variants\", function (e) {\n      return new y(e);\n    });\n\n    var b = n(4),\n        v = function () {\n      function e(t, n) {\n        var o = this;\n        this._opaqueRenderTarget = null, this._opaqueMeshesCache = [], this._transparentMeshesCache = [], this._options = Object(b.a)(Object(b.a)({}, e._getDefaultOptions()), t), this._scene = n, this._scene._transmissionHelper = this, this.onErrorObservable = new r.Observable(), this._scene.onDisposeObservable.addOnce(function (e) {\n          o.dispose();\n        }), this._parseScene(), this._setupRenderTargets();\n      }\n\n      return e._getDefaultOptions = function () {\n        return {\n          renderSize: 512\n        };\n      }, e.prototype.updateOptions = function (e) {\n        var t = this;\n\n        if (Object.keys(e).filter(function (n) {\n          return t._options[n] !== e[n];\n        }).length) {\n          var n = Object(b.a)(Object(b.a)({}, this._options), e),\n              r = this._options;\n          this._options = n, n.renderSize !== r.renderSize && this._setupRenderTargets();\n        }\n      }, e.prototype.getOpaqueTarget = function () {\n        return this._opaqueRenderTarget;\n      }, e.prototype.shouldRenderAsTransmission = function (e) {\n        return !!e && !!(e instanceof r.PBRMaterial && e.subSurface.isRefractionEnabled);\n      }, e.prototype._addMesh = function (e) {\n        e instanceof r.Mesh && (e.onMaterialChangedObservable.add(this.onMeshMaterialChanged.bind(this)), this.shouldRenderAsTransmission(e.material) ? this._transparentMeshesCache.push(e) : this._opaqueMeshesCache.push(e));\n      }, e.prototype._removeMesh = function (e) {\n        if (e instanceof r.Mesh) {\n          e.onMaterialChangedObservable.remove(this.onMeshMaterialChanged.bind(this));\n\n          var t = this._transparentMeshesCache.indexOf(e);\n\n          -1 !== t && this._transparentMeshesCache.splice(t, 1), -1 !== (t = this._opaqueMeshesCache.indexOf(e)) && this._opaqueMeshesCache.splice(t, 1);\n        }\n      }, e.prototype._parseScene = function () {\n        this._scene.meshes.forEach(this._addMesh.bind(this)), this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)), this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\n      }, e.prototype.onMeshMaterialChanged = function (e) {\n        if (e instanceof r.Mesh) {\n          var t = this._transparentMeshesCache.indexOf(e),\n              n = this._opaqueMeshesCache.indexOf(e);\n\n          this.shouldRenderAsTransmission(e.material) ? (e.material instanceof r.PBRMaterial && (e.material.subSurface.refractionTexture = this._opaqueRenderTarget), -1 !== n ? (this._opaqueMeshesCache.splice(n, 1), this._transparentMeshesCache.push(e)) : -1 === t && this._transparentMeshesCache.push(e)) : -1 !== t ? (this._transparentMeshesCache.splice(t, 1), this._opaqueMeshesCache.push(e)) : -1 === n && this._opaqueMeshesCache.push(e);\n        }\n      }, e.prototype._setupRenderTargets = function () {\n        var e = this,\n            t = -1;\n        if (this._scene.layers && this._opaqueRenderTarget) for (var n = 0, o = this._scene.layers; n < o.length; n++) {\n          var a = (l = o[n]).renderTargetTextures.indexOf(this._opaqueRenderTarget);\n          a >= 0 && l.renderTargetTextures.splice(a, 1);\n        }\n        if (this._opaqueRenderTarget && (t = this._scene.customRenderTargets.indexOf(this._opaqueRenderTarget), this._opaqueRenderTarget.dispose()), this._opaqueRenderTarget = new r.RenderTargetTexture(\"opaqueSceneTexture\", this._options.renderSize, this._scene, !0), this._opaqueRenderTarget.renderList = this._opaqueMeshesCache, this._opaqueRenderTarget.gammaSpace = !0, this._opaqueRenderTarget.lodGenerationScale = 1, this._opaqueRenderTarget.lodGenerationOffset = -4, t >= 0 ? this._scene.customRenderTargets.splice(t, 0, this._opaqueRenderTarget) : (t = this._scene.customRenderTargets.length, this._scene.customRenderTargets.push(this._opaqueRenderTarget)), this._scene.layers && this._opaqueRenderTarget) for (var i = 0, s = this._scene.layers; i < s.length; i++) {\n          var l;\n          (l = s[i]).renderTargetTextures.push(this._opaqueRenderTarget);\n        }\n\n        this._transparentMeshesCache.forEach(function (t) {\n          e.shouldRenderAsTransmission(t.material) && t.material instanceof r.PBRMaterial && (t.material.refractionTexture = e._opaqueRenderTarget);\n        });\n      }, e.prototype.dispose = function () {\n        this._scene._transmissionHelper = void 0, this._opaqueRenderTarget && (this._opaqueRenderTarget.dispose(), this._opaqueRenderTarget = null), this._transparentMeshesCache = [], this._opaqueMeshesCache = [];\n      }, e;\n    }(),\n        g = function () {\n      function e(e) {\n        this.name = \"KHR_materials_transmission\", this.order = 175, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_transmission\"), this.enabled && (e.parent.transparencyAsCoverage = !0);\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, a) {\n          var i = new Array();\n          return i.push(r._loader.loadMaterialBasePropertiesAsync(e, t, n)), i.push(r._loader.loadMaterialPropertiesAsync(e, t, n)), i.push(r._loadTransparentPropertiesAsync(o, t, n, a)), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadTransparentPropertiesAsync = function (e, t, n, o) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var a = n;\n        if (a.subSurface.isRefractionEnabled = !0, a.subSurface.volumeIndexOfRefraction = 1, a.subSurface.useAlbedoToTintRefraction = !0, void 0 === o.transmissionFactor) return a.subSurface.refractionIntensity = 0, a.subSurface.isRefractionEnabled = !1, Promise.resolve();\n        a.subSurface.refractionIntensity = o.transmissionFactor;\n        var i = a.getScene();\n        return a.subSurface.refractionIntensity && !i._transmissionHelper && new v({}, a.getScene()), o.transmissionTexture ? (o.transmissionTexture.nonColorData = !0, this._loader.loadTextureInfoAsync(e + \"/transmissionTexture\", o.transmissionTexture, void 0).then(function (e) {\n          a.subSurface.thicknessTexture = e, a.subSurface.useMaskFromThicknessTextureGltf = !0;\n        })) : Promise.resolve();\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_transmission\", function (e) {\n      return new g(e);\n    });\n\n    var A = function () {\n      function e(e) {\n        this.name = \"KHR_materials_translucency\", this.order = 175, this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_materials_translucency\"), this.enabled && (e.parent.transparencyAsCoverage = !0);\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, a) {\n          var i = new Array();\n          return i.push(r._loader.loadMaterialBasePropertiesAsync(e, t, n)), i.push(r._loader.loadMaterialPropertiesAsync(e, t, n)), i.push(r._loadTranslucentPropertiesAsync(o, t, n, a)), Promise.all(i).then(function () {});\n        });\n      }, e.prototype._loadTranslucentPropertiesAsync = function (e, t, n, o) {\n        if (!(n instanceof r.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var a = n;\n        return a.subSurface.isTranslucencyEnabled = !0, a.subSurface.volumeIndexOfRefraction = 1, a.subSurface.minimumThickness = 0, a.subSurface.maximumThickness = 0, a.subSurface.useAlbedoToTintRefraction = !0, void 0 === o.translucencyFactor ? (a.subSurface.translucencyIntensity = 0, a.subSurface.isTranslucencyEnabled = !1, Promise.resolve()) : (a.subSurface.translucencyIntensity = o.translucencyFactor, o.translucencyTexture ? this._loader.loadTextureInfoAsync(e + \"/translucencyTexture\", o.translucencyTexture).then(function (e) {\n          a.subSurface.thicknessTexture = e, a.subSurface.useMaskFromThicknessTextureGltf = !0;\n        }) : Promise.resolve());\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_materials_translucency\", function (e) {\n      return new A(e);\n    });\n\n    var T = function () {\n      function e(e) {\n        this.name = \"KHR_mesh_quantization\", this.enabled = e.isExtensionUsed(\"KHR_mesh_quantization\");\n      }\n\n      return e.prototype.dispose = function () {}, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_mesh_quantization\", function (e) {\n      return new T(e);\n    });\n\n    var x = function () {\n      function e(e) {\n        this.name = \"KHR_texture_basisu\", this._loader = e, this.enabled = e.isExtensionUsed(\"KHR_texture_basisu\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype._loadTextureAsync = function (e, t, n) {\n        var r = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (a, i) {\n          var s = null == t.sampler ? o.b.DefaultSampler : o.a.Get(e + \"/sampler\", r._loader.gltf.samplers, t.sampler),\n              l = o.a.Get(a + \"/source\", r._loader.gltf.images, i.source);\n          return r._loader._createTextureAsync(e, s, l, function (e) {\n            n(e);\n          }, t._textureInfo.nonColorData ? {\n            useRGBAIfASTCBC7NotAvailableWhenUASTC: !0\n          } : void 0);\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_texture_basisu\", function (e) {\n      return new x(e);\n    });\n\n    var E = function () {\n      function e(e) {\n        this.name = \"KHR_texture_transform\", this._loader = e, this.enabled = this._loader.isExtensionUsed(\"KHR_texture_transform\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadTextureInfoAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (o, i) {\n          return a._loader.loadTextureInfoAsync(e, t, function (e) {\n            if (!(e instanceof r.Texture)) throw new Error(o + \": Texture type not supported\");\n            i.offset && (e.uOffset = i.offset[0], e.vOffset = i.offset[1]), e.uRotationCenter = 0, e.vRotationCenter = 0, i.rotation && (e.wAng = -i.rotation), i.scale && (e.uScale = i.scale[0], e.vScale = i.scale[1]), null != i.texCoord && (e.coordinatesIndex = i.texCoord), n(e);\n          });\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"KHR_texture_transform\", function (e) {\n      return new E(e);\n    });\n\n    var L = function () {\n      function e(e) {\n        this.name = \"MSFT_audio_emitter\", this._loader = e, this.enabled = this._loader.isExtensionUsed(\"MSFT_audio_emitter\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null, this._clips = null, this._emitters = null;\n      }, e.prototype.onLoading = function () {\n        var e = this._loader.gltf.extensions;\n\n        if (e && e[this.name]) {\n          var t = e[this.name];\n          this._clips = t.clips, this._emitters = t.emitters, o.a.Assign(this._clips), o.a.Assign(this._emitters);\n        }\n      }, e.prototype.loadSceneAsync = function (e, t) {\n        var n = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (r, a) {\n          var i = new Array();\n          i.push(n._loader.loadSceneAsync(e, t));\n\n          for (var s = 0, l = a.emitters; s < l.length; s++) {\n            var u = l[s],\n                c = o.a.Get(r + \"/emitters\", n._emitters, u);\n            if (null != c.refDistance || null != c.maxDistance || null != c.rolloffFactor || null != c.distanceModel || null != c.innerAngle || null != c.outerAngle) throw new Error(r + \": Direction or Distance properties are not allowed on emitters attached to a scene\");\n            i.push(n._loadEmitterAsync(r + \"/emitters/\" + c.index, c));\n          }\n\n          return Promise.all(i).then(function () {});\n        });\n      }, e.prototype.loadNodeAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (e, i) {\n          var s = new Array();\n          return a._loader.loadNodeAsync(e, t, function (t) {\n            for (var l = function l(n) {\n              var i = o.a.Get(e + \"/emitters\", a._emitters, n);\n              s.push(a._loadEmitterAsync(e + \"/emitters/\" + i.index, i).then(function () {\n                for (var e = 0, n = i._babylonSounds; e < n.length; e++) {\n                  var o = n[e];\n                  o.attachToMesh(t), null == i.innerAngle && null == i.outerAngle || (o.setLocalDirectionToMesh(r.Vector3.Forward()), o.setDirectionalCone(2 * r.Tools.ToDegrees(null == i.innerAngle ? Math.PI : i.innerAngle), 2 * r.Tools.ToDegrees(null == i.outerAngle ? Math.PI : i.outerAngle), 0));\n                }\n              }));\n            }, u = 0, c = i.emitters; u < c.length; u++) {\n              l(c[u]);\n            }\n\n            n(t);\n          }).then(function (e) {\n            return Promise.all(s).then(function () {\n              return e;\n            });\n          });\n        });\n      }, e.prototype.loadAnimationAsync = function (e, t) {\n        var n = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (r, a) {\n          return n._loader.loadAnimationAsync(e, t).then(function (i) {\n            var s = new Array();\n            o.a.Assign(a.events);\n\n            for (var l = 0, u = a.events; l < u.length; l++) {\n              var c = u[l];\n              s.push(n._loadAnimationEventAsync(r + \"/events/\" + c.index, e, t, c, i));\n            }\n\n            return Promise.all(s).then(function () {\n              return i;\n            });\n          });\n        });\n      }, e.prototype._loadClipAsync = function (e, t) {\n        if (t._objectURL) return t._objectURL;\n        var n;\n        if (t.uri) n = this._loader.loadUriAsync(e, t, t.uri);else {\n          var r = o.a.Get(e + \"/bufferView\", this._loader.gltf.bufferViews, t.bufferView);\n          n = this._loader.loadBufferViewAsync(\"/bufferViews/\" + r.index, r);\n        }\n        return t._objectURL = n.then(function (e) {\n          return URL.createObjectURL(new Blob([e], {\n            type: t.mimeType\n          }));\n        }), t._objectURL;\n      }, e.prototype._loadEmitterAsync = function (e, t) {\n        var n = this;\n\n        if (t._babylonSounds = t._babylonSounds || [], !t._babylonData) {\n          for (var a = new Array(), i = t.name || \"emitter\" + t.index, s = {\n            loop: !1,\n            autoplay: !1,\n            volume: null == t.volume ? 1 : t.volume\n          }, l = function l(e) {\n            var l = \"/extensions/\" + u.name + \"/clips\",\n                c = o.a.Get(l, u._clips, t.clips[e].clip);\n            a.push(u._loadClipAsync(l + \"/\" + t.clips[e].clip, c).then(function (o) {\n              var a = t._babylonSounds[e] = new r.Sound(i, o, n._loader.babylonScene, null, s);\n              a.refDistance = t.refDistance || 1, a.maxDistance = t.maxDistance || 256, a.rolloffFactor = t.rolloffFactor || 1, a.distanceModel = t.distanceModel || \"exponential\", a._positionInEmitterSpace = !0;\n            }));\n          }, u = this, c = 0; c < t.clips.length; c++) {\n            l(c);\n          }\n\n          var d = Promise.all(a).then(function () {\n            var e = t.clips.map(function (e) {\n              return e.weight || 1;\n            }),\n                n = new r.WeightedSound(t.loop || !1, t._babylonSounds, e);\n            t.innerAngle && (n.directionalConeInnerAngle = 2 * r.Tools.ToDegrees(t.innerAngle)), t.outerAngle && (n.directionalConeOuterAngle = 2 * r.Tools.ToDegrees(t.outerAngle)), t.volume && (n.volume = t.volume), t._babylonData.sound = n;\n          });\n          t._babylonData = {\n            loaded: d\n          };\n        }\n\n        return t._babylonData.loaded;\n      }, e.prototype._getEventAction = function (e, t, n, r, o) {\n        switch (n) {\n          case \"play\":\n            return function (e) {\n              var n = (o || 0) + (e - r);\n              t.play(n);\n            };\n\n          case \"stop\":\n            return function (e) {\n              t.stop();\n            };\n\n          case \"pause\":\n            return function (e) {\n              t.pause();\n            };\n\n          default:\n            throw new Error(e + \": Unsupported action \" + n);\n        }\n      }, e.prototype._loadAnimationEventAsync = function (e, t, n, a, i) {\n        var s = this;\n        if (0 == i.targetedAnimations.length) return Promise.resolve();\n        var l = i.targetedAnimations[0],\n            u = a.emitter,\n            c = o.a.Get(\"/extensions/\" + this.name + \"/emitters\", this._emitters, u);\n        return this._loadEmitterAsync(e, c).then(function () {\n          var t = c._babylonData.sound;\n\n          if (t) {\n            var n = new r.AnimationEvent(a.time, s._getEventAction(e, t, a.action, a.time, a.startOffset));\n            l.animation.addEvent(n), i.onAnimationGroupEndObservable.add(function () {\n              t.stop();\n            }), i.onAnimationGroupPauseObservable.add(function () {\n              t.pause();\n            });\n          }\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"MSFT_audio_emitter\", function (e) {\n      return new L(e);\n    });\n\n    var O = function () {\n      function e(e) {\n        this.name = \"MSFT_lod\", this.order = 100, this.maxLODsToLoad = 10, this.onNodeLODsLoadedObservable = new r.Observable(), this.onMaterialLODsLoadedObservable = new r.Observable(), this._bufferLODs = new Array(), this._nodeIndexLOD = null, this._nodeSignalLODs = new Array(), this._nodePromiseLODs = new Array(), this._nodeBufferLODs = new Array(), this._materialIndexLOD = null, this._materialSignalLODs = new Array(), this._materialPromiseLODs = new Array(), this._materialBufferLODs = new Array(), this._loader = e, this.enabled = this._loader.isExtensionUsed(\"MSFT_lod\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null, this._nodeIndexLOD = null, this._nodeSignalLODs.length = 0, this._nodePromiseLODs.length = 0, this._nodeBufferLODs.length = 0, this._materialIndexLOD = null, this._materialSignalLODs.length = 0, this._materialPromiseLODs.length = 0, this._materialBufferLODs.length = 0, this.onMaterialLODsLoadedObservable.clear(), this.onNodeLODsLoadedObservable.clear();\n      }, e.prototype.onReady = function () {\n        for (var e = this, t = function t(_t) {\n          var r = Promise.all(n._nodePromiseLODs[_t]).then(function () {\n            0 !== _t && (e._loader.endPerformanceCounter(\"Node LOD \" + _t), e._loader.log(\"Loaded node LOD \" + _t)), e.onNodeLODsLoadedObservable.notifyObservers(_t), _t !== e._nodePromiseLODs.length - 1 && (e._loader.startPerformanceCounter(\"Node LOD \" + (_t + 1)), e._loadBufferLOD(e._nodeBufferLODs, _t + 1), e._nodeSignalLODs[_t] && e._nodeSignalLODs[_t].resolve());\n          });\n\n          n._loader._completePromises.push(r);\n        }, n = this, r = 0; r < this._nodePromiseLODs.length; r++) {\n          t(r);\n        }\n\n        var o = function o(t) {\n          var n = Promise.all(a._materialPromiseLODs[t]).then(function () {\n            0 !== t && (e._loader.endPerformanceCounter(\"Material LOD \" + t), e._loader.log(\"Loaded material LOD \" + t)), e.onMaterialLODsLoadedObservable.notifyObservers(t), t !== e._materialPromiseLODs.length - 1 && (e._loader.startPerformanceCounter(\"Material LOD \" + (t + 1)), e._loadBufferLOD(e._materialBufferLODs, t + 1), e._materialSignalLODs[t] && e._materialSignalLODs[t].resolve());\n          });\n\n          a._loader._completePromises.push(n);\n        },\n            a = this;\n\n        for (r = 0; r < this._materialPromiseLODs.length; r++) {\n          o(r);\n        }\n      }, e.prototype.loadSceneAsync = function (e, t) {\n        var n = this._loader.loadSceneAsync(e, t);\n\n        return this._loadBufferLOD(this._bufferLODs, 0), n;\n      }, e.prototype.loadNodeAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtensionAsync(e, t, this.name, function (e, n) {\n          var o,\n              i = a._getLODs(e, t, a._loader.gltf.nodes, n.ids);\n\n          a._loader.logOpen(\"\" + e);\n\n          for (var s = function s(e) {\n            var t = i[e];\n            0 !== e && (a._nodeIndexLOD = e, a._nodeSignalLODs[e] = a._nodeSignalLODs[e] || new r.Deferred());\n\n            var n = a._loader.loadNodeAsync(\"/nodes/\" + t.index, t, function (e) {\n              e.setEnabled(!1);\n            }).then(function (t) {\n              if (0 !== e) {\n                var n = i[e - 1];\n                n._babylonTransformNode && (a._disposeTransformNode(n._babylonTransformNode), delete n._babylonTransformNode);\n              }\n\n              return t.setEnabled(!0), t;\n            });\n\n            a._nodePromiseLODs[e] = a._nodePromiseLODs[e] || [], 0 === e ? o = n : (a._nodeIndexLOD = null, a._nodePromiseLODs[e].push(n));\n          }, l = 0; l < i.length; l++) {\n            s(l);\n          }\n\n          return a._loader.logClose(), o;\n        });\n      }, e.prototype._loadMaterialAsync = function (e, t, n, r, a) {\n        var i = this;\n        return this._nodeIndexLOD ? null : o.b.LoadExtensionAsync(e, t, this.name, function (e, o) {\n          var s,\n              l = i._getLODs(e, t, i._loader.gltf.materials, o.ids);\n\n          i._loader.logOpen(\"\" + e);\n\n          for (var u = function u(e) {\n            var t = l[e];\n            0 !== e && (i._materialIndexLOD = e);\n\n            var o = i._loader._loadMaterialAsync(\"/materials/\" + t.index, t, n, r, function (t) {\n              0 === e && a(t);\n            }).then(function (t) {\n              if (0 !== e) {\n                a(t);\n                var n = l[e - 1]._data;\n                n[r] && (i._disposeMaterials([n[r].babylonMaterial]), delete n[r]);\n              }\n\n              return t;\n            });\n\n            i._materialPromiseLODs[e] = i._materialPromiseLODs[e] || [], 0 === e ? s = o : (i._materialIndexLOD = null, i._materialPromiseLODs[e].push(o));\n          }, c = 0; c < l.length; c++) {\n            u(c);\n          }\n\n          return i._loader.logClose(), s;\n        });\n      }, e.prototype._loadUriAsync = function (e, t, n) {\n        var o = this;\n\n        if (null !== this._nodeIndexLOD) {\n          this._loader.log(\"deferred\");\n\n          var a = this._nodeIndexLOD - 1;\n          return this._nodeSignalLODs[a] = this._nodeSignalLODs[a] || new r.Deferred(), this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function () {\n            return o._loader.loadUriAsync(e, t, n);\n          });\n        }\n\n        if (null !== this._materialIndexLOD) {\n          this._loader.log(\"deferred\");\n\n          a = this._materialIndexLOD - 1;\n          return this._materialSignalLODs[a] = this._materialSignalLODs[a] || new r.Deferred(), this._materialSignalLODs[a].promise.then(function () {\n            return o._loader.loadUriAsync(e, t, n);\n          });\n        }\n\n        return null;\n      }, e.prototype.loadBufferAsync = function (e, t, n, o) {\n        if (this._loader.parent.useRangeRequests && !t.uri) {\n          if (!this._loader.bin) throw new Error(e + \": Uri is missing or the binary glTF is missing its binary chunk\");\n\n          var a = function a(e, t) {\n            var a = n,\n                i = a + o - 1,\n                s = e[t];\n            return s ? (s.start = Math.min(s.start, a), s.end = Math.max(s.end, i)) : (s = {\n              start: a,\n              end: i,\n              loaded: new r.Deferred()\n            }, e[t] = s), s.loaded.promise.then(function (e) {\n              return new Uint8Array(e.buffer, e.byteOffset + n - s.start, o);\n            });\n          };\n\n          return this._loader.log(\"deferred\"), null !== this._nodeIndexLOD ? a(this._nodeBufferLODs, this._nodeIndexLOD) : null !== this._materialIndexLOD ? a(this._materialBufferLODs, this._materialIndexLOD) : a(this._bufferLODs, 0);\n        }\n\n        return null;\n      }, e.prototype._loadBufferLOD = function (e, t) {\n        var n = e[t];\n        n && (this._loader.log(\"Loading buffer range [\" + n.start + \"-\" + n.end + \"]\"), this._loader.bin.readAsync(n.start, n.end - n.start + 1).then(function (e) {\n          n.loaded.resolve(e);\n        }, function (e) {\n          n.loaded.reject(e);\n        }));\n      }, e.prototype._getLODs = function (e, t, n, r) {\n        if (this.maxLODsToLoad <= 0) throw new Error(\"maxLODsToLoad must be greater than zero\");\n\n        for (var a = new Array(), i = r.length - 1; i >= 0; i--) {\n          if (a.push(o.a.Get(e + \"/ids/\" + r[i], n, r[i])), a.length === this.maxLODsToLoad) return a;\n        }\n\n        return a.push(t), a;\n      }, e.prototype._disposeTransformNode = function (e) {\n        var t = this,\n            n = new Array(),\n            r = e.material;\n        r && n.push(r);\n\n        for (var o = 0, a = e.getChildMeshes(); o < a.length; o++) {\n          var i = a[o];\n          i.material && n.push(i.material);\n        }\n\n        e.dispose();\n        var s = n.filter(function (e) {\n          return t._loader.babylonScene.meshes.every(function (t) {\n            return t.material != e;\n          });\n        });\n\n        this._disposeMaterials(s);\n      }, e.prototype._disposeMaterials = function (e) {\n        for (var t = {}, n = 0, r = e; n < r.length; n++) {\n          for (var o = 0, a = (c = r[n]).getActiveTextures(); o < a.length; o++) {\n            var i = a[o];\n            t[i.uniqueId] = i;\n          }\n\n          c.dispose();\n        }\n\n        for (var s in t) {\n          for (var l = 0, u = this._loader.babylonScene.materials; l < u.length; l++) {\n            var c;\n            (c = u[l]).hasTexture(t[s]) && delete t[s];\n          }\n        }\n\n        for (var s in t) {\n          t[s].dispose();\n        }\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"MSFT_lod\", function (e) {\n      return new O(e);\n    });\n\n    var M = function () {\n      function e(e) {\n        this.name = \"MSFT_minecraftMesh\", this._loader = e, this.enabled = this._loader.isExtensionUsed(\"MSFT_minecraftMesh\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtraAsync(e, t, this.name, function (o, i) {\n          if (i) {\n            if (!(n instanceof r.PBRMaterial)) throw new Error(o + \": Material type not supported\");\n\n            var s = a._loader.loadMaterialPropertiesAsync(e, t, n);\n\n            return n.needAlphaBlending() && (n.forceDepthWrite = !0, n.separateCullingPass = !0), n.backFaceCulling = n.forceDepthWrite, n.twoSidedLighting = !0, s;\n          }\n\n          return null;\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"MSFT_minecraftMesh\", function (e) {\n      return new M(e);\n    });\n\n    var S = function () {\n      function e(e) {\n        this.name = \"MSFT_sRGBFactors\", this._loader = e, this.enabled = this._loader.isExtensionUsed(\"MSFT_sRGBFactors\");\n      }\n\n      return e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var a = this;\n        return o.b.LoadExtraAsync(e, t, this.name, function (o, i) {\n          if (i) {\n            if (!(n instanceof r.PBRMaterial)) throw new Error(o + \": Material type not supported\");\n\n            var s = a._loader.loadMaterialPropertiesAsync(e, t, n);\n\n            return n.albedoTexture || n.albedoColor.toLinearSpaceToRef(n.albedoColor), n.reflectivityTexture || n.reflectivityColor.toLinearSpaceToRef(n.reflectivityColor), s;\n          }\n\n          return null;\n        });\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"MSFT_sRGBFactors\", function (e) {\n      return new S(e);\n    });\n\n    var w = function () {\n      function e(e) {\n        this.name = \"ExtrasAsMetadata\", this.enabled = !0, this._loader = e;\n      }\n\n      return e.prototype._assignExtras = function (e, t) {\n        if (t.extras && Object.keys(t.extras).length > 0) {\n          var n = e.metadata = e.metadata || {};\n          (n.gltf = n.gltf || {}).extras = t.extras;\n        }\n      }, e.prototype.dispose = function () {\n        this._loader = null;\n      }, e.prototype.loadNodeAsync = function (e, t, n) {\n        var r = this;\n        return this._loader.loadNodeAsync(e, t, function (e) {\n          r._assignExtras(e, t), n(e);\n        });\n      }, e.prototype.loadCameraAsync = function (e, t, n) {\n        var r = this;\n        return this._loader.loadCameraAsync(e, t, function (e) {\n          r._assignExtras(e, t), n(e);\n        });\n      }, e.prototype.createMaterial = function (e, t, n) {\n        var r = this._loader.createMaterial(e, t, n);\n\n        return this._assignExtras(r, t), r;\n      }, e;\n    }();\n\n    o.b.RegisterExtension(\"ExtrasAsMetadata\", function (e) {\n      return new w(e);\n    });\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"GLTFBinaryExtension\", function () {\n      return k;\n    }), n.d(t, \"GLTFLoaderBase\", function () {\n      return D;\n    }), n.d(t, \"GLTFLoader\", function () {\n      return G;\n    }), n.d(t, \"GLTFLoaderExtension\", function () {\n      return U;\n    }), n.d(t, \"EComponentType\", function () {\n      return r;\n    }), n.d(t, \"EShaderType\", function () {\n      return o;\n    }), n.d(t, \"EParameterType\", function () {\n      return a;\n    }), n.d(t, \"ETextureWrapMode\", function () {\n      return i;\n    }), n.d(t, \"ETextureFilterType\", function () {\n      return s;\n    }), n.d(t, \"ETextureFormat\", function () {\n      return l;\n    }), n.d(t, \"ECullingType\", function () {\n      return u;\n    }), n.d(t, \"EBlendingFunction\", function () {\n      return c;\n    }), n.d(t, \"GLTFUtils\", function () {\n      return p;\n    }), n.d(t, \"GLTFMaterialsCommonExtension\", function () {\n      return H;\n    });\n    var r,\n        o,\n        a,\n        i,\n        s,\n        l,\n        u,\n        c,\n        d = n(4);\n    !function (e) {\n      e[e.BYTE = 5120] = \"BYTE\", e[e.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", e[e.SHORT = 5122] = \"SHORT\", e[e.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", e[e.FLOAT = 5126] = \"FLOAT\";\n    }(r || (r = {})), function (e) {\n      e[e.FRAGMENT = 35632] = \"FRAGMENT\", e[e.VERTEX = 35633] = \"VERTEX\";\n    }(o || (o = {})), function (e) {\n      e[e.BYTE = 5120] = \"BYTE\", e[e.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", e[e.SHORT = 5122] = \"SHORT\", e[e.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", e[e.INT = 5124] = \"INT\", e[e.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", e[e.FLOAT = 5126] = \"FLOAT\", e[e.FLOAT_VEC2 = 35664] = \"FLOAT_VEC2\", e[e.FLOAT_VEC3 = 35665] = \"FLOAT_VEC3\", e[e.FLOAT_VEC4 = 35666] = \"FLOAT_VEC4\", e[e.INT_VEC2 = 35667] = \"INT_VEC2\", e[e.INT_VEC3 = 35668] = \"INT_VEC3\", e[e.INT_VEC4 = 35669] = \"INT_VEC4\", e[e.BOOL = 35670] = \"BOOL\", e[e.BOOL_VEC2 = 35671] = \"BOOL_VEC2\", e[e.BOOL_VEC3 = 35672] = \"BOOL_VEC3\", e[e.BOOL_VEC4 = 35673] = \"BOOL_VEC4\", e[e.FLOAT_MAT2 = 35674] = \"FLOAT_MAT2\", e[e.FLOAT_MAT3 = 35675] = \"FLOAT_MAT3\", e[e.FLOAT_MAT4 = 35676] = \"FLOAT_MAT4\", e[e.SAMPLER_2D = 35678] = \"SAMPLER_2D\";\n    }(a || (a = {})), function (e) {\n      e[e.CLAMP_TO_EDGE = 33071] = \"CLAMP_TO_EDGE\", e[e.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\", e[e.REPEAT = 10497] = \"REPEAT\";\n    }(i || (i = {})), function (e) {\n      e[e.NEAREST = 9728] = \"NEAREST\", e[e.LINEAR = 9728] = \"LINEAR\", e[e.NEAREST_MIPMAP_NEAREST = 9984] = \"NEAREST_MIPMAP_NEAREST\", e[e.LINEAR_MIPMAP_NEAREST = 9985] = \"LINEAR_MIPMAP_NEAREST\", e[e.NEAREST_MIPMAP_LINEAR = 9986] = \"NEAREST_MIPMAP_LINEAR\", e[e.LINEAR_MIPMAP_LINEAR = 9987] = \"LINEAR_MIPMAP_LINEAR\";\n    }(s || (s = {})), function (e) {\n      e[e.ALPHA = 6406] = \"ALPHA\", e[e.RGB = 6407] = \"RGB\", e[e.RGBA = 6408] = \"RGBA\", e[e.LUMINANCE = 6409] = \"LUMINANCE\", e[e.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\";\n    }(l || (l = {})), function (e) {\n      e[e.FRONT = 1028] = \"FRONT\", e[e.BACK = 1029] = \"BACK\", e[e.FRONT_AND_BACK = 1032] = \"FRONT_AND_BACK\";\n    }(u || (u = {})), function (e) {\n      e[e.ZERO = 0] = \"ZERO\", e[e.ONE = 1] = \"ONE\", e[e.SRC_COLOR = 768] = \"SRC_COLOR\", e[e.ONE_MINUS_SRC_COLOR = 769] = \"ONE_MINUS_SRC_COLOR\", e[e.DST_COLOR = 774] = \"DST_COLOR\", e[e.ONE_MINUS_DST_COLOR = 775] = \"ONE_MINUS_DST_COLOR\", e[e.SRC_ALPHA = 770] = \"SRC_ALPHA\", e[e.ONE_MINUS_SRC_ALPHA = 771] = \"ONE_MINUS_SRC_ALPHA\", e[e.DST_ALPHA = 772] = \"DST_ALPHA\", e[e.ONE_MINUS_DST_ALPHA = 773] = \"ONE_MINUS_DST_ALPHA\", e[e.CONSTANT_COLOR = 32769] = \"CONSTANT_COLOR\", e[e.ONE_MINUS_CONSTANT_COLOR = 32770] = \"ONE_MINUS_CONSTANT_COLOR\", e[e.CONSTANT_ALPHA = 32771] = \"CONSTANT_ALPHA\", e[e.ONE_MINUS_CONSTANT_ALPHA = 32772] = \"ONE_MINUS_CONSTANT_ALPHA\", e[e.SRC_ALPHA_SATURATE = 776] = \"SRC_ALPHA_SATURATE\";\n    }(c || (c = {}));\n\n    var f,\n        h = n(0),\n        p = function () {\n      function e() {}\n\n      return e.SetMatrix = function (e, t, n, r, o) {\n        var i = null;\n        if (\"MODEL\" === n.semantic ? i = t.getWorldMatrix() : \"PROJECTION\" === n.semantic ? i = e.getProjectionMatrix() : \"VIEW\" === n.semantic ? i = e.getViewMatrix() : \"MODELVIEWINVERSETRANSPOSE\" === n.semantic ? i = h.Matrix.Transpose(t.getWorldMatrix().multiply(e.getViewMatrix()).invert()) : \"MODELVIEW\" === n.semantic ? i = t.getWorldMatrix().multiply(e.getViewMatrix()) : \"MODELVIEWPROJECTION\" === n.semantic ? i = t.getWorldMatrix().multiply(e.getTransformMatrix()) : \"MODELINVERSE\" === n.semantic ? i = t.getWorldMatrix().invert() : \"VIEWINVERSE\" === n.semantic ? i = e.getViewMatrix().invert() : \"PROJECTIONINVERSE\" === n.semantic ? i = e.getProjectionMatrix().invert() : \"MODELVIEWINVERSE\" === n.semantic ? i = t.getWorldMatrix().multiply(e.getViewMatrix()).invert() : \"MODELVIEWPROJECTIONINVERSE\" === n.semantic ? i = t.getWorldMatrix().multiply(e.getTransformMatrix()).invert() : \"MODELINVERSETRANSPOSE\" === n.semantic && (i = h.Matrix.Transpose(t.getWorldMatrix().invert())), i) switch (n.type) {\n          case a.FLOAT_MAT2:\n            o.setMatrix2x2(r, h.Matrix.GetAsMatrix2x2(i));\n            break;\n\n          case a.FLOAT_MAT3:\n            o.setMatrix3x3(r, h.Matrix.GetAsMatrix3x3(i));\n            break;\n\n          case a.FLOAT_MAT4:\n            o.setMatrix(r, i);\n        }\n      }, e.SetUniform = function (e, t, n, r) {\n        switch (r) {\n          case a.FLOAT:\n            return e.setFloat(t, n), !0;\n\n          case a.FLOAT_VEC2:\n            return e.setVector2(t, h.Vector2.FromArray(n)), !0;\n\n          case a.FLOAT_VEC3:\n            return e.setVector3(t, h.Vector3.FromArray(n)), !0;\n\n          case a.FLOAT_VEC4:\n            return e.setVector4(t, h.Vector4.FromArray(n)), !0;\n\n          default:\n            return !1;\n        }\n      }, e.GetWrapMode = function (e) {\n        switch (e) {\n          case i.CLAMP_TO_EDGE:\n            return h.Texture.CLAMP_ADDRESSMODE;\n\n          case i.MIRRORED_REPEAT:\n            return h.Texture.MIRROR_ADDRESSMODE;\n\n          case i.REPEAT:\n          default:\n            return h.Texture.WRAP_ADDRESSMODE;\n        }\n      }, e.GetByteStrideFromType = function (e) {\n        switch (e.type) {\n          case \"VEC2\":\n            return 2;\n\n          case \"VEC3\":\n            return 3;\n\n          case \"VEC4\":\n          case \"MAT2\":\n            return 4;\n\n          case \"MAT3\":\n            return 9;\n\n          case \"MAT4\":\n            return 16;\n\n          default:\n            return 1;\n        }\n      }, e.GetTextureFilterMode = function (e) {\n        switch (e) {\n          case s.LINEAR:\n          case s.LINEAR_MIPMAP_NEAREST:\n          case s.LINEAR_MIPMAP_LINEAR:\n            return h.Texture.TRILINEAR_SAMPLINGMODE;\n\n          case s.NEAREST:\n          case s.NEAREST_MIPMAP_NEAREST:\n            return h.Texture.NEAREST_SAMPLINGMODE;\n\n          default:\n            return h.Texture.BILINEAR_SAMPLINGMODE;\n        }\n      }, e.GetBufferFromBufferView = function (e, t, n, o, a) {\n        n = t.byteOffset + n;\n        var i = e.loadedBufferViews[t.buffer];\n        if (n + o > i.byteLength) throw new Error(\"Buffer access is out of range\");\n        var s = i.buffer;\n\n        switch (n += i.byteOffset, a) {\n          case r.BYTE:\n            return new Int8Array(s, n, o);\n\n          case r.UNSIGNED_BYTE:\n            return new Uint8Array(s, n, o);\n\n          case r.SHORT:\n            return new Int16Array(s, n, o);\n\n          case r.UNSIGNED_SHORT:\n            return new Uint16Array(s, n, o);\n\n          default:\n            return new Float32Array(s, n, o);\n        }\n      }, e.GetBufferFromAccessor = function (t, n) {\n        var r = t.bufferViews[n.bufferView],\n            o = n.count * e.GetByteStrideFromType(n);\n        return e.GetBufferFromBufferView(t, r, n.byteOffset, o, n.componentType);\n      }, e.DecodeBufferToText = function (e) {\n        for (var t = \"\", n = e.byteLength, r = 0; r < n; ++r) {\n          t += String.fromCharCode(e[r]);\n        }\n\n        return t;\n      }, e.GetDefaultMaterial = function (t) {\n        if (!e._DefaultMaterial) {\n          h.Effect.ShadersStore.GLTFDefaultMaterialVertexShader = [\"precision highp float;\", \"\", \"uniform mat4 worldView;\", \"uniform mat4 projection;\", \"\", \"attribute vec3 position;\", \"\", \"void main(void)\", \"{\", \"    gl_Position = projection * worldView * vec4(position, 1.0);\", \"}\"].join(\"\\n\"), h.Effect.ShadersStore.GLTFDefaultMaterialPixelShader = [\"precision highp float;\", \"\", \"uniform vec4 u_emission;\", \"\", \"void main(void)\", \"{\", \"    gl_FragColor = u_emission;\", \"}\"].join(\"\\n\");\n          var n = {\n            attributes: [\"position\"],\n            uniforms: [\"worldView\", \"projection\", \"u_emission\"],\n            samplers: new Array(),\n            needAlphaBlending: !1\n          };\n          e._DefaultMaterial = new h.ShaderMaterial(\"GLTFDefaultMaterial\", t, {\n            vertex: \"GLTFDefaultMaterial\",\n            fragment: \"GLTFDefaultMaterial\"\n          }, n), e._DefaultMaterial.setColor4(\"u_emission\", new h.Color4(.5, .5, .5, 1));\n        }\n\n        return e._DefaultMaterial;\n      }, e._DefaultMaterial = null, e;\n    }(),\n        _ = n(2);\n\n    !function (e) {\n      e[e.IDENTIFIER = 1] = \"IDENTIFIER\", e[e.UNKNOWN = 2] = \"UNKNOWN\", e[e.END_OF_INPUT = 3] = \"END_OF_INPUT\";\n    }(f || (f = {}));\n\n    var m = function () {\n      function e(e) {\n        this._pos = 0, this.currentToken = f.UNKNOWN, this.currentIdentifier = \"\", this.currentString = \"\", this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/, this._toParse = e, this._maxPos = e.length;\n      }\n\n      return e.prototype.getNextToken = function () {\n        if (this.isEnd()) return f.END_OF_INPUT;\n        if (this.currentString = this.read(), this.currentToken = f.UNKNOWN, \"_\" === this.currentString || this.isLetterOrDigitPattern.test(this.currentString)) for (this.currentToken = f.IDENTIFIER, this.currentIdentifier = this.currentString; !this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || \"_\" === this.currentString);) {\n          this.currentIdentifier += this.currentString, this.forward();\n        }\n        return this.currentToken;\n      }, e.prototype.peek = function () {\n        return this._toParse[this._pos];\n      }, e.prototype.read = function () {\n        return this._toParse[this._pos++];\n      }, e.prototype.forward = function () {\n        this._pos++;\n      }, e.prototype.isEnd = function () {\n        return this._pos >= this._maxPos;\n      }, e;\n    }(),\n        y = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"],\n        b = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"],\n        v = [\"translation\", \"rotation\", \"scale\"],\n        g = [\"position\", \"rotationQuaternion\", \"scaling\"],\n        A = function A(e, t, n) {\n      for (var r in e) {\n        var o = e[r];\n        n[t][r] = o;\n      }\n    },\n        T = function T(e) {\n      if (e) for (var t = 0; t < e.length / 2; t++) {\n        e[2 * t + 1] = 1 - e[2 * t + 1];\n      }\n    },\n        x = function x(e) {\n      if (\"NORMAL\" === e.semantic) return \"normal\";\n      if (\"POSITION\" === e.semantic) return \"position\";\n      if (\"JOINT\" === e.semantic) return \"matricesIndices\";\n      if (\"WEIGHT\" === e.semantic) return \"matricesWeights\";\n      if (\"COLOR\" === e.semantic) return \"color\";\n\n      if (e.semantic && -1 !== e.semantic.indexOf(\"TEXCOORD_\")) {\n        var t = Number(e.semantic.split(\"_\")[1]);\n        return \"uv\" + (0 === t ? \"\" : t + 1);\n      }\n\n      return null;\n    },\n        E = function E(e) {\n      var t = null;\n\n      if (e.translation || e.rotation || e.scale) {\n        var n = h.Vector3.FromArray(e.scale || [1, 1, 1]),\n            r = h.Quaternion.FromArray(e.rotation || [0, 0, 0, 1]),\n            o = h.Vector3.FromArray(e.translation || [0, 0, 0]);\n        t = h.Matrix.Compose(n, r, o);\n      } else t = h.Matrix.FromArray(e.matrix);\n\n      return t;\n    },\n        L = function L(e, t, n, r) {\n      for (var o = 0; o < r.bones.length; o++) {\n        if (r.bones[o].name === n) return r.bones[o];\n      }\n\n      var a = e.nodes;\n\n      for (var i in a) {\n        var s = a[i];\n\n        if (s.jointName) {\n          var l = s.children;\n\n          for (o = 0; o < l.length; o++) {\n            var u = e.nodes[l[o]];\n\n            if (u.jointName && u.jointName === n) {\n              var c = E(s),\n                  d = new h.Bone(s.name || \"\", r, L(e, t, s.jointName, r), c);\n              return d.id = i, d;\n            }\n          }\n        }\n      }\n\n      return null;\n    },\n        O = function O(e, t) {\n      for (var n = 0; n < e.length; n++) {\n        for (var r = e[n], o = 0; o < r.node.children.length; o++) {\n          if (r.node.children[o] === t) return r.bone;\n        }\n      }\n\n      return null;\n    },\n        M = function M(e, t) {\n      var n = e.nodes,\n          r = n[t];\n      if (r) return {\n        node: r,\n        id: t\n      };\n\n      for (var o in n) {\n        if ((r = n[o]).jointName === t) return {\n          node: r,\n          id: o\n        };\n      }\n\n      return null;\n    },\n        S = function S(e, t) {\n      for (var n = 0; n < e.jointNames.length; n++) {\n        if (e.jointNames[n] === t) return !0;\n      }\n\n      return !1;\n    },\n        w = function w(e, t, n, r, o) {\n      if (r || (r = new h.Skeleton(t.name || \"\", \"\", e.scene)), !t.babylonSkeleton) return r;\n      var a = [],\n          i = [];\n      !function (e, t, n, r) {\n        for (var o in e.nodes) {\n          var a = e.nodes[o],\n              i = o;\n\n          if (a.jointName && !S(n, a.jointName)) {\n            var s = E(a),\n                l = new h.Bone(a.name || \"\", t, null, s);\n            l.id = i, r.push({\n              bone: l,\n              node: a,\n              id: i\n            });\n          }\n        }\n\n        for (var u = 0; u < r.length; u++) {\n          for (var c = r[u], d = c.node.children, f = 0; f < d.length; f++) {\n            for (var p = null, _ = 0; _ < r.length; _++) {\n              if (r[_].id === d[f]) {\n                p = r[_];\n                break;\n              }\n            }\n\n            p && (p.bone._parent = c.bone, c.bone.children.push(p.bone));\n          }\n        }\n      }(e, r, t, a), r.bones = [];\n\n      for (var s = 0; s < t.jointNames.length; s++) {\n        if (g = M(e, t.jointNames[s])) {\n          var l = g.node;\n\n          if (l) {\n            o = g.id;\n            var u = e.scene.getBoneByID(o);\n            if (u) r.bones.push(u);else {\n              for (var c = !1, d = null, f = 0; f < s; f++) {\n                var p = M(e, t.jointNames[f]);\n\n                if (p) {\n                  var _ = p.node;\n\n                  if (_) {\n                    var m = _.children;\n\n                    if (m) {\n                      c = !1;\n\n                      for (var y = 0; y < m.length; y++) {\n                        if (m[y] === o) {\n                          d = L(e, t, t.jointNames[f], r), c = !0;\n                          break;\n                        }\n                      }\n\n                      if (c) break;\n                    }\n                  } else h.Tools.Warn(\"Joint named \" + t.jointNames[f] + \" does not exist when looking for parent\");\n                }\n              }\n\n              var b = E(l);\n              !d && a.length > 0 && (d = O(a, o)) && -1 === i.indexOf(d) && i.push(d), new h.Bone(l.jointName || \"\", r, d, b).id = o;\n            }\n          } else h.Tools.Warn(\"Joint named \" + t.jointNames[s] + \" does not exist\");\n        }\n      }\n\n      var v = r.bones;\n      r.bones = [];\n\n      for (s = 0; s < t.jointNames.length; s++) {\n        var g;\n        if (g = M(e, t.jointNames[s])) for (f = 0; f < v.length; f++) {\n          if (v[f].id === g.id) {\n            r.bones.push(v[f]);\n            break;\n          }\n        }\n      }\n\n      r.prepare();\n\n      for (s = 0; s < i.length; s++) {\n        r.bones.push(i[s]);\n      }\n\n      return r;\n    },\n        R = function R(e, t, n, r, o) {\n      if (o || (e.scene._blockEntityCollection = e.forAssetContainer, o = new h.Mesh(t.name || \"\", e.scene), e.scene._blockEntityCollection = !1, o.id = r), !t.babylonNode) return o;\n\n      for (var a, i = [], s = null, l = new Array(), u = new Array(), c = new Array(), d = new Array(), f = 0; f < n.length; f++) {\n        var m = n[f];\n        if (N = e.meshes[m]) for (var y = 0; y < N.primitives.length; y++) {\n          var b = new h.VertexData(),\n              v = N.primitives[y];\n          v.mode;\n          var g = v.attributes,\n              A = null,\n              x = null;\n\n          for (var E in g) {\n            if (A = e.accessors[g[E]], x = p.GetBufferFromAccessor(e, A), \"NORMAL\" === E) b.normals = new Float32Array(x.length), b.normals.set(x);else if (\"POSITION\" === E) {\n              if (_.GLTFFileLoader.HomogeneousCoordinates) {\n                b.positions = new Float32Array(x.length - x.length / 4);\n\n                for (var L = 0; L < x.length; L += 4) {\n                  b.positions[L] = x[L], b.positions[L + 1] = x[L + 1], b.positions[L + 2] = x[L + 2];\n                }\n              } else b.positions = new Float32Array(x.length), b.positions.set(x);\n\n              u.push(b.positions.length);\n            } else if (-1 !== E.indexOf(\"TEXCOORD_\")) {\n              var O = Number(E.split(\"_\")[1]),\n                  M = h.VertexBuffer.UVKind + (0 === O ? \"\" : O + 1),\n                  S = new Float32Array(x.length);\n              S.set(x), T(S), b.set(S, M);\n            } else \"JOINT\" === E ? (b.matricesIndices = new Float32Array(x.length), b.matricesIndices.set(x)) : \"WEIGHT\" === E ? (b.matricesWeights = new Float32Array(x.length), b.matricesWeights.set(x)) : \"COLOR\" === E && (b.colors = new Float32Array(x.length), b.colors.set(x));\n          }\n\n          if (A = e.accessors[v.indices]) x = p.GetBufferFromAccessor(e, A), b.indices = new Int32Array(x.length), b.indices.set(x), d.push(b.indices.length);else {\n            var w = [];\n\n            for (L = 0; L < b.positions.length / 3; L++) {\n              w.push(L);\n            }\n\n            b.indices = new Int32Array(w), d.push(b.indices.length);\n          }\n          s ? s.merge(b) : s = b;\n          var R = e.scene.getMaterialByID(v.material);\n          i.push(null === R ? p.GetDefaultMaterial(e.scene) : R), l.push(0 === l.length ? 0 : l[l.length - 1] + u[u.length - 2]), c.push(0 === c.length ? 0 : c[c.length - 1] + d[d.length - 2]);\n        }\n      }\n\n      e.scene._blockEntityCollection = e.forAssetContainer, i.length > 1 ? (a = new h.MultiMaterial(\"multimat\" + r, e.scene)).subMaterials = i : a = new h.StandardMaterial(\"multimat\" + r, e.scene), 1 === i.length && (a = i[0]), o.material || (o.material = a), new h.Geometry(r, e.scene, s, !1, o), o.computeWorldMatrix(!0), e.scene._blockEntityCollection = !1, o.subMeshes = [];\n      var C = 0;\n\n      for (f = 0; f < n.length; f++) {\n        var N;\n        m = n[f];\n        if (N = e.meshes[m]) for (y = 0; y < N.primitives.length; y++) {\n          N.primitives[y].mode, h.SubMesh.AddToMesh(C, l[C], u[C], c[C], d[C], o, o, !0), C++;\n        }\n      }\n\n      return o;\n    },\n        C = function C(e, t, n, r) {\n      e.position && (e.position = t), (e.rotationQuaternion || e.rotation) && (e.rotationQuaternion = n), e.scaling && (e.scaling = r);\n    },\n        N = function N(e, t, n, r) {\n      var o = null;\n      if (e.importOnlyMeshes && (t.skin || t.meshes) && e.importMeshesNames && e.importMeshesNames.length > 0 && -1 === e.importMeshesNames.indexOf(t.name || \"\")) return null;\n\n      if (t.skin) {\n        if (t.meshes) {\n          var a = e.skins[t.skin];\n          (i = R(e, t, t.meshes, n, t.babylonNode)).skeleton = e.scene.getLastSkeletonByID(t.skin), null === i.skeleton && (i.skeleton = w(e, a, 0, a.babylonSkeleton, t.skin), a.babylonSkeleton || (a.babylonSkeleton = i.skeleton)), o = i;\n        }\n      } else if (t.meshes) {\n        var i;\n        o = i = R(e, t, t.mesh ? [t.mesh] : t.meshes, n, t.babylonNode);\n      } else if (!t.light || t.babylonNode || e.importOnlyMeshes) {\n        if (t.camera && !t.babylonNode && !e.importOnlyMeshes) {\n          var s = e.cameras[t.camera];\n\n          if (s) {\n            if (e.scene._blockEntityCollection = e.forAssetContainer, \"orthographic\" === s.type) {\n              var l = new h.FreeCamera(t.camera, h.Vector3.Zero(), e.scene, !1);\n              l.name = t.name || \"\", l.mode = h.Camera.ORTHOGRAPHIC_CAMERA, l.attachControl(), o = l;\n            } else if (\"perspective\" === s.type) {\n              var u = s[s.type],\n                  c = new h.FreeCamera(t.camera, h.Vector3.Zero(), e.scene, !1);\n              c.name = t.name || \"\", c.attachControl(), u.aspectRatio || (u.aspectRatio = e.scene.getEngine().getRenderWidth() / e.scene.getEngine().getRenderHeight()), u.znear && u.zfar && (c.maxZ = u.zfar, c.minZ = u.znear), o = c;\n            }\n\n            e.scene._blockEntityCollection = !1;\n          }\n        }\n      } else {\n        var d = e.lights[t.light];\n        if (d) if (\"ambient\" === d.type) {\n          var f = d[d.type],\n              p = new h.HemisphericLight(t.light, h.Vector3.Zero(), e.scene);\n          p.name = t.name || \"\", f.color && (p.diffuse = h.Color3.FromArray(f.color)), o = p;\n        } else if (\"directional\" === d.type) {\n          var _ = d[d.type],\n              m = new h.DirectionalLight(t.light, h.Vector3.Zero(), e.scene);\n          m.name = t.name || \"\", _.color && (m.diffuse = h.Color3.FromArray(_.color)), o = m;\n        } else if (\"point\" === d.type) {\n          var y = d[d.type],\n              b = new h.PointLight(t.light, h.Vector3.Zero(), e.scene);\n          b.name = t.name || \"\", y.color && (b.diffuse = h.Color3.FromArray(y.color)), o = b;\n        } else if (\"spot\" === d.type) {\n          var v = d[d.type],\n              g = new h.SpotLight(t.light, h.Vector3.Zero(), h.Vector3.Zero(), 0, 0, e.scene);\n          g.name = t.name || \"\", v.color && (g.diffuse = h.Color3.FromArray(v.color)), v.fallOfAngle && (g.angle = v.fallOfAngle), v.fallOffExponent && (g.exponent = v.fallOffExponent), o = g;\n        }\n      }\n\n      if (!t.jointName) {\n        if (t.babylonNode) return t.babylonNode;\n\n        if (null === o) {\n          e.scene._blockEntityCollection = e.forAssetContainer;\n          var A = new h.Mesh(t.name || \"\", e.scene);\n          e.scene._blockEntityCollection = !1, t.babylonNode = A, o = A;\n        }\n      }\n\n      if (null !== o) {\n        if (t.matrix && o instanceof h.Mesh) !function (e, t, n) {\n          if (t.matrix) {\n            var r = new h.Vector3(0, 0, 0),\n                o = new h.Quaternion(),\n                a = new h.Vector3(0, 0, 0);\n            h.Matrix.FromArray(t.matrix).decompose(a, o, r), C(e, r, o, a);\n          } else t.translation && t.rotation && t.scale && C(e, h.Vector3.FromArray(t.translation), h.Quaternion.FromArray(t.rotation), h.Vector3.FromArray(t.scale));\n\n          e.computeWorldMatrix(!0);\n        }(o, t);else {\n          var T = t.translation || [0, 0, 0],\n              x = t.rotation || [0, 0, 0, 1],\n              E = t.scale || [1, 1, 1];\n          C(o, h.Vector3.FromArray(T), h.Quaternion.FromArray(x), h.Vector3.FromArray(E));\n        }\n        o.updateCache(!0), t.babylonNode = o;\n      }\n\n      return o;\n    },\n        P = function P(e, t, n, r) {\n      void 0 === r && (r = !1);\n      var o = e.nodes[t],\n          a = null;\n      if (r = !(e.importOnlyMeshes && !r && e.importMeshesNames) || -1 !== e.importMeshesNames.indexOf(o.name || \"\") || 0 === e.importMeshesNames.length, !o.jointName && r && null !== (a = N(e, o, t)) && (a.id = t, a.parent = n), o.children) for (var i = 0; i < o.children.length; i++) {\n        P(e, o.children[i], a, r);\n      }\n    },\n        I = function I(e) {\n      var t = e.currentScene;\n      if (t) for (var n = 0; n < t.nodes.length; n++) {\n        P(e, t.nodes[n], null);\n      } else for (var r in e.scenes) {\n        t = e.scenes[r];\n\n        for (n = 0; n < t.nodes.length; n++) {\n          P(e, t.nodes[n], null);\n        }\n      }\n      !function (e) {\n        for (var t in e.animations) {\n          var n = e.animations[t];\n          if (n.channels && n.samplers) for (var r = null, o = 0; o < n.channels.length; o++) {\n            var a = n.channels[o],\n                i = n.samplers[a.sampler];\n\n            if (i) {\n              var s = null,\n                  l = null;\n              n.parameters ? (s = n.parameters[i.input], l = n.parameters[i.output]) : (s = i.input, l = i.output);\n              var u = p.GetBufferFromAccessor(e, e.accessors[s]),\n                  c = p.GetBufferFromAccessor(e, e.accessors[l]),\n                  d = a.target.id,\n                  f = e.scene.getNodeByID(d);\n\n              if (null === f && (f = e.scene.getNodeByName(d)), null !== f) {\n                var _ = f instanceof h.Bone,\n                    m = a.target.path,\n                    y = v.indexOf(m);\n\n                -1 !== y && (m = g[y]);\n                var b = h.Animation.ANIMATIONTYPE_MATRIX;\n                _ || (\"rotationQuaternion\" === m ? (b = h.Animation.ANIMATIONTYPE_QUATERNION, f.rotationQuaternion = new h.Quaternion()) : b = h.Animation.ANIMATIONTYPE_VECTOR3);\n                var A = null,\n                    T = [],\n                    x = 0,\n                    E = !1;\n                _ && r && r.getKeys().length === u.length && (A = r, E = !0), E || (e.scene._blockEntityCollection = e.forAssetContainer, A = new h.Animation(t, _ ? \"_matrix\" : m, 1, b, h.Animation.ANIMATIONLOOPMODE_CYCLE), e.scene._blockEntityCollection = !1);\n\n                for (var L = 0; L < u.length; L++) {\n                  var O = null;\n\n                  if (\"rotationQuaternion\" === m ? (O = h.Quaternion.FromArray([c[x], c[x + 1], c[x + 2], c[x + 3]]), x += 4) : (O = h.Vector3.FromArray([c[x], c[x + 1], c[x + 2]]), x += 3), _) {\n                    var M = f,\n                        S = h.Vector3.Zero(),\n                        w = new h.Quaternion(),\n                        R = h.Vector3.Zero(),\n                        C = M.getBaseMatrix();\n                    E && r && (C = r.getKeys()[L].value), C.decompose(R, w, S), \"position\" === m ? S = O : \"rotationQuaternion\" === m ? w = O : R = O, O = h.Matrix.Compose(R, w, S);\n                  }\n\n                  E ? r && (r.getKeys()[L].value = O) : T.push({\n                    frame: u[L],\n                    value: O\n                  });\n                }\n\n                !E && A && (A.setKeys(T), f.animations.push(A)), r = A, e.scene.stopAnimation(f), e.scene.beginAnimation(f, 0, u[u.length - 1], !0, 1);\n              } else h.Tools.Warn(\"Creating animation named \" + t + \". But cannot find node named \" + d + \" to attach to\");\n            }\n          }\n        }\n      }(e);\n\n      for (n = 0; n < e.scene.skeletons.length; n++) {\n        var o = e.scene.skeletons[n];\n        e.scene.beginAnimation(o, 0, Number.MAX_VALUE, !0, 1);\n      }\n    },\n        F = function F(e, t, n, r, o, i) {\n      return function (s) {\n        !function (e, t, n, r, o) {\n          var i = r.values || n.parameters,\n              s = n.uniforms;\n\n          for (var l in o) {\n            var u = o[l],\n                c = u.type,\n                d = i[s[l]];\n\n            if (void 0 === d && (d = u.value), d) {\n              var f = function f(e) {\n                return function (n) {\n                  u.value && e && (t.setTexture(e, n), delete o[e]);\n                };\n              };\n\n              c === a.SAMPLER_2D ? U.LoadTextureAsync(e, r.values ? d : u.value, f(l), function () {\n                return f(null);\n              }) : u.value && p.SetUniform(t, l, r.values ? d : u.value, c) && delete o[l];\n            }\n          }\n        }(e, t, n, r, o), t.onBind = function (s) {\n          !function (e, t, n, r, o, i, s) {\n            var l = i.values || o.parameters;\n\n            for (var u in n) {\n              var c = n[u],\n                  d = c.type;\n              if (d === a.FLOAT_MAT2 || d === a.FLOAT_MAT3 || d === a.FLOAT_MAT4) {\n                if (!c.semantic || c.source || c.node) {\n                  if (c.semantic && (c.source || c.node)) {\n                    var f = t.scene.getNodeByName(c.source || c.node || \"\");\n                    if (null === f && (f = t.scene.getNodeByID(c.source || c.node || \"\")), null === f) continue;\n                    p.SetMatrix(t.scene, f, c, u, r.getEffect());\n                  }\n                } else p.SetMatrix(t.scene, e, c, u, r.getEffect());\n              } else {\n                var h = l[o.uniforms[u]];\n                if (!h) continue;\n\n                if (d === a.SAMPLER_2D) {\n                  var _ = t.textures[i.values ? h : c.value].babylonTexture;\n                  if (null == _) continue;\n                  r.getEffect().setTexture(u, _);\n                } else p.SetUniform(r.getEffect(), u, h, d);\n              }\n            }\n\n            s(r);\n          }(s, e, o, t, n, r, i);\n        };\n      };\n    },\n        B = function B(e, t, n) {\n      for (var r in t.uniforms) {\n        var o = t.uniforms[r],\n            a = t.parameters[o];\n\n        if (e.currentIdentifier === r && a.semantic && !a.source && !a.node) {\n          var i = y.indexOf(a.semantic);\n          if (-1 !== i) return delete n[r], b[i];\n        }\n      }\n\n      return e.currentIdentifier;\n    },\n        V = function V(e) {\n      for (var t in e.materials) {\n        U.LoadMaterialAsync(e, t, function (e) {}, function () {});\n      }\n    },\n        D = function () {\n      function e() {}\n\n      return e.CreateRuntime = function (e, t, n) {\n        var r = {\n          extensions: {},\n          accessors: {},\n          buffers: {},\n          bufferViews: {},\n          meshes: {},\n          lights: {},\n          cameras: {},\n          nodes: {},\n          images: {},\n          textures: {},\n          shaders: {},\n          programs: {},\n          samplers: {},\n          techniques: {},\n          materials: {},\n          animations: {},\n          skins: {},\n          extensionsUsed: [],\n          scenes: {},\n          buffersCount: 0,\n          shaderscount: 0,\n          scene: t,\n          rootUrl: n,\n          loadedBufferCount: 0,\n          loadedBufferViews: {},\n          loadedShaderCount: 0,\n          importOnlyMeshes: !1,\n          dummyNodes: [],\n          forAssetContainer: !1\n        };\n        return e.extensions && A(e.extensions, \"extensions\", r), e.extensionsUsed && A(e.extensionsUsed, \"extensionsUsed\", r), e.buffers && function (e, t) {\n          for (var n in e) {\n            var r = e[n];\n            t.buffers[n] = r, t.buffersCount++;\n          }\n        }(e.buffers, r), e.bufferViews && A(e.bufferViews, \"bufferViews\", r), e.accessors && A(e.accessors, \"accessors\", r), e.meshes && A(e.meshes, \"meshes\", r), e.lights && A(e.lights, \"lights\", r), e.cameras && A(e.cameras, \"cameras\", r), e.nodes && A(e.nodes, \"nodes\", r), e.images && A(e.images, \"images\", r), e.textures && A(e.textures, \"textures\", r), e.shaders && function (e, t) {\n          for (var n in e) {\n            var r = e[n];\n            t.shaders[n] = r, t.shaderscount++;\n          }\n        }(e.shaders, r), e.programs && A(e.programs, \"programs\", r), e.samplers && A(e.samplers, \"samplers\", r), e.techniques && A(e.techniques, \"techniques\", r), e.materials && A(e.materials, \"materials\", r), e.animations && A(e.animations, \"animations\", r), e.skins && A(e.skins, \"skins\", r), e.scenes && (r.scenes = e.scenes), e.scene && e.scenes && (r.currentScene = e.scenes[e.scene]), r;\n      }, e.LoadBufferAsync = function (e, t, n, r, o) {\n        var a = e.buffers[t];\n        h.Tools.IsBase64(a.uri) ? setTimeout(function () {\n          return n(new Uint8Array(h.Tools.DecodeBase64(a.uri)));\n        }) : h.Tools.LoadFile(e.rootUrl + a.uri, function (e) {\n          return n(new Uint8Array(e));\n        }, o, void 0, !0, function (e) {\n          e && r(e.status + \" \" + e.statusText);\n        });\n      }, e.LoadTextureBufferAsync = function (e, t, n, r) {\n        var o = e.textures[t];\n        if (o && o.source) {\n          if (o.babylonTexture) n(null);else {\n            var a = e.images[o.source];\n            h.Tools.IsBase64(a.uri) ? setTimeout(function () {\n              return n(new Uint8Array(h.Tools.DecodeBase64(a.uri)));\n            }) : h.Tools.LoadFile(e.rootUrl + a.uri, function (e) {\n              return n(new Uint8Array(e));\n            }, void 0, void 0, !0, function (e) {\n              e && r(e.status + \" \" + e.statusText);\n            });\n          }\n        } else r(\"\");\n      }, e.CreateTextureAsync = function (e, t, n, r, o) {\n        var a = e.textures[t];\n        if (a.babylonTexture) r(a.babylonTexture);else {\n          var i = e.samplers[a.sampler],\n              l = i.minFilter === s.NEAREST_MIPMAP_NEAREST || i.minFilter === s.NEAREST_MIPMAP_LINEAR || i.minFilter === s.LINEAR_MIPMAP_NEAREST || i.minFilter === s.LINEAR_MIPMAP_LINEAR,\n              u = h.Texture.BILINEAR_SAMPLINGMODE,\n              c = null == n ? new Blob() : new Blob([n]),\n              d = URL.createObjectURL(c),\n              f = function f() {\n            return URL.revokeObjectURL(d);\n          },\n              _ = new h.Texture(d, e.scene, !l, !0, u, f, f);\n\n          void 0 !== i.wrapS && (_.wrapU = p.GetWrapMode(i.wrapS)), void 0 !== i.wrapT && (_.wrapV = p.GetWrapMode(i.wrapT)), _.name = t, a.babylonTexture = _, r(_);\n        }\n      }, e.LoadShaderStringAsync = function (e, t, n, r) {\n        var o = e.shaders[t];\n\n        if (h.Tools.IsBase64(o.uri)) {\n          var a = atob(o.uri.split(\",\")[1]);\n          n && n(a);\n        } else h.Tools.LoadFile(e.rootUrl + o.uri, n, void 0, void 0, !1, function (e) {\n          e && r && r(e.status + \" \" + e.statusText);\n        });\n      }, e.LoadMaterialAsync = function (e, t, n, r) {\n        var o = e.materials[t];\n\n        if (o.technique) {\n          var i = e.techniques[o.technique];\n\n          if (!i) {\n            e.scene._blockEntityCollection = e.forAssetContainer;\n            var s = new h.StandardMaterial(t, e.scene);\n            return e.scene._blockEntityCollection = !1, s.diffuseColor = new h.Color3(.5, .5, .5), s.sideOrientation = h.Material.CounterClockWiseSideOrientation, void n(s);\n          }\n\n          var l = e.programs[i.program],\n              d = i.states,\n              p = h.Effect.ShadersStore[l.vertexShader + \"VertexShader\"],\n              _ = h.Effect.ShadersStore[l.fragmentShader + \"PixelShader\"],\n              v = \"\",\n              g = \"\",\n              A = new m(p),\n              T = new m(_),\n              E = {},\n              L = [],\n              O = [],\n              M = [];\n\n          for (var S in i.uniforms) {\n            var w = i.uniforms[S],\n                R = i.parameters[w];\n            if (E[S] = R, !R.semantic || R.node || R.source) R.type === a.SAMPLER_2D ? M.push(S) : L.push(S);else {\n              var C = y.indexOf(R.semantic);\n              -1 !== C ? (L.push(b[C]), delete E[S]) : L.push(S);\n            }\n          }\n\n          for (var N in i.attributes) {\n            var P = i.attributes[N];\n\n            if ((D = i.parameters[P]).semantic) {\n              var I = x(D);\n              I && O.push(I);\n            }\n          }\n\n          for (; !A.isEnd() && A.getNextToken();) {\n            if (A.currentToken === f.IDENTIFIER) {\n              var V = !1;\n\n              for (var N in i.attributes) {\n                P = i.attributes[N];\n                var D = i.parameters[P];\n\n                if (A.currentIdentifier === N && D.semantic) {\n                  v += x(D), V = !0;\n                  break;\n                }\n              }\n\n              V || (v += B(A, i, E));\n            } else v += A.currentString;\n          }\n\n          for (; !T.isEnd() && T.getNextToken();) {\n            T.currentToken === f.IDENTIFIER ? g += B(T, i, E) : g += T.currentString;\n          }\n\n          var G = {\n            vertex: l.vertexShader + t,\n            fragment: l.fragmentShader + t\n          },\n              U = {\n            attributes: O,\n            uniforms: L,\n            samplers: M,\n            needAlphaBlending: d && d.enable && -1 !== d.enable.indexOf(3042)\n          };\n          h.Effect.ShadersStore[l.vertexShader + t + \"VertexShader\"] = v, h.Effect.ShadersStore[l.fragmentShader + t + \"PixelShader\"] = g;\n          var k = new h.ShaderMaterial(t, e.scene, G, U);\n\n          if (k.onError = function (e, t, n) {\n            return function (r, o) {\n              t.dispose(!0), n(\"Cannot compile program named \" + e.name + \". Error: \" + o + \". Default material will be applied\");\n            };\n          }(l, k, r), k.onCompiled = F(e, k, i, o, E, n), k.sideOrientation = h.Material.CounterClockWiseSideOrientation, d && d.functions) {\n            var H = d.functions;\n            H.cullFace && H.cullFace[0] !== u.BACK && (k.backFaceCulling = !1);\n            var K = H.blendFuncSeparate;\n            K && (K[0] === c.SRC_ALPHA && K[1] === c.ONE_MINUS_SRC_ALPHA && K[2] === c.ONE && K[3] === c.ONE ? k.alphaMode = h.Constants.ALPHA_COMBINE : K[0] === c.ONE && K[1] === c.ONE && K[2] === c.ZERO && K[3] === c.ONE ? k.alphaMode = h.Constants.ALPHA_ONEONE : K[0] === c.SRC_ALPHA && K[1] === c.ONE && K[2] === c.ZERO && K[3] === c.ONE ? k.alphaMode = h.Constants.ALPHA_ADD : K[0] === c.ZERO && K[1] === c.ONE_MINUS_SRC_COLOR && K[2] === c.ONE && K[3] === c.ONE ? k.alphaMode = h.Constants.ALPHA_SUBTRACT : K[0] === c.DST_COLOR && K[1] === c.ZERO && K[2] === c.ONE && K[3] === c.ONE ? k.alphaMode = h.Constants.ALPHA_MULTIPLY : K[0] === c.SRC_ALPHA && K[1] === c.ONE_MINUS_SRC_COLOR && K[2] === c.ONE && K[3] === c.ONE && (k.alphaMode = h.Constants.ALPHA_MAXIMIZED));\n          }\n        } else r && r(\"No technique found.\");\n      }, e;\n    }(),\n        G = function () {\n      function e() {\n        this.state = null;\n      }\n\n      return e.RegisterExtension = function (t) {\n        e.Extensions[t.name] ? h.Tools.Error('Tool with the same name \"' + t.name + '\" already exists') : e.Extensions[t.name] = t;\n      }, e.prototype.dispose = function () {}, e.prototype._importMeshAsync = function (e, t, n, r, o, a, i, s) {\n        var l = this;\n        return t.useRightHandedSystem = !0, U.LoadRuntimeAsync(t, n, r, function (t) {\n          t.forAssetContainer = o, t.importOnlyMeshes = !0, \"\" === e ? t.importMeshesNames = [] : \"string\" == typeof e ? t.importMeshesNames = [e] : !e || e instanceof Array ? (t.importMeshesNames = [], h.Tools.Warn(\"Argument meshesNames must be of type string or string[]\")) : t.importMeshesNames = [e], l._createNodes(t);\n          var n = new Array(),\n              r = new Array();\n\n          for (var s in t.nodes) {\n            var u = t.nodes[s];\n            u.babylonNode instanceof h.AbstractMesh && n.push(u.babylonNode);\n          }\n\n          for (var c in t.skins) {\n            var d = t.skins[c];\n            d.babylonSkeleton instanceof h.Skeleton && r.push(d.babylonSkeleton);\n          }\n\n          l._loadBuffersAsync(t, function () {\n            l._loadShadersAsync(t, function () {\n              V(t), I(t), !_.GLTFFileLoader.IncrementalLoading && a && a(n, r);\n            });\n          }, i), _.GLTFFileLoader.IncrementalLoading && a && a(n, r);\n        }, s), !0;\n      }, e.prototype.importMeshAsync = function (e, t, n, r, o, a) {\n        var i = this;\n        return new Promise(function (s, l) {\n          i._importMeshAsync(e, t, r, o, n, function (e, t) {\n            s({\n              meshes: e,\n              particleSystems: [],\n              skeletons: t,\n              animationGroups: [],\n              lights: [],\n              transformNodes: [],\n              geometries: []\n            });\n          }, a, function (e) {\n            l(new Error(e));\n          });\n        });\n      }, e.prototype._loadAsync = function (e, t, n, r, o, a, i) {\n        var s = this;\n        e.useRightHandedSystem = !0, U.LoadRuntimeAsync(e, t, n, function (e) {\n          U.LoadRuntimeExtensionsAsync(e, function () {\n            s._createNodes(e), s._loadBuffersAsync(e, function () {\n              s._loadShadersAsync(e, function () {\n                V(e), I(e), _.GLTFFileLoader.IncrementalLoading || o();\n              });\n            }), _.GLTFFileLoader.IncrementalLoading && o();\n          }, i);\n        }, i);\n      }, e.prototype.loadAsync = function (e, t, n, r) {\n        var o = this;\n        return new Promise(function (a, i) {\n          o._loadAsync(e, t, n, !1, function () {\n            a();\n          }, r, function (e) {\n            i(new Error(e));\n          });\n        });\n      }, e.prototype._loadShadersAsync = function (e, t) {\n        var n = !1,\n            r = function r(n, _r2) {\n          U.LoadShaderStringAsync(e, n, function (a) {\n            a instanceof ArrayBuffer || (e.loadedShaderCount++, a && (h.Effect.ShadersStore[n + (_r2.type === o.VERTEX ? \"VertexShader\" : \"PixelShader\")] = a), e.loadedShaderCount === e.shaderscount && t());\n          }, function () {\n            h.Tools.Error(\"Error when loading shader program named \" + n + \" located at \" + _r2.uri);\n          });\n        };\n\n        for (var a in e.shaders) {\n          n = !0;\n          var i = e.shaders[a];\n          i ? r.bind(this, a, i)() : h.Tools.Error(\"No shader named: \" + a);\n        }\n\n        n || t();\n      }, e.prototype._loadBuffersAsync = function (e, t, n) {\n        var r = !1,\n            o = function o(n, r) {\n          U.LoadBufferAsync(e, n, function (o) {\n            e.loadedBufferCount++, o && (o.byteLength != e.buffers[n].byteLength && h.Tools.Error(\"Buffer named \" + n + \" is length \" + o.byteLength + \". Expected: \" + r.byteLength), e.loadedBufferViews[n] = o), e.loadedBufferCount === e.buffersCount && t();\n          }, function () {\n            h.Tools.Error(\"Error when loading buffer named \" + n + \" located at \" + r.uri);\n          });\n        };\n\n        for (var a in e.buffers) {\n          r = !0;\n          var i = e.buffers[a];\n          i ? o.bind(this, a, i)() : h.Tools.Error(\"No buffer named: \" + a);\n        }\n\n        r || t();\n      }, e.prototype._createNodes = function (e) {\n        var t = e.currentScene;\n        if (t) for (var n = 0; n < t.nodes.length; n++) {\n          P(e, t.nodes[n], null);\n        } else for (var r in e.scenes) {\n          t = e.scenes[r];\n\n          for (n = 0; n < t.nodes.length; n++) {\n            P(e, t.nodes[n], null);\n          }\n        }\n      }, e.Extensions = {}, e;\n    }(),\n        U = function () {\n      function e(e) {\n        this._name = e;\n      }\n\n      return Object.defineProperty(e.prototype, \"name\", {\n        get: function get() {\n          return this._name;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), e.prototype.loadRuntimeAsync = function (e, t, n, r, o) {\n        return !1;\n      }, e.prototype.loadRuntimeExtensionsAsync = function (e, t, n) {\n        return !1;\n      }, e.prototype.loadBufferAsync = function (e, t, n, r, o) {\n        return !1;\n      }, e.prototype.loadTextureBufferAsync = function (e, t, n, r) {\n        return !1;\n      }, e.prototype.createTextureAsync = function (e, t, n, r, o) {\n        return !1;\n      }, e.prototype.loadShaderStringAsync = function (e, t, n, r) {\n        return !1;\n      }, e.prototype.loadMaterialAsync = function (e, t, n, r) {\n        return !1;\n      }, e.LoadRuntimeAsync = function (t, n, r, o, a) {\n        e.ApplyExtensions(function (e) {\n          return e.loadRuntimeAsync(t, n, r, o, a);\n        }, function () {\n          setTimeout(function () {\n            o && o(D.CreateRuntime(n.json, t, r));\n          });\n        });\n      }, e.LoadRuntimeExtensionsAsync = function (t, n, r) {\n        e.ApplyExtensions(function (e) {\n          return e.loadRuntimeExtensionsAsync(t, n, r);\n        }, function () {\n          setTimeout(function () {\n            n();\n          });\n        });\n      }, e.LoadBufferAsync = function (t, n, r, o, a) {\n        e.ApplyExtensions(function (e) {\n          return e.loadBufferAsync(t, n, r, o, a);\n        }, function () {\n          D.LoadBufferAsync(t, n, r, o, a);\n        });\n      }, e.LoadTextureAsync = function (t, n, r, o) {\n        e.LoadTextureBufferAsync(t, n, function (a) {\n          a && e.CreateTextureAsync(t, n, a, r, o);\n        }, o);\n      }, e.LoadShaderStringAsync = function (t, n, r, o) {\n        e.ApplyExtensions(function (e) {\n          return e.loadShaderStringAsync(t, n, r, o);\n        }, function () {\n          D.LoadShaderStringAsync(t, n, r, o);\n        });\n      }, e.LoadMaterialAsync = function (t, n, r, o) {\n        e.ApplyExtensions(function (e) {\n          return e.loadMaterialAsync(t, n, r, o);\n        }, function () {\n          D.LoadMaterialAsync(t, n, r, o);\n        });\n      }, e.LoadTextureBufferAsync = function (t, n, r, o) {\n        e.ApplyExtensions(function (e) {\n          return e.loadTextureBufferAsync(t, n, r, o);\n        }, function () {\n          D.LoadTextureBufferAsync(t, n, r, o);\n        });\n      }, e.CreateTextureAsync = function (t, n, r, o, a) {\n        e.ApplyExtensions(function (e) {\n          return e.createTextureAsync(t, n, r, o, a);\n        }, function () {\n          D.CreateTextureAsync(t, n, r, o, a);\n        });\n      }, e.ApplyExtensions = function (e, t) {\n        for (var n in G.Extensions) {\n          if (e(G.Extensions[n])) return;\n        }\n\n        t();\n      }, e;\n    }();\n\n    _.GLTFFileLoader._CreateGLTF1Loader = function () {\n      return new G();\n    };\n\n    var k = function (e) {\n      function t() {\n        return e.call(this, \"KHR_binary_glTF\") || this;\n      }\n\n      return Object(d.b)(t, e), t.prototype.loadRuntimeAsync = function (e, t, n, r, o) {\n        var a = t.json.extensionsUsed;\n        return !(!a || -1 === a.indexOf(this.name) || !t.bin) && (this._bin = t.bin, r(D.CreateRuntime(t.json, e, n)), !0);\n      }, t.prototype.loadBufferAsync = function (e, t, n, r) {\n        return -1 !== e.extensionsUsed.indexOf(this.name) && \"binary_glTF\" === t && (this._bin.readAsync(0, this._bin.byteLength).then(n, function (e) {\n          return r(e.message);\n        }), !0);\n      }, t.prototype.loadTextureBufferAsync = function (e, t, n, o) {\n        var a = e.textures[t],\n            i = e.images[a.source];\n        if (!i.extensions || !(this.name in i.extensions)) return !1;\n        var s = i.extensions[this.name],\n            l = e.bufferViews[s.bufferView];\n        return n(p.GetBufferFromBufferView(e, l, 0, l.byteLength, r.UNSIGNED_BYTE)), !0;\n      }, t.prototype.loadShaderStringAsync = function (e, t, n, o) {\n        var a = e.shaders[t];\n        if (!a.extensions || !(this.name in a.extensions)) return !1;\n        var i = a.extensions[this.name],\n            s = e.bufferViews[i.bufferView],\n            l = p.GetBufferFromBufferView(e, s, 0, s.byteLength, r.UNSIGNED_BYTE);\n        return setTimeout(function () {\n          var e = p.DecodeBufferToText(l);\n          n(e);\n        }), !0;\n      }, t;\n    }(U);\n\n    G.RegisterExtension(new k());\n\n    var H = function (e) {\n      function t() {\n        return e.call(this, \"KHR_materials_common\") || this;\n      }\n\n      return Object(d.b)(t, e), t.prototype.loadRuntimeExtensionsAsync = function (e, t, n) {\n        if (!e.extensions) return !1;\n        var r = e.extensions[this.name];\n        if (!r) return !1;\n        var o = r.lights;\n        if (o) for (var a in o) {\n          var i = o[a];\n\n          switch (i.type) {\n            case \"ambient\":\n              var s = new h.HemisphericLight(i.name, new h.Vector3(0, 1, 0), e.scene),\n                  l = i.ambient;\n              l && (s.diffuse = h.Color3.FromArray(l.color || [1, 1, 1]));\n              break;\n\n            case \"point\":\n              var u = new h.PointLight(i.name, new h.Vector3(10, 10, 10), e.scene),\n                  c = i.point;\n              c && (u.diffuse = h.Color3.FromArray(c.color || [1, 1, 1]));\n              break;\n\n            case \"directional\":\n              var d = new h.DirectionalLight(i.name, new h.Vector3(0, -1, 0), e.scene),\n                  f = i.directional;\n              f && (d.diffuse = h.Color3.FromArray(f.color || [1, 1, 1]));\n              break;\n\n            case \"spot\":\n              var p = i.spot;\n              if (p) new h.SpotLight(i.name, new h.Vector3(0, 10, 0), new h.Vector3(0, -1, 0), p.fallOffAngle || Math.PI, p.fallOffExponent || 0, e.scene).diffuse = h.Color3.FromArray(p.color || [1, 1, 1]);\n              break;\n\n            default:\n              h.Tools.Warn('GLTF Material Common extension: light type \"' + i.type + \"” not supported\");\n          }\n        }\n        return !1;\n      }, t.prototype.loadMaterialAsync = function (e, t, n, r) {\n        var o = e.materials[t];\n        if (!o || !o.extensions) return !1;\n        var a = o.extensions[this.name];\n        if (!a) return !1;\n        var i = new h.StandardMaterial(t, e.scene);\n        return i.sideOrientation = h.Material.CounterClockWiseSideOrientation, \"CONSTANT\" === a.technique && (i.disableLighting = !0), i.backFaceCulling = void 0 !== a.doubleSided && !a.doubleSided, i.alpha = void 0 === a.values.transparency ? 1 : a.values.transparency, i.specularPower = void 0 === a.values.shininess ? 0 : a.values.shininess, \"string\" == typeof a.values.ambient ? this._loadTexture(e, a.values.ambient, i, \"ambientTexture\", r) : i.ambientColor = h.Color3.FromArray(a.values.ambient || [0, 0, 0]), \"string\" == typeof a.values.diffuse ? this._loadTexture(e, a.values.diffuse, i, \"diffuseTexture\", r) : i.diffuseColor = h.Color3.FromArray(a.values.diffuse || [0, 0, 0]), \"string\" == typeof a.values.emission ? this._loadTexture(e, a.values.emission, i, \"emissiveTexture\", r) : i.emissiveColor = h.Color3.FromArray(a.values.emission || [0, 0, 0]), \"string\" == typeof a.values.specular ? this._loadTexture(e, a.values.specular, i, \"specularTexture\", r) : i.specularColor = h.Color3.FromArray(a.values.specular || [0, 0, 0]), !0;\n      }, t.prototype._loadTexture = function (e, t, n, r, o) {\n        D.LoadTextureBufferAsync(e, t, function (a) {\n          D.CreateTextureAsync(e, t, a, function (e) {\n            return n[r] = e;\n          }, o);\n        }, o);\n      }, t;\n    }(U);\n\n    G.RegisterExtension(new H());\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"ArrayItem\", function () {\n      return r.a;\n    }), n.d(t, \"GLTFLoader\", function () {\n      return r.b;\n    }), n.d(t, \"EXT_lights_image_based\", function () {\n      return o.EXT_lights_image_based;\n    }), n.d(t, \"EXT_mesh_gpu_instancing\", function () {\n      return o.EXT_mesh_gpu_instancing;\n    }), n.d(t, \"EXT_texture_webp\", function () {\n      return o.EXT_texture_webp;\n    }), n.d(t, \"KHR_draco_mesh_compression\", function () {\n      return o.KHR_draco_mesh_compression;\n    }), n.d(t, \"KHR_lights\", function () {\n      return o.KHR_lights;\n    }), n.d(t, \"KHR_materials_pbrSpecularGlossiness\", function () {\n      return o.KHR_materials_pbrSpecularGlossiness;\n    }), n.d(t, \"KHR_materials_unlit\", function () {\n      return o.KHR_materials_unlit;\n    }), n.d(t, \"KHR_materials_clearcoat\", function () {\n      return o.KHR_materials_clearcoat;\n    }), n.d(t, \"KHR_materials_sheen\", function () {\n      return o.KHR_materials_sheen;\n    }), n.d(t, \"KHR_materials_specular\", function () {\n      return o.KHR_materials_specular;\n    }), n.d(t, \"KHR_materials_ior\", function () {\n      return o.KHR_materials_ior;\n    }), n.d(t, \"KHR_materials_variants\", function () {\n      return o.KHR_materials_variants;\n    }), n.d(t, \"KHR_materials_transmission\", function () {\n      return o.KHR_materials_transmission;\n    }), n.d(t, \"KHR_materials_translucency\", function () {\n      return o.KHR_materials_translucency;\n    }), n.d(t, \"KHR_mesh_quantization\", function () {\n      return o.KHR_mesh_quantization;\n    }), n.d(t, \"KHR_texture_basisu\", function () {\n      return o.KHR_texture_basisu;\n    }), n.d(t, \"KHR_texture_transform\", function () {\n      return o.KHR_texture_transform;\n    }), n.d(t, \"MSFT_audio_emitter\", function () {\n      return o.MSFT_audio_emitter;\n    }), n.d(t, \"MSFT_lod\", function () {\n      return o.MSFT_lod;\n    }), n.d(t, \"MSFT_minecraftMesh\", function () {\n      return o.MSFT_minecraftMesh;\n    }), n.d(t, \"MSFT_sRGBFactors\", function () {\n      return o.MSFT_sRGBFactors;\n    }), n.d(t, \"ExtrasAsMetadata\", function () {\n      return o.ExtrasAsMetadata;\n    });\n    var r = n(1),\n        o = (n(6), n(7));\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"MTLFileLoader\", function () {\n      return o;\n    }), n.d(t, \"OBJFileLoader\", function () {\n      return a;\n    });\n\n    var r = n(0),\n        o = function () {\n      function e() {\n        this.materials = [];\n      }\n\n      return e.prototype.parseMTL = function (t, n, o, a) {\n        if (!(n instanceof ArrayBuffer)) {\n          for (var i, s = n.split(\"\\n\"), l = /\\s+/, u = null, c = 0; c < s.length; c++) {\n            var d = s[c].trim();\n\n            if (0 !== d.length && \"#\" !== d.charAt(0)) {\n              var f = d.indexOf(\" \"),\n                  h = f >= 0 ? d.substring(0, f) : d;\n              h = h.toLowerCase();\n              var p = f >= 0 ? d.substring(f + 1).trim() : \"\";\n              \"newmtl\" === h ? (u && this.materials.push(u), t._blockEntityCollection = a, u = new r.StandardMaterial(p, t), t._blockEntityCollection = !1) : \"kd\" === h && u ? (i = p.split(l, 3).map(parseFloat), u.diffuseColor = r.Color3.FromArray(i)) : \"ka\" === h && u ? (i = p.split(l, 3).map(parseFloat), u.ambientColor = r.Color3.FromArray(i)) : \"ks\" === h && u ? (i = p.split(l, 3).map(parseFloat), u.specularColor = r.Color3.FromArray(i)) : \"ke\" === h && u ? (i = p.split(l, 3).map(parseFloat), u.emissiveColor = r.Color3.FromArray(i)) : \"ns\" === h && u ? u.specularPower = parseFloat(p) : \"d\" === h && u ? u.alpha = parseFloat(p) : \"map_ka\" === h && u ? u.ambientTexture = e._getTexture(o, p, t) : \"map_kd\" === h && u ? u.diffuseTexture = e._getTexture(o, p, t) : \"map_ks\" === h && u ? u.specularTexture = e._getTexture(o, p, t) : \"map_ns\" === h || (\"map_bump\" === h && u ? u.bumpTexture = e._getTexture(o, p, t) : \"map_d\" === h && u && (u.opacityTexture = e._getTexture(o, p, t)));\n            }\n          }\n\n          u && this.materials.push(u);\n        }\n      }, e._getTexture = function (t, n, o) {\n        if (!n) return null;\n        var a = t;\n\n        if (\"file:\" === t) {\n          var i = n.lastIndexOf(\"\\\\\");\n          -1 === i && (i = n.lastIndexOf(\"/\")), a += i > -1 ? n.substr(i + 1) : n;\n        } else a += n;\n\n        return new r.Texture(a, o, !1, e.INVERT_TEXTURE_Y);\n      }, e.INVERT_TEXTURE_Y = !0, e;\n    }(),\n        a = function () {\n      function e(t) {\n        this.name = \"obj\", this.extensions = \".obj\", this.obj = /^o/, this.group = /^g/, this.mtllib = /^mtllib /, this.usemtl = /^usemtl /, this.smooth = /^s /, this.vertexPattern = /v(\\s+[\\d|\\.|\\+|\\-|e|E]+){3,7}/, this.normalPattern = /vn(\\s+[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/, this.uvPattern = /vt(\\s+[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/, this.facePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/, this.facePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/, this.facePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/, this.facePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/, this.facePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/, this._forAssetContainer = !1, this._meshLoadOptions = t || e.currentMeshLoadOptions;\n      }\n\n      return Object.defineProperty(e, \"INVERT_TEXTURE_Y\", {\n        get: function get() {\n          return o.INVERT_TEXTURE_Y;\n        },\n        set: function set(e) {\n          o.INVERT_TEXTURE_Y = e;\n        },\n        enumerable: !1,\n        configurable: !0\n      }), Object.defineProperty(e, \"currentMeshLoadOptions\", {\n        get: function get() {\n          return {\n            ComputeNormals: e.COMPUTE_NORMALS,\n            ImportVertexColors: e.IMPORT_VERTEX_COLORS,\n            InvertY: e.INVERT_Y,\n            InvertTextureY: e.INVERT_TEXTURE_Y,\n            UVScaling: e.UV_SCALING,\n            MaterialLoadingFailsSilently: e.MATERIAL_LOADING_FAILS_SILENTLY,\n            OptimizeWithUV: e.OPTIMIZE_WITH_UV,\n            SkipMaterials: e.SKIP_MATERIALS\n          };\n        },\n        enumerable: !1,\n        configurable: !0\n      }), e.prototype._loadMTL = function (e, t, n, o) {\n        var a = r.Tools.BaseUrl + t + e;\n        r.Tools.LoadFile(a, n, void 0, void 0, !1, function (e, t) {\n          o(a, t);\n        });\n      }, e.prototype.createPlugin = function () {\n        return new e(e.currentMeshLoadOptions);\n      }, e.prototype.canDirectLoad = function (e) {\n        return !1;\n      }, e.prototype.importMeshAsync = function (e, t, n, r, o, a) {\n        return this._parseSolid(e, t, n, r).then(function (e) {\n          return {\n            meshes: e,\n            particleSystems: [],\n            skeletons: [],\n            animationGroups: [],\n            transformNodes: [],\n            geometries: [],\n            lights: []\n          };\n        });\n      }, e.prototype.loadAsync = function (e, t, n, r, o) {\n        return this.importMeshAsync(null, e, t, n, r).then(function () {});\n      }, e.prototype.loadAssetContainerAsync = function (e, t, n, o, a) {\n        var i = this;\n        return this._forAssetContainer = !0, this.importMeshAsync(null, e, t, n).then(function (t) {\n          var n = new r.AssetContainer(e);\n          return t.meshes.forEach(function (e) {\n            return n.meshes.push(e);\n          }), t.meshes.forEach(function (e) {\n            var t = e.material;\n            t && -1 == n.materials.indexOf(t) && (n.materials.push(t), t.getActiveTextures().forEach(function (e) {\n              -1 == n.textures.indexOf(e) && n.textures.push(e);\n            }));\n          }), i._forAssetContainer = !1, n;\n        }).catch(function (e) {\n          throw i._forAssetContainer = !1, e;\n        });\n      }, e.prototype._parseSolid = function (t, n, a, i) {\n        for (var s, l = this, u = [], c = [], d = [], f = [], h = [], p = [], _ = [], m = [], y = [], b = [], v = [], g = 0, A = !1, T = [], x = [], E = [], L = [], O = [], M = \"\", S = \"\", w = new o(), R = 1, C = !0, N = new r.Color4(.5, .5, .5, 1), P = function P(e, t, n, r, o, a, i) {\n          var s;\n          -1 === (s = l._meshLoadOptions.OptimizeWithUV ? function (e, t) {\n            e[t[0]] || (e[t[0]] = {\n              normals: [],\n              idx: [],\n              uv: []\n            });\n            var n = e[t[0]].normals.indexOf(t[1]);\n            return 1 != n && t[2] === e[t[0]].uv[n] ? e[t[0]].idx[n] : -1;\n          }(v, [e, n, t]) : function (e, t) {\n            e[t[0]] || (e[t[0]] = {\n              normals: [],\n              idx: []\n            });\n            var n = e[t[0]].normals.indexOf(t[1]);\n            return -1 === n ? -1 : e[t[0]].idx[n];\n          }(v, [e, n])) ? (p.push(_.length), _.push(r), m.push(o), b.push(a), void 0 !== i && y.push(i), v[e].normals.push(n), v[e].idx.push(g++), l._meshLoadOptions.OptimizeWithUV && v[e].uv.push(t)) : p.push(s);\n        }, I = function I() {\n          for (var e = 0; e < _.length; e++) {\n            T.push(_[e].x, _[e].y, _[e].z), E.push(b[e].x, b[e].y, b[e].z), L.push(m[e].x, m[e].y), !0 === l._meshLoadOptions.ImportVertexColors && x.push(y[e].r, y[e].g, y[e].b, y[e].a);\n          }\n\n          _ = [], b = [], m = [], y = [], v = [], g = 0;\n        }, F = function F(e, t) {\n          for (var n = t; n < e.length - 1; n++) {\n            O.push(e[0], e[n], e[n + 1]);\n          }\n        }, B = function B(e, t) {\n          F(e, t);\n\n          for (var n = 0; n < O.length; n++) {\n            var o = parseInt(O[n]) - 1;\n            P(o, 0, 0, u[o], r.Vector2.Zero(), r.Vector3.Up(), !0 === l._meshLoadOptions.ImportVertexColors ? f[o] : void 0);\n          }\n\n          O = [];\n        }, V = function V(e, t) {\n          F(e, t);\n\n          for (var n = 0; n < O.length; n++) {\n            var o = O[n].split(\"/\"),\n                a = parseInt(o[0]) - 1,\n                i = parseInt(o[1]) - 1;\n            P(a, i, 0, u[a], d[i], r.Vector3.Up(), !0 === l._meshLoadOptions.ImportVertexColors ? f[a] : void 0);\n          }\n\n          O = [];\n        }, D = function D(e, t) {\n          F(e, t);\n\n          for (var n = 0; n < O.length; n++) {\n            var r = O[n].split(\"/\"),\n                o = parseInt(r[0]) - 1,\n                a = parseInt(r[1]) - 1,\n                i = parseInt(r[2]) - 1;\n            P(o, a, i, u[o], d[a], c[i]);\n          }\n\n          O = [];\n        }, G = function G(e, t) {\n          F(e, t);\n\n          for (var n = 0; n < O.length; n++) {\n            var o = O[n].split(\"//\"),\n                a = parseInt(o[0]) - 1,\n                i = parseInt(o[1]) - 1;\n            P(a, 1, i, u[a], r.Vector2.Zero(), c[i], !0 === l._meshLoadOptions.ImportVertexColors ? f[a] : void 0);\n          }\n\n          O = [];\n        }, U = function U(e, t) {\n          F(e, t);\n\n          for (var n = 0; n < O.length; n++) {\n            var r = O[n].split(\"/\"),\n                o = u.length + parseInt(r[0]),\n                a = d.length + parseInt(r[1]),\n                i = c.length + parseInt(r[2]);\n            P(o, a, i, u[o], d[a], c[i], !0 === l._meshLoadOptions.ImportVertexColors ? f[o] : void 0);\n          }\n\n          O = [];\n        }, k = function k() {\n          h.length > 0 && (s = h[h.length - 1], I(), p.reverse(), s.indices = p.slice(), s.positions = T.slice(), s.normals = E.slice(), s.uvs = L.slice(), !0 === l._meshLoadOptions.ImportVertexColors && (s.colors = x.slice()), p = [], T = [], x = [], E = [], L = []);\n        }, H = a.split(\"\\n\"), K = 0; K < H.length; K++) {\n          var j,\n              W = H[K].trim().replace(/\\s\\s/g, \" \");\n          if (0 !== W.length && \"#\" !== W.charAt(0)) if (this.vertexPattern.test(W)) j = W.match(/[^ ]+/g), u.push(new r.Vector3(parseFloat(j[1]), parseFloat(j[2]), parseFloat(j[3]))), !0 === this._meshLoadOptions.ImportVertexColors && (j.length >= 7 ? f.push(new r.Color4(parseFloat(j[4]), parseFloat(j[5]), parseFloat(j[6]), 7 === j.length || void 0 === j[7] ? 1 : parseFloat(j[7]))) : f.push(N));else if (null !== (j = this.normalPattern.exec(W))) c.push(new r.Vector3(parseFloat(j[1]), parseFloat(j[2]), parseFloat(j[3])));else if (null !== (j = this.uvPattern.exec(W))) d.push(new r.Vector2(parseFloat(j[1]) * e.UV_SCALING.x, parseFloat(j[2]) * e.UV_SCALING.y));else if (null !== (j = this.facePattern3.exec(W))) D(j[1].trim().split(\" \"), 1);else if (null !== (j = this.facePattern4.exec(W))) G(j[1].trim().split(\" \"), 1);else if (null !== (j = this.facePattern5.exec(W))) U(j[1].trim().split(\" \"), 1);else if (null !== (j = this.facePattern2.exec(W))) V(j[1].trim().split(\" \"), 1);else if (null !== (j = this.facePattern1.exec(W))) B(j[1].trim().split(\" \"), 1);else if (this.group.test(W) || this.obj.test(W)) {\n            var q = {\n              name: W.substring(2).trim(),\n              indices: void 0,\n              positions: void 0,\n              normals: void 0,\n              uvs: void 0,\n              colors: void 0,\n              materialName: \"\"\n            };\n            k(), h.push(q), A = !0, C = !0, R = 1;\n          } else if (this.usemtl.test(W)) {\n            if (M = W.substring(7).trim(), !C || !A) {\n              k();\n              q = {\n                name: \"mesh_mm\" + R.toString(),\n                indices: void 0,\n                positions: void 0,\n                normals: void 0,\n                uvs: void 0,\n                colors: void 0,\n                materialName: M\n              };\n              R++, h.push(q), A = !0;\n            }\n\n            A && C && (h[h.length - 1].materialName = M, C = !1);\n          } else this.mtllib.test(W) ? S = W.substring(7).trim() : this.smooth.test(W) || console.log(\"Unhandled expression at line : \" + W);\n        }\n\n        A && (s = h[h.length - 1], p.reverse(), I(), s.indices = p, s.positions = T, s.normals = E, s.uvs = L, !0 === this._meshLoadOptions.ImportVertexColors && (s.colors = x)), A || (p.reverse(), I(), h.push({\n          name: r.Geometry.RandomId(),\n          indices: p,\n          positions: T,\n          colors: x,\n          normals: E,\n          uvs: L,\n          materialName: M\n        }));\n\n        for (var Y = [], X = new Array(), J = 0; J < h.length; J++) {\n          if (t && h[J].name) if (t instanceof Array) {\n            if (-1 === t.indexOf(h[J].name)) continue;\n          } else if (h[J].name !== t) continue;\n          s = h[J], n._blockEntityCollection = this._forAssetContainer;\n          var Q = new r.Mesh(h[J].name, n);\n          n._blockEntityCollection = !1, X.push(h[J].materialName);\n          var z = new r.VertexData();\n\n          if (z.uvs = s.uvs, z.indices = s.indices, z.positions = s.positions, !0 === this._meshLoadOptions.ComputeNormals) {\n            var Z = new Array();\n            r.VertexData.ComputeNormals(s.positions, s.indices, Z), z.normals = Z;\n          } else z.normals = s.normals;\n\n          !0 === this._meshLoadOptions.ImportVertexColors && (z.colors = s.colors), z.applyToMesh(Q), this._meshLoadOptions.InvertY && (Q.scaling.y *= -1), Y.push(Q);\n        }\n\n        var $ = [];\n        return \"\" !== S && !1 === this._meshLoadOptions.SkipMaterials && $.push(new Promise(function (e, t) {\n          l._loadMTL(S, i, function (o) {\n            try {\n              w.parseMTL(n, o, i, l._forAssetContainer);\n\n              for (var a = 0; a < w.materials.length; a++) {\n                for (var s, u = 0, c = []; (s = X.indexOf(w.materials[a].name, u)) > -1;) {\n                  c.push(s), u = s + 1;\n                }\n\n                if (-1 === s && 0 === c.length) w.materials[a].dispose();else for (var d = 0; d < c.length; d++) {\n                  Y[c[d]].material = w.materials[a];\n                }\n              }\n\n              e();\n            } catch (n) {\n              r.Tools.Warn(\"Error processing MTL file: '\" + S + \"'\"), l._meshLoadOptions.MaterialLoadingFailsSilently ? e() : t(n);\n            }\n          }, function (n, o) {\n            r.Tools.Warn(\"Error downloading MTL file: '\" + S + \"'\"), l._meshLoadOptions.MaterialLoadingFailsSilently ? e() : t(o);\n          });\n        })), Promise.all($).then(function () {\n          return Y;\n        });\n      }, e.OPTIMIZE_WITH_UV = !0, e.INVERT_Y = !1, e.IMPORT_VERTEX_COLORS = !1, e.COMPUTE_NORMALS = !1, e.UV_SCALING = new r.Vector2(1, 1), e.SKIP_MATERIALS = !1, e.MATERIAL_LOADING_FAILS_SILENTLY = !0, e;\n    }();\n\n    r.SceneLoader && r.SceneLoader.RegisterPlugin(new a());\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"STLFileLoader\", function () {\n      return o;\n    });\n\n    var r = n(0),\n        o = function () {\n      function e() {\n        this.solidPattern = /solid (\\S*)([\\S\\s]*?)endsolid[ ]*(\\S*)/g, this.facetsPattern = /facet([\\s\\S]*?)endfacet/g, this.normalPattern = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g, this.vertexPattern = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g, this.name = \"stl\", this.extensions = {\n          \".stl\": {\n            isBinary: !0\n          }\n        };\n      }\n\n      return e.prototype.importMesh = function (e, t, n, o, a, i, s) {\n        var l;\n\n        if (\"string\" != typeof n) {\n          if (this._isBinary(n)) {\n            var u = new r.Mesh(\"stlmesh\", t);\n            return this._parseBinary(u, n), a && a.push(u), !0;\n          }\n\n          for (var c = new Uint8Array(n), d = \"\", f = 0; f < n.byteLength; f++) {\n            d += String.fromCharCode(c[f]);\n          }\n\n          n = d;\n        }\n\n        for (; l = this.solidPattern.exec(n);) {\n          var h = l[1];\n          if (h != l[3]) return r.Tools.Error(\"Error in STL, solid name != endsolid name\"), !1;\n          if (e && h) if (e instanceof Array) {\n            if (!e.indexOf(h)) continue;\n          } else if (h !== e) continue;\n          h = h || \"stlmesh\";\n          u = new r.Mesh(h, t);\n          this._parseASCII(u, l[2]), a && a.push(u);\n        }\n\n        return !0;\n      }, e.prototype.load = function (e, t, n) {\n        return this.importMesh(null, e, t, n, null, null, null);\n      }, e.prototype.loadAssetContainer = function (e, t, n, o) {\n        var a = new r.AssetContainer(e);\n        return e._blockEntityCollection = !0, this.importMesh(null, e, t, n, a.meshes, null, null), e._blockEntityCollection = !1, a;\n      }, e.prototype._isBinary = function (e) {\n        var t;\n        if (50, 84 + 50 * (t = new DataView(e)).getUint32(80, !0) === t.byteLength) return !0;\n\n        for (var n = t.byteLength, r = 0; r < n; r++) {\n          if (t.getUint8(r) > 127) return !0;\n        }\n\n        return !1;\n      }, e.prototype._parseBinary = function (e, t) {\n        for (var n = new DataView(t), o = n.getUint32(80, !0), a = 0, i = new Float32Array(3 * o * 3), s = new Float32Array(3 * o * 3), l = new Uint32Array(3 * o), u = 0, c = 0; c < o; c++) {\n          for (var d = 84 + 50 * c, f = n.getFloat32(d, !0), h = n.getFloat32(d + 4, !0), p = n.getFloat32(d + 8, !0), _ = 1; _ <= 3; _++) {\n            var m = d + 12 * _;\n            i[a] = n.getFloat32(m, !0), i[a + 2] = n.getFloat32(m + 4, !0), i[a + 1] = n.getFloat32(m + 8, !0), s[a] = f, s[a + 2] = h, s[a + 1] = p, a += 3;\n          }\n\n          l[u] = u++, l[u] = u++, l[u] = u++;\n        }\n\n        e.setVerticesData(r.VertexBuffer.PositionKind, i), e.setVerticesData(r.VertexBuffer.NormalKind, s), e.setIndices(l), e.computeWorldMatrix(!0);\n      }, e.prototype._parseASCII = function (e, t) {\n        for (var n, o = [], a = [], i = [], s = 0; n = this.facetsPattern.exec(t);) {\n          var l = n[1],\n              u = this.normalPattern.exec(l);\n\n          if (this.normalPattern.lastIndex = 0, u) {\n            for (var c, d = [Number(u[1]), Number(u[5]), Number(u[3])]; c = this.vertexPattern.exec(l);) {\n              o.push(Number(c[1]), Number(c[5]), Number(c[3])), a.push(d[0], d[1], d[2]);\n            }\n\n            i.push(s++, s++, s++), this.vertexPattern.lastIndex = 0;\n          }\n        }\n\n        this.facetsPattern.lastIndex = 0, e.setVerticesData(r.VertexBuffer.PositionKind, o), e.setVerticesData(r.VertexBuffer.NormalKind, a), e.setIndices(i), e.computeWorldMatrix(!0);\n      }, e;\n    }();\n\n    r.SceneLoader && r.SceneLoader.RegisterPlugin(new o());\n  }, function (e, t, n) {\n    \"use strict\";\n\n    (function (e) {\n      var r = n(2),\n          o = n(3);\n      n.d(t, \"a\", function () {\n        return r.GLTFFileLoader;\n      }), n.d(t, \"b\", function () {\n        return r.GLTFLoaderAnimationStartMode;\n      }), n.d(t, \"c\", function () {\n        return r.GLTFLoaderCoordinateSystemMode;\n      }), n.d(t, \"d\", function () {\n        return r.GLTFLoaderState;\n      }), n.d(t, \"e\", function () {\n        return o.GLTFValidation;\n      });\n      var a = void 0 !== e ? e : \"undefined\" != typeof window ? window : void 0;\n\n      if (void 0 !== a) {\n        for (var i in a.BABYLON = a.BABYLON || {}, r) {\n          a.BABYLON[i] = r[i];\n        }\n\n        for (var i in o) {\n          a.BABYLON[i] = o[i];\n        }\n      }\n    }).call(this, n(5));\n  }, function (e, t, n) {\n    \"use strict\";\n\n    (function (e) {\n      var r = n(8);\n      n.d(t, \"a\", function () {\n        return r;\n      });\n      var o = void 0 !== e ? e : \"undefined\" != typeof window ? window : void 0;\n      if (void 0 !== o) for (var a in o.BABYLON = o.BABYLON || {}, o.BABYLON.GLTF1 = o.BABYLON.GLTF1 || {}, r) {\n        o.BABYLON.GLTF1[a] = r[a];\n      }\n    }).call(this, n(5));\n  }, function (e, t, n) {\n    \"use strict\";\n\n    (function (e) {\n      var r = n(7),\n          o = n(6),\n          a = n(9);\n      n.d(t, \"a\", function () {\n        return a;\n      });\n      var i = void 0 !== e ? e : \"undefined\" != typeof window ? window : void 0;\n\n      if (void 0 !== i) {\n        i.BABYLON = i.BABYLON || {};\n        var s = i.BABYLON;\n        s.GLTF2 = s.GLTF2 || {}, s.GLTF2.Loader = s.GLTF2.Loader || {}, s.GLTF2.Loader.Extensions = s.GLTF2.Loader.Extensions || {};\n        var l = [];\n\n        for (var u in r) {\n          s.GLTF2.Loader.Extensions[u] = r[u], l.push(u);\n        }\n\n        for (var u in o) {\n          s.GLTF2.Loader[u] = o[u], l.push(u);\n        }\n\n        for (var u in a) {\n          l.indexOf(u) > -1 || (s.GLTF2[u] = a[u]);\n        }\n      }\n    }).call(this, n(5));\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), function (e) {\n      var r = n(10);\n      n.d(t, \"MTLFileLoader\", function () {\n        return r.MTLFileLoader;\n      }), n.d(t, \"OBJFileLoader\", function () {\n        return r.OBJFileLoader;\n      });\n      var o = void 0 !== e ? e : \"undefined\" != typeof window ? window : void 0;\n      if (void 0 !== o) for (var a in r) {\n        o.BABYLON[a] = r[a];\n      }\n    }.call(this, n(5));\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), function (e) {\n      var r = n(11);\n      n.d(t, \"STLFileLoader\", function () {\n        return r.STLFileLoader;\n      });\n      var o = void 0 !== e ? e : \"undefined\" != typeof window ? window : void 0;\n      if (void 0 !== o) for (var a in r) {\n        o.BABYLON[a] = r[a];\n      }\n    }.call(this, n(5));\n  },,,, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"GLTFLoaderCoordinateSystemMode\", function () {\n      return r.c;\n    }), n.d(t, \"GLTFLoaderAnimationStartMode\", function () {\n      return r.b;\n    }), n.d(t, \"GLTFLoaderState\", function () {\n      return r.d;\n    }), n.d(t, \"GLTFFileLoader\", function () {\n      return r.a;\n    }), n.d(t, \"GLTFValidation\", function () {\n      return r.e;\n    }), n.d(t, \"GLTF1\", function () {\n      return o.a;\n    }), n.d(t, \"GLTF2\", function () {\n      return a.a;\n    }), n.d(t, \"MTLFileLoader\", function () {\n      return i.MTLFileLoader;\n    }), n.d(t, \"OBJFileLoader\", function () {\n      return i.OBJFileLoader;\n    }), n.d(t, \"STLFileLoader\", function () {\n      return s.STLFileLoader;\n    });\n    n(2), n(3), n(8), n(9), n(10), n(11);\n    var r = n(12),\n        o = n(13),\n        a = n(14),\n        i = n(15),\n        s = n(16);\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}