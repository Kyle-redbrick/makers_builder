{"ast":null,"code":"/**\n * Browser Image Compression\n * v1.0.14\n * by Donald <donaldcwl@gmail.com>\n * https://github.com/Donaldcwl/browser-image-compression\n */\nfunction _defineProperty(e, r, t) {\n  return r in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var a = Object.getOwnPropertySymbols(e);\n    r && (a = a.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, a);\n  }\n\n  return t;\n}\n\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _slicedToArray(e, r) {\n  return _arrayWithHoles(e) || _iterableToArrayLimit(e, r) || _unsupportedIterableToArray(e, r) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(e) {\n  if (Array.isArray(e)) return e;\n}\n\nfunction _iterableToArrayLimit(e, r) {\n  if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) {\n    var t = [],\n        a = !0,\n        i = !1,\n        f = void 0;\n\n    try {\n      for (var c, s = e[Symbol.iterator](); !(a = (c = s.next()).done) && (t.push(c.value), !r || t.length !== r); a = !0) {\n        ;\n      }\n    } catch (e) {\n      i = !0, f = e;\n    } finally {\n      try {\n        a || null == s.return || s.return();\n      } finally {\n        if (i) throw f;\n      }\n    }\n\n    return t;\n  }\n}\n\nfunction _unsupportedIterableToArray(e, r) {\n  if (e) {\n    if (\"string\" == typeof e) return _arrayLikeToArray(e, r);\n    var t = Object.prototype.toString.call(e).slice(8, -1);\n    return \"Object\" === t && e.constructor && (t = e.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(e) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(e, r) : void 0;\n  }\n}\n\nfunction _arrayLikeToArray(e, r) {\n  (null == r || r > e.length) && (r = e.length);\n\n  for (var t = 0, a = new Array(r); t < r; t++) {\n    a[t] = e[t];\n  }\n\n  return a;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction createCommonjsModule(e) {\n  var r = {\n    exports: {}\n  };\n  return e(r, r.exports), r.exports;\n}\n\nvar UZIP_1 = createCommonjsModule(function (e) {\n  var r,\n      t,\n      UZIP = {};\n  e.exports = UZIP, UZIP.parse = function (e, r) {\n    for (var t = UZIP.bin.readUshort, a = UZIP.bin.readUint, i = 0, f = {}, c = new Uint8Array(e), s = c.length - 4; 101010256 != a(c, s);) {\n      s--;\n    }\n\n    i = s;\n    i += 4;\n    var l = t(c, i += 4),\n        u = (t(c, i += 2), a(c, i += 2)),\n        d = a(c, i += 4);\n    i += 4, i = d;\n\n    for (var h = 0; h < l; h++) {\n      a(c, i);\n      i += 4, i += 4, i += 4;\n      a(c, i += 4), u = a(c, i += 4);\n      var A = a(c, i += 4),\n          v = t(c, i += 4),\n          p = t(c, i + 2),\n          U = t(c, i + 4);\n      i += 6;\n      var g = a(c, i += 8);\n      i += 4, i += v + p + U, UZIP._readLocal(c, g, f, u, A, r);\n    }\n\n    return f;\n  }, UZIP._readLocal = function (e, r, t, a, i, f) {\n    var c = UZIP.bin.readUshort,\n        s = UZIP.bin.readUint,\n        l = (s(e, r), c(e, r += 4), c(e, r += 2), c(e, r += 2));\n    s(e, r += 2), s(e, r += 4);\n    r += 4;\n    var u = c(e, r += 8),\n        d = c(e, r += 2);\n    r += 2;\n    var h = UZIP.bin.readUTF8(e, r, u);\n    if (r += u, r += d, f) t[h] = {\n      size: i,\n      csize: a\n    };else {\n      var A = new Uint8Array(e.buffer, r);\n      if (0 == l) t[h] = new Uint8Array(A.buffer.slice(r, r + a));else {\n        if (8 != l) throw \"unknown compression method: \" + l;\n        var v = new Uint8Array(i);\n        UZIP.inflateRaw(A, v), t[h] = v;\n      }\n    }\n  }, UZIP.inflateRaw = function (e, r) {\n    return UZIP.F.inflate(e, r);\n  }, UZIP.inflate = function (e, r) {\n    e[0], e[1];\n    return UZIP.inflateRaw(new Uint8Array(e.buffer, e.byteOffset + 2, e.length - 6), r);\n  }, UZIP.deflate = function (e, r) {\n    null == r && (r = {\n      level: 6\n    });\n    var t = 0,\n        a = new Uint8Array(50 + Math.floor(1.1 * e.length));\n    a[t] = 120, a[t + 1] = 156, t += 2, t = UZIP.F.deflateRaw(e, a, t, r.level);\n    var i = UZIP.adler(e, 0, e.length);\n    return a[t + 0] = i >>> 24 & 255, a[t + 1] = i >>> 16 & 255, a[t + 2] = i >>> 8 & 255, a[t + 3] = i >>> 0 & 255, new Uint8Array(a.buffer, 0, t + 4);\n  }, UZIP.deflateRaw = function (e, r) {\n    null == r && (r = {\n      level: 6\n    });\n    var t = new Uint8Array(50 + Math.floor(1.1 * e.length)),\n        a = UZIP.F.deflateRaw(e, t, a, r.level);\n    return new Uint8Array(t.buffer, 0, a);\n  }, UZIP.encode = function (e, r) {\n    null == r && (r = !1);\n    var t = 0,\n        a = UZIP.bin.writeUint,\n        i = UZIP.bin.writeUshort,\n        f = {};\n\n    for (var c in e) {\n      var s = !UZIP._noNeed(c) && !r,\n          l = e[c],\n          u = UZIP.crc.crc(l, 0, l.length);\n      f[c] = {\n        cpr: s,\n        usize: l.length,\n        crc: u,\n        file: s ? UZIP.deflateRaw(l) : l\n      };\n    }\n\n    for (var c in f) {\n      t += f[c].file.length + 30 + 46 + 2 * UZIP.bin.sizeUTF8(c);\n    }\n\n    t += 22;\n    var d = new Uint8Array(t),\n        h = 0,\n        A = [];\n\n    for (var c in f) {\n      var v = f[c];\n      A.push(h), h = UZIP._writeHeader(d, h, c, v, 0);\n    }\n\n    var p = 0,\n        U = h;\n\n    for (var c in f) {\n      v = f[c];\n      A.push(h), h = UZIP._writeHeader(d, h, c, v, 1, A[p++]);\n    }\n\n    var g = h - U;\n    return a(d, h, 101010256), h += 4, i(d, h += 4, p), i(d, h += 2, p), a(d, h += 2, g), a(d, h += 4, U), h += 4, h += 2, d.buffer;\n  }, UZIP._noNeed = function (e) {\n    var r = e.split(\".\").pop().toLowerCase();\n    return -1 != \"png,jpg,jpeg,zip\".indexOf(r);\n  }, UZIP._writeHeader = function (e, r, t, a, i, f) {\n    var c = UZIP.bin.writeUint,\n        s = UZIP.bin.writeUshort,\n        l = a.file;\n    return c(e, r, 0 == i ? 67324752 : 33639248), r += 4, 1 == i && (r += 2), s(e, r, 20), s(e, r += 2, 0), s(e, r += 2, a.cpr ? 8 : 0), c(e, r += 2, 0), c(e, r += 4, a.crc), c(e, r += 4, l.length), c(e, r += 4, a.usize), s(e, r += 4, UZIP.bin.sizeUTF8(t)), s(e, r += 2, 0), r += 2, 1 == i && (r += 2, r += 2, c(e, r += 6, f), r += 4), r += UZIP.bin.writeUTF8(e, r, t), 0 == i && (e.set(l, r), r += l.length), r;\n  }, UZIP.crc = {\n    table: function () {\n      for (var e = new Uint32Array(256), r = 0; r < 256; r++) {\n        for (var t = r, a = 0; a < 8; a++) {\n          1 & t ? t = 3988292384 ^ t >>> 1 : t >>>= 1;\n        }\n\n        e[r] = t;\n      }\n\n      return e;\n    }(),\n    update: function update(e, r, t, a) {\n      for (var i = 0; i < a; i++) {\n        e = UZIP.crc.table[255 & (e ^ r[t + i])] ^ e >>> 8;\n      }\n\n      return e;\n    },\n    crc: function crc(e, r, t) {\n      return 4294967295 ^ UZIP.crc.update(4294967295, e, r, t);\n    }\n  }, UZIP.adler = function (e, r, t) {\n    for (var a = 1, i = 0, f = r, c = r + t; f < c;) {\n      for (var s = Math.min(f + 5552, c); f < s;) {\n        i += a += e[f++];\n      }\n\n      a %= 65521, i %= 65521;\n    }\n\n    return i << 16 | a;\n  }, UZIP.bin = {\n    readUshort: function readUshort(e, r) {\n      return e[r] | e[r + 1] << 8;\n    },\n    writeUshort: function writeUshort(e, r, t) {\n      e[r] = 255 & t, e[r + 1] = t >> 8 & 255;\n    },\n    readUint: function readUint(e, r) {\n      return 16777216 * e[r + 3] + (e[r + 2] << 16 | e[r + 1] << 8 | e[r]);\n    },\n    writeUint: function writeUint(e, r, t) {\n      e[r] = 255 & t, e[r + 1] = t >> 8 & 255, e[r + 2] = t >> 16 & 255, e[r + 3] = t >> 24 & 255;\n    },\n    readASCII: function readASCII(e, r, t) {\n      for (var a = \"\", i = 0; i < t; i++) {\n        a += String.fromCharCode(e[r + i]);\n      }\n\n      return a;\n    },\n    writeASCII: function writeASCII(e, r, t) {\n      for (var a = 0; a < t.length; a++) {\n        e[r + a] = t.charCodeAt(a);\n      }\n    },\n    pad: function pad(e) {\n      return e.length < 2 ? \"0\" + e : e;\n    },\n    readUTF8: function readUTF8(e, r, t) {\n      for (var a, i = \"\", f = 0; f < t; f++) {\n        i += \"%\" + UZIP.bin.pad(e[r + f].toString(16));\n      }\n\n      try {\n        a = decodeURIComponent(i);\n      } catch (a) {\n        return UZIP.bin.readASCII(e, r, t);\n      }\n\n      return a;\n    },\n    writeUTF8: function writeUTF8(e, r, t) {\n      for (var a = t.length, i = 0, f = 0; f < a; f++) {\n        var c = t.charCodeAt(f);\n        if (0 == (4294967168 & c)) e[r + i] = c, i++;else if (0 == (4294965248 & c)) e[r + i] = 192 | c >> 6, e[r + i + 1] = 128 | c >> 0 & 63, i += 2;else if (0 == (4294901760 & c)) e[r + i] = 224 | c >> 12, e[r + i + 1] = 128 | c >> 6 & 63, e[r + i + 2] = 128 | c >> 0 & 63, i += 3;else {\n          if (0 != (4292870144 & c)) throw \"e\";\n          e[r + i] = 240 | c >> 18, e[r + i + 1] = 128 | c >> 12 & 63, e[r + i + 2] = 128 | c >> 6 & 63, e[r + i + 3] = 128 | c >> 0 & 63, i += 4;\n        }\n      }\n\n      return i;\n    },\n    sizeUTF8: function sizeUTF8(e) {\n      for (var r = e.length, t = 0, a = 0; a < r; a++) {\n        var i = e.charCodeAt(a);\n        if (0 == (4294967168 & i)) t++;else if (0 == (4294965248 & i)) t += 2;else if (0 == (4294901760 & i)) t += 3;else {\n          if (0 != (4292870144 & i)) throw \"e\";\n          t += 4;\n        }\n      }\n\n      return t;\n    }\n  }, UZIP.F = {}, UZIP.F.deflateRaw = function (e, r, t, a) {\n    var i = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][a],\n        f = UZIP.F.U,\n        c = UZIP.F._goodIndex,\n        s = (UZIP.F._hash, UZIP.F._putsE),\n        l = 0,\n        u = t << 3,\n        d = 0,\n        h = e.length;\n\n    if (0 == a) {\n      for (; l < h;) {\n        s(r, u, l + (I = Math.min(65535, h - l)) == h ? 1 : 0), u = UZIP.F._copyExact(e, l, I, r, u + 8), l += I;\n      }\n\n      return u >>> 3;\n    }\n\n    var A = f.lits,\n        v = f.strt,\n        p = f.prev,\n        U = 0,\n        g = 0,\n        m = 0,\n        w = 0,\n        P = 0,\n        b = 0;\n\n    for (h > 2 && (v[b = UZIP.F._hash(e, 0)] = 0), l = 0; l < h; l++) {\n      if (P = b, l + 1 < h - 2) {\n        b = UZIP.F._hash(e, l + 1);\n\n        var _ = l + 1 & 32767;\n\n        p[_] = v[b], v[b] = _;\n      }\n\n      if (d <= l) {\n        (U > 14e3 || g > 26697) && h - l > 100 && (d < l && (A[U] = l - d, U += 2, d = l), u = UZIP.F._writeBlock(l == h - 1 || d == h ? 1 : 0, A, U, w, e, m, l - m, r, u), U = g = w = 0, m = l);\n        var y = 0;\n        l < h - 2 && (y = UZIP.F._bestMatch(e, l, p, P, Math.min(i[2], h - l), i[3]));\n        var I = y >>> 16,\n            F = 65535 & y;\n\n        if (0 != y) {\n          F = 65535 & y;\n          var G = c(I = y >>> 16, f.of0);\n          f.lhst[257 + G]++;\n          var C = c(F, f.df0);\n          f.dhst[C]++, w += f.exb[G] + f.dxb[C], A[U] = I << 23 | l - d, A[U + 1] = F << 16 | G << 8 | C, U += 2, d = l + I;\n        } else f.lhst[e[l]]++;\n\n        g++;\n      }\n    }\n\n    for (m == l && 0 != e.length || (d < l && (A[U] = l - d, U += 2, d = l), u = UZIP.F._writeBlock(1, A, U, w, e, m, l - m, r, u), U = 0, g = 0, U = g = w = 0, m = l); 0 != (7 & u);) {\n      u++;\n    }\n\n    return u >>> 3;\n  }, UZIP.F._bestMatch = function (e, r, t, a, i, f) {\n    var c = 32767 & r,\n        s = t[c],\n        l = c - s + 32768 & 32767;\n    if (s == c || a != UZIP.F._hash(e, r - l)) return 0;\n\n    for (var u = 0, d = 0, h = Math.min(32767, r); l <= h && 0 != --f && s != c;) {\n      if (0 == u || e[r + u] == e[r + u - l]) {\n        var A = UZIP.F._howLong(e, r, l);\n\n        if (A > u) {\n          if (d = l, (u = A) >= i) break;\n          l + 2 < A && (A = l + 2);\n\n          for (var v = 0, p = 0; p < A - 2; p++) {\n            var U = r - l + p + 32768 & 32767,\n                g = U - t[U] + 32768 & 32767;\n            g > v && (v = g, s = U);\n          }\n        }\n      }\n\n      l += (c = s) - (s = t[c]) + 32768 & 32767;\n    }\n\n    return u << 16 | d;\n  }, UZIP.F._howLong = function (e, r, t) {\n    if (e[r] != e[r - t] || e[r + 1] != e[r + 1 - t] || e[r + 2] != e[r + 2 - t]) return 0;\n    var a = r,\n        i = Math.min(e.length, r + 258);\n\n    for (r += 3; r < i && e[r] == e[r - t];) {\n      r++;\n    }\n\n    return r - a;\n  }, UZIP.F._hash = function (e, r) {\n    return (e[r] << 8 | e[r + 1]) + (e[r + 2] << 4) & 65535;\n  }, UZIP.saved = 0, UZIP.F._writeBlock = function (e, r, t, a, i, f, c, s, l) {\n    var u,\n        d,\n        h,\n        A,\n        v,\n        p,\n        U,\n        g,\n        m,\n        w = UZIP.F.U,\n        P = UZIP.F._putsF,\n        b = UZIP.F._putsE;\n    w.lhst[256]++, d = (u = UZIP.F.getTrees())[0], h = u[1], A = u[2], v = u[3], p = u[4], U = u[5], g = u[6], m = u[7];\n\n    var _ = 32 + (0 == (l + 3 & 7) ? 0 : 8 - (l + 3 & 7)) + (c << 3),\n        y = a + UZIP.F.contSize(w.fltree, w.lhst) + UZIP.F.contSize(w.fdtree, w.dhst),\n        I = a + UZIP.F.contSize(w.ltree, w.lhst) + UZIP.F.contSize(w.dtree, w.dhst);\n\n    I += 14 + 3 * U + UZIP.F.contSize(w.itree, w.ihst) + (2 * w.ihst[16] + 3 * w.ihst[17] + 7 * w.ihst[18]);\n\n    for (var F = 0; F < 286; F++) {\n      w.lhst[F] = 0;\n    }\n\n    for (F = 0; F < 30; F++) {\n      w.dhst[F] = 0;\n    }\n\n    for (F = 0; F < 19; F++) {\n      w.ihst[F] = 0;\n    }\n\n    var G = _ < y && _ < I ? 0 : y < I ? 1 : 2;\n\n    if (P(s, l, e), P(s, l + 1, G), l += 3, 0 == G) {\n      for (; 0 != (7 & l);) {\n        l++;\n      }\n\n      l = UZIP.F._copyExact(i, f, c, s, l);\n    } else {\n      var C, E;\n\n      if (1 == G && (C = w.fltree, E = w.fdtree), 2 == G) {\n        UZIP.F.makeCodes(w.ltree, d), UZIP.F.revCodes(w.ltree, d), UZIP.F.makeCodes(w.dtree, h), UZIP.F.revCodes(w.dtree, h), UZIP.F.makeCodes(w.itree, A), UZIP.F.revCodes(w.itree, A), C = w.ltree, E = w.dtree, b(s, l, v - 257), b(s, l += 5, p - 1), b(s, l += 5, U - 4), l += 4;\n\n        for (var B = 0; B < U; B++) {\n          b(s, l + 3 * B, w.itree[1 + (w.ordr[B] << 1)]);\n        }\n\n        l += 3 * U, l = UZIP.F._codeTiny(g, w.itree, s, l), l = UZIP.F._codeTiny(m, w.itree, s, l);\n      }\n\n      for (var Z = f, x = 0; x < t; x += 2) {\n        for (var M = r[x], R = M >>> 23, Q = Z + (8388607 & M); Z < Q;) {\n          l = UZIP.F._writeLit(i[Z++], C, s, l);\n        }\n\n        if (0 != R) {\n          var T = r[x + 1],\n              D = T >> 16,\n              O = T >> 8 & 255,\n              V = 255 & T;\n          b(s, l = UZIP.F._writeLit(257 + O, C, s, l), R - w.of0[O]), l += w.exb[O], P(s, l = UZIP.F._writeLit(V, E, s, l), D - w.df0[V]), l += w.dxb[V], Z += R;\n        }\n      }\n\n      l = UZIP.F._writeLit(256, C, s, l);\n    }\n\n    return l;\n  }, UZIP.F._copyExact = function (e, r, t, a, i) {\n    var f = i >>> 3;\n    return a[f] = t, a[f + 1] = t >>> 8, a[f + 2] = 255 - a[f], a[f + 3] = 255 - a[f + 1], f += 4, a.set(new Uint8Array(e.buffer, r, t), f), i + (t + 4 << 3);\n  }, UZIP.F.getTrees = function () {\n    for (var e = UZIP.F.U, r = UZIP.F._hufTree(e.lhst, e.ltree, 15), t = UZIP.F._hufTree(e.dhst, e.dtree, 15), a = [], i = UZIP.F._lenCodes(e.ltree, a), f = [], c = UZIP.F._lenCodes(e.dtree, f), s = 0; s < a.length; s += 2) {\n      e.ihst[a[s]]++;\n    }\n\n    for (s = 0; s < f.length; s += 2) {\n      e.ihst[f[s]]++;\n    }\n\n    for (var l = UZIP.F._hufTree(e.ihst, e.itree, 7), u = 19; u > 4 && 0 == e.itree[1 + (e.ordr[u - 1] << 1)];) {\n      u--;\n    }\n\n    return [r, t, l, i, c, u, a, f];\n  }, UZIP.F.getSecond = function (e) {\n    for (var r = [], t = 0; t < e.length; t += 2) {\n      r.push(e[t + 1]);\n    }\n\n    return r;\n  }, UZIP.F.nonZero = function (e) {\n    for (var r = \"\", t = 0; t < e.length; t += 2) {\n      0 != e[t + 1] && (r += (t >> 1) + \",\");\n    }\n\n    return r;\n  }, UZIP.F.contSize = function (e, r) {\n    for (var t = 0, a = 0; a < r.length; a++) {\n      t += r[a] * e[1 + (a << 1)];\n    }\n\n    return t;\n  }, UZIP.F._codeTiny = function (e, r, t, a) {\n    for (var i = 0; i < e.length; i += 2) {\n      var f = e[i],\n          c = e[i + 1];\n      a = UZIP.F._writeLit(f, r, t, a);\n      var s = 16 == f ? 2 : 17 == f ? 3 : 7;\n      f > 15 && (UZIP.F._putsE(t, a, c, s), a += s);\n    }\n\n    return a;\n  }, UZIP.F._lenCodes = function (e, r) {\n    for (var t = e.length; 2 != t && 0 == e[t - 1];) {\n      t -= 2;\n    }\n\n    for (var a = 0; a < t; a += 2) {\n      var i = e[a + 1],\n          f = a + 3 < t ? e[a + 3] : -1,\n          c = a + 5 < t ? e[a + 5] : -1,\n          s = 0 == a ? -1 : e[a - 1];\n\n      if (0 == i && f == i && c == i) {\n        for (var l = a + 5; l + 2 < t && e[l + 2] == i;) {\n          l += 2;\n        }\n\n        (u = Math.min(l + 1 - a >>> 1, 138)) < 11 ? r.push(17, u - 3) : r.push(18, u - 11), a += 2 * u - 2;\n      } else if (i == s && f == i && c == i) {\n        for (l = a + 5; l + 2 < t && e[l + 2] == i;) {\n          l += 2;\n        }\n\n        var u = Math.min(l + 1 - a >>> 1, 6);\n        r.push(16, u - 3), a += 2 * u - 2;\n      } else r.push(i, 0);\n    }\n\n    return t >>> 1;\n  }, UZIP.F._hufTree = function (e, r, t) {\n    var a = [],\n        i = e.length,\n        f = r.length,\n        c = 0;\n\n    for (c = 0; c < f; c += 2) {\n      r[c] = 0, r[c + 1] = 0;\n    }\n\n    for (c = 0; c < i; c++) {\n      0 != e[c] && a.push({\n        lit: c,\n        f: e[c]\n      });\n    }\n\n    var s = a.length,\n        l = a.slice(0);\n    if (0 == s) return 0;\n\n    if (1 == s) {\n      var u = a[0].lit;\n      l = 0 == u ? 1 : 0;\n      return r[1 + (u << 1)] = 1, r[1 + (l << 1)] = 1, 1;\n    }\n\n    a.sort(function (e, r) {\n      return e.f - r.f;\n    });\n    var d = a[0],\n        h = a[1],\n        A = 0,\n        v = 1,\n        p = 2;\n\n    for (a[0] = {\n      lit: -1,\n      f: d.f + h.f,\n      l: d,\n      r: h,\n      d: 0\n    }; v != s - 1;) {\n      d = A != v && (p == s || a[A].f < a[p].f) ? a[A++] : a[p++], h = A != v && (p == s || a[A].f < a[p].f) ? a[A++] : a[p++], a[v++] = {\n        lit: -1,\n        f: d.f + h.f,\n        l: d,\n        r: h\n      };\n    }\n\n    var U = UZIP.F.setDepth(a[v - 1], 0);\n\n    for (U > t && (UZIP.F.restrictDepth(l, t, U), U = t), c = 0; c < s; c++) {\n      r[1 + (l[c].lit << 1)] = l[c].d;\n    }\n\n    return U;\n  }, UZIP.F.setDepth = function (e, r) {\n    return -1 != e.lit ? (e.d = r, r) : Math.max(UZIP.F.setDepth(e.l, r + 1), UZIP.F.setDepth(e.r, r + 1));\n  }, UZIP.F.restrictDepth = function (e, r, t) {\n    var a = 0,\n        i = 1 << t - r,\n        f = 0;\n\n    for (e.sort(function (e, r) {\n      return r.d == e.d ? e.f - r.f : r.d - e.d;\n    }), a = 0; a < e.length && e[a].d > r; a++) {\n      var c = e[a].d;\n      e[a].d = r, f += i - (1 << t - c);\n    }\n\n    for (f >>>= t - r; f > 0;) {\n      (c = e[a].d) < r ? (e[a].d++, f -= 1 << r - c - 1) : a++;\n    }\n\n    for (; a >= 0; a--) {\n      e[a].d == r && f < 0 && (e[a].d--, f++);\n    }\n\n    0 != f && console.log(\"debt left\");\n  }, UZIP.F._goodIndex = function (e, r) {\n    var t = 0;\n    return r[16 | t] <= e && (t |= 16), r[8 | t] <= e && (t |= 8), r[4 | t] <= e && (t |= 4), r[2 | t] <= e && (t |= 2), r[1 | t] <= e && (t |= 1), t;\n  }, UZIP.F._writeLit = function (e, r, t, a) {\n    return UZIP.F._putsF(t, a, r[e << 1]), a + r[1 + (e << 1)];\n  }, UZIP.F.inflate = function (e, r) {\n    var t = Uint8Array;\n    if (3 == e[0] && 0 == e[1]) return r || new t(0);\n    var a = UZIP.F,\n        i = a._bitsF,\n        f = a._bitsE,\n        c = a._decodeTiny,\n        s = a.makeCodes,\n        l = a.codes2map,\n        u = a._get17,\n        d = a.U,\n        h = null == r;\n    h && (r = new t(e.length >>> 2 << 3));\n\n    for (var A, v, p = 0, U = 0, g = 0, m = 0, w = 0, P = 0, b = 0, _ = 0, y = 0; 0 == p;) {\n      if (p = i(e, y, 1), U = i(e, y + 1, 2), y += 3, 0 != U) {\n        if (h && (r = UZIP.F._check(r, _ + (1 << 17))), 1 == U && (A = d.flmap, v = d.fdmap, P = 511, b = 31), 2 == U) {\n          g = f(e, y, 5) + 257, m = f(e, y + 5, 5) + 1, w = f(e, y + 10, 4) + 4, y += 14;\n\n          for (var I = 0; I < 38; I += 2) {\n            d.itree[I] = 0, d.itree[I + 1] = 0;\n          }\n\n          var F = 1;\n\n          for (I = 0; I < w; I++) {\n            var G = f(e, y + 3 * I, 3);\n            d.itree[1 + (d.ordr[I] << 1)] = G, G > F && (F = G);\n          }\n\n          y += 3 * w, s(d.itree, F), l(d.itree, F, d.imap), A = d.lmap, v = d.dmap, y = c(d.imap, (1 << F) - 1, g + m, e, y, d.ttree);\n\n          var C = a._copyOut(d.ttree, 0, g, d.ltree);\n\n          P = (1 << C) - 1;\n\n          var E = a._copyOut(d.ttree, g, m, d.dtree);\n\n          b = (1 << E) - 1, s(d.ltree, C), l(d.ltree, C, A), s(d.dtree, E), l(d.dtree, E, v);\n        }\n\n        for (;;) {\n          var B = A[u(e, y) & P];\n          y += 15 & B;\n          var Z = B >>> 4;\n          if (Z >>> 8 == 0) r[_++] = Z;else {\n            if (256 == Z) break;\n            var x = _ + Z - 254;\n\n            if (Z > 264) {\n              var M = d.ldef[Z - 257];\n              x = _ + (M >>> 3) + f(e, y, 7 & M), y += 7 & M;\n            }\n\n            var R = v[u(e, y) & b];\n            y += 15 & R;\n            var Q = R >>> 4,\n                T = d.ddef[Q],\n                D = (T >>> 4) + i(e, y, 15 & T);\n\n            for (y += 15 & T, h && (r = UZIP.F._check(r, _ + (1 << 17))); _ < x;) {\n              r[_] = r[_++ - D], r[_] = r[_++ - D], r[_] = r[_++ - D], r[_] = r[_++ - D];\n            }\n\n            _ = x;\n          }\n        }\n      } else {\n        0 != (7 & y) && (y += 8 - (7 & y));\n        var O = 4 + (y >>> 3),\n            V = e[O - 4] | e[O - 3] << 8;\n        h && (r = UZIP.F._check(r, _ + V)), r.set(new t(e.buffer, e.byteOffset + O, V), _), y = O + V << 3, _ += V;\n      }\n    }\n\n    return r.length == _ ? r : r.slice(0, _);\n  }, UZIP.F._check = function (e, r) {\n    var t = e.length;\n    if (r <= t) return e;\n    var a = new Uint8Array(Math.max(t << 1, r));\n    return a.set(e, 0), a;\n  }, UZIP.F._decodeTiny = function (e, r, t, a, i, f) {\n    for (var c = UZIP.F._bitsE, s = UZIP.F._get17, l = 0; l < t;) {\n      var u = e[s(a, i) & r];\n      i += 15 & u;\n      var d = u >>> 4;\n      if (d <= 15) f[l] = d, l++;else {\n        var h = 0,\n            A = 0;\n        16 == d ? (A = 3 + c(a, i, 2), i += 2, h = f[l - 1]) : 17 == d ? (A = 3 + c(a, i, 3), i += 3) : 18 == d && (A = 11 + c(a, i, 7), i += 7);\n\n        for (var v = l + A; l < v;) {\n          f[l] = h, l++;\n        }\n      }\n    }\n\n    return i;\n  }, UZIP.F._copyOut = function (e, r, t, a) {\n    for (var i = 0, f = 0, c = a.length >>> 1; f < t;) {\n      var s = e[f + r];\n      a[f << 1] = 0, a[1 + (f << 1)] = s, s > i && (i = s), f++;\n    }\n\n    for (; f < c;) {\n      a[f << 1] = 0, a[1 + (f << 1)] = 0, f++;\n    }\n\n    return i;\n  }, UZIP.F.makeCodes = function (e, r) {\n    for (var t, a, i, f, c = UZIP.F.U, s = e.length, l = c.bl_count, u = 0; u <= r; u++) {\n      l[u] = 0;\n    }\n\n    for (u = 1; u < s; u += 2) {\n      l[e[u]]++;\n    }\n\n    var d = c.next_code;\n\n    for (t = 0, l[0] = 0, a = 1; a <= r; a++) {\n      t = t + l[a - 1] << 1, d[a] = t;\n    }\n\n    for (i = 0; i < s; i += 2) {\n      0 != (f = e[i + 1]) && (e[i] = d[f], d[f]++);\n    }\n  }, UZIP.F.codes2map = function (e, r, t) {\n    for (var a = e.length, i = UZIP.F.U.rev15, f = 0; f < a; f += 2) {\n      if (0 != e[f + 1]) for (var c = f >> 1, s = e[f + 1], l = c << 4 | s, u = r - s, d = e[f] << u, h = d + (1 << u); d != h;) {\n        t[i[d] >>> 15 - r] = l, d++;\n      }\n    }\n  }, UZIP.F.revCodes = function (e, r) {\n    for (var t = UZIP.F.U.rev15, a = 15 - r, i = 0; i < e.length; i += 2) {\n      var f = e[i] << r - e[i + 1];\n      e[i] = t[f] >>> a;\n    }\n  }, UZIP.F._putsE = function (e, r, t) {\n    t <<= 7 & r;\n    var a = r >>> 3;\n    e[a] |= t, e[a + 1] |= t >>> 8;\n  }, UZIP.F._putsF = function (e, r, t) {\n    t <<= 7 & r;\n    var a = r >>> 3;\n    e[a] |= t, e[a + 1] |= t >>> 8, e[a + 2] |= t >>> 16;\n  }, UZIP.F._bitsE = function (e, r, t) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8) >>> (7 & r) & (1 << t) - 1;\n  }, UZIP.F._bitsF = function (e, r, t) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r) & (1 << t) - 1;\n  }, UZIP.F._get17 = function (e, r) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r);\n  }, UZIP.F._get25 = function (e, r) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16 | e[3 + (r >>> 3)] << 24) >>> (7 & r);\n  }, UZIP.F.U = (r = Uint16Array, t = Uint32Array, {\n    next_code: new r(16),\n    bl_count: new r(16),\n    ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n    exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n    ldef: new r(32),\n    df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n    dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n    ddef: new t(32),\n    flmap: new r(512),\n    fltree: [],\n    fdmap: new r(32),\n    fdtree: [],\n    lmap: new r(32768),\n    ltree: [],\n    ttree: [],\n    dmap: new r(32768),\n    dtree: [],\n    imap: new r(512),\n    itree: [],\n    rev15: new r(32768),\n    lhst: new t(286),\n    dhst: new t(30),\n    ihst: new t(19),\n    lits: new t(15e3),\n    strt: new r(65536),\n    prev: new r(32768)\n  }), function () {\n    for (var e = UZIP.F.U, r = 0; r < 32768; r++) {\n      var t = r;\n      t = (4278255360 & (t = (4042322160 & (t = (3435973836 & (t = (2863311530 & t) >>> 1 | (1431655765 & t) << 1)) >>> 2 | (858993459 & t) << 2)) >>> 4 | (252645135 & t) << 4)) >>> 8 | (16711935 & t) << 8, e.rev15[r] = (t >>> 16 | t << 16) >>> 17;\n    }\n\n    function pushV(e, r, t) {\n      for (; 0 != r--;) {\n        e.push(0, t);\n      }\n    }\n\n    for (r = 0; r < 32; r++) {\n      e.ldef[r] = e.of0[r] << 3 | e.exb[r], e.ddef[r] = e.df0[r] << 4 | e.dxb[r];\n    }\n\n    pushV(e.fltree, 144, 8), pushV(e.fltree, 112, 9), pushV(e.fltree, 24, 7), pushV(e.fltree, 8, 8), UZIP.F.makeCodes(e.fltree, 9), UZIP.F.codes2map(e.fltree, 9, e.flmap), UZIP.F.revCodes(e.fltree, 9), pushV(e.fdtree, 32, 5), UZIP.F.makeCodes(e.fdtree, 5), UZIP.F.codes2map(e.fdtree, 5, e.fdmap), UZIP.F.revCodes(e.fdtree, 5), pushV(e.itree, 19, 0), pushV(e.ltree, 286, 0), pushV(e.dtree, 30, 0), pushV(e.ttree, 320, 0);\n  }();\n}),\n    UZIP = Object.freeze(Object.assign(Object.create(null), UZIP_1, {\n  default: UZIP_1\n})),\n    UPNG = {},\n    N,\n    W,\n    H;\nUPNG.toRGBA8 = function (e) {\n  var r = e.width,\n      t = e.height;\n  if (null == e.tabs.acTL) return [UPNG.toRGBA8.decodeImage(e.data, r, t, e).buffer];\n  var a = [];\n  null == e.frames[0].data && (e.frames[0].data = e.data);\n\n  for (var i = r * t * 4, f = new Uint8Array(i), c = new Uint8Array(i), s = new Uint8Array(i), l = 0; l < e.frames.length; l++) {\n    var u = e.frames[l],\n        d = u.rect.x,\n        h = u.rect.y,\n        A = u.rect.width,\n        v = u.rect.height,\n        p = UPNG.toRGBA8.decodeImage(u.data, A, v, e);\n    if (0 != l) for (var U = 0; U < i; U++) {\n      s[U] = f[U];\n    }\n    if (0 == u.blend ? UPNG._copyTile(p, A, v, f, r, t, d, h, 0) : 1 == u.blend && UPNG._copyTile(p, A, v, f, r, t, d, h, 1), a.push(f.buffer.slice(0)), 0 == u.dispose) ;else if (1 == u.dispose) UPNG._copyTile(c, A, v, f, r, t, d, h, 0);else if (2 == u.dispose) for (U = 0; U < i; U++) {\n      f[U] = s[U];\n    }\n  }\n\n  return a;\n}, UPNG.toRGBA8.decodeImage = function (e, r, t, a) {\n  var i = r * t,\n      f = UPNG.decode._getBPP(a),\n      c = Math.ceil(r * f / 8),\n      s = new Uint8Array(4 * i),\n      l = new Uint32Array(s.buffer),\n      u = a.ctype,\n      d = a.depth,\n      h = UPNG._bin.readUshort;\n\n  if (6 == u) {\n    var A = i << 2;\n    if (8 == d) for (var v = 0; v < A; v += 4) {\n      s[v] = e[v], s[v + 1] = e[v + 1], s[v + 2] = e[v + 2], s[v + 3] = e[v + 3];\n    }\n    if (16 == d) for (v = 0; v < A; v++) {\n      s[v] = e[v << 1];\n    }\n  } else if (2 == u) {\n    var p = a.tabs.tRNS;\n\n    if (null == p) {\n      if (8 == d) for (v = 0; v < i; v++) {\n        var U = 3 * v;\n        l[v] = 255 << 24 | e[U + 2] << 16 | e[U + 1] << 8 | e[U];\n      }\n      if (16 == d) for (v = 0; v < i; v++) {\n        U = 6 * v;\n        l[v] = 255 << 24 | e[U + 4] << 16 | e[U + 2] << 8 | e[U];\n      }\n    } else {\n      var g = p[0],\n          m = p[1],\n          w = p[2];\n      if (8 == d) for (v = 0; v < i; v++) {\n        var P = v << 2;\n        U = 3 * v;\n        l[v] = 255 << 24 | e[U + 2] << 16 | e[U + 1] << 8 | e[U], e[U] == g && e[U + 1] == m && e[U + 2] == w && (s[P + 3] = 0);\n      }\n      if (16 == d) for (v = 0; v < i; v++) {\n        P = v << 2, U = 6 * v;\n        l[v] = 255 << 24 | e[U + 4] << 16 | e[U + 2] << 8 | e[U], h(e, U) == g && h(e, U + 2) == m && h(e, U + 4) == w && (s[P + 3] = 0);\n      }\n    }\n  } else if (3 == u) {\n    var b = a.tabs.PLTE,\n        _ = a.tabs.tRNS,\n        y = _ ? _.length : 0;\n    if (1 == d) for (var I = 0; I < t; I++) {\n      var F = I * c,\n          G = I * r;\n\n      for (v = 0; v < r; v++) {\n        P = G + v << 2;\n        var C = 3 * (E = e[F + (v >> 3)] >> 7 - ((7 & v) << 0) & 1);\n        s[P] = b[C], s[P + 1] = b[C + 1], s[P + 2] = b[C + 2], s[P + 3] = E < y ? _[E] : 255;\n      }\n    }\n    if (2 == d) for (I = 0; I < t; I++) {\n      for (F = I * c, G = I * r, v = 0; v < r; v++) {\n        P = G + v << 2, C = 3 * (E = e[F + (v >> 2)] >> 6 - ((3 & v) << 1) & 3);\n        s[P] = b[C], s[P + 1] = b[C + 1], s[P + 2] = b[C + 2], s[P + 3] = E < y ? _[E] : 255;\n      }\n    }\n    if (4 == d) for (I = 0; I < t; I++) {\n      for (F = I * c, G = I * r, v = 0; v < r; v++) {\n        P = G + v << 2, C = 3 * (E = e[F + (v >> 1)] >> 4 - ((1 & v) << 2) & 15);\n        s[P] = b[C], s[P + 1] = b[C + 1], s[P + 2] = b[C + 2], s[P + 3] = E < y ? _[E] : 255;\n      }\n    }\n    if (8 == d) for (v = 0; v < i; v++) {\n      var E;\n      P = v << 2, C = 3 * (E = e[v]);\n      s[P] = b[C], s[P + 1] = b[C + 1], s[P + 2] = b[C + 2], s[P + 3] = E < y ? _[E] : 255;\n    }\n  } else if (4 == u) {\n    if (8 == d) for (v = 0; v < i; v++) {\n      P = v << 2;\n      var B = e[Z = v << 1];\n      s[P] = B, s[P + 1] = B, s[P + 2] = B, s[P + 3] = e[Z + 1];\n    }\n    if (16 == d) for (v = 0; v < i; v++) {\n      var Z;\n      P = v << 2, B = e[Z = v << 2];\n      s[P] = B, s[P + 1] = B, s[P + 2] = B, s[P + 3] = e[Z + 2];\n    }\n  } else if (0 == u) for (g = a.tabs.tRNS ? a.tabs.tRNS : -1, I = 0; I < t; I++) {\n    var x = I * c,\n        M = I * r;\n    if (1 == d) for (var R = 0; R < r; R++) {\n      var Q = (B = 255 * (e[x + (R >>> 3)] >>> 7 - (7 & R) & 1)) == 255 * g ? 0 : 255;\n      l[M + R] = Q << 24 | B << 16 | B << 8 | B;\n    } else if (2 == d) for (R = 0; R < r; R++) {\n      Q = (B = 85 * (e[x + (R >>> 2)] >>> 6 - ((3 & R) << 1) & 3)) == 85 * g ? 0 : 255;\n      l[M + R] = Q << 24 | B << 16 | B << 8 | B;\n    } else if (4 == d) for (R = 0; R < r; R++) {\n      Q = (B = 17 * (e[x + (R >>> 1)] >>> 4 - ((1 & R) << 2) & 15)) == 17 * g ? 0 : 255;\n      l[M + R] = Q << 24 | B << 16 | B << 8 | B;\n    } else if (8 == d) for (R = 0; R < r; R++) {\n      Q = (B = e[x + R]) == g ? 0 : 255;\n      l[M + R] = Q << 24 | B << 16 | B << 8 | B;\n    } else if (16 == d) for (R = 0; R < r; R++) {\n      B = e[x + (R << 1)], Q = h(e, x + (R << v)) == g ? 0 : 255;\n      l[M + R] = Q << 24 | B << 16 | B << 8 | B;\n    }\n  }\n\n  return s;\n}, UPNG.decode = function (e) {\n  for (var r, t = new Uint8Array(e), a = 8, i = UPNG._bin, f = i.readUshort, c = i.readUint, s = {\n    tabs: {},\n    frames: []\n  }, l = new Uint8Array(t.length), u = 0, d = 0, h = [137, 80, 78, 71, 13, 10, 26, 10], A = 0; A < 8; A++) {\n    if (t[A] != h[A]) throw \"The input is not a PNG file!\";\n  }\n\n  for (; a < t.length;) {\n    var v = i.readUint(t, a);\n    a += 4;\n    var p = i.readASCII(t, a, 4);\n    if (a += 4, \"IHDR\" == p) UPNG.decode._IHDR(t, a, s);else if (\"CgBI\" == p) s.tabs[p] = t.slice(a, a + 4);else if (\"IDAT\" == p) {\n      for (A = 0; A < v; A++) {\n        l[u + A] = t[a + A];\n      }\n\n      u += v;\n    } else if (\"acTL\" == p) s.tabs[p] = {\n      num_frames: c(t, a),\n      num_plays: c(t, a + 4)\n    }, r = new Uint8Array(t.length);else if (\"fcTL\" == p) {\n      var U;\n      if (0 != d) (U = s.frames[s.frames.length - 1]).data = UPNG.decode._decompress(s, r.slice(0, d), U.rect.width, U.rect.height), d = 0;\n      var g = {\n        x: c(t, a + 12),\n        y: c(t, a + 16),\n        width: c(t, a + 4),\n        height: c(t, a + 8)\n      },\n          m = f(t, a + 22);\n      m = f(t, a + 20) / (0 == m ? 100 : m);\n      var w = {\n        rect: g,\n        delay: Math.round(1e3 * m),\n        dispose: t[a + 24],\n        blend: t[a + 25]\n      };\n      s.frames.push(w);\n    } else if (\"fdAT\" == p) {\n      for (A = 0; A < v - 4; A++) {\n        r[d + A] = t[a + A + 4];\n      }\n\n      d += v - 4;\n    } else if (\"pHYs\" == p) s.tabs[p] = [i.readUint(t, a), i.readUint(t, a + 4), t[a + 8]];else if (\"cHRM\" == p) {\n      s.tabs[p] = [];\n\n      for (A = 0; A < 8; A++) {\n        s.tabs[p].push(i.readUint(t, a + 4 * A));\n      }\n    } else if (\"tEXt\" == p || \"zTXt\" == p) {\n      null == s.tabs[p] && (s.tabs[p] = {});\n\n      var P = i.nextZero(t, a),\n          b = i.readASCII(t, a, P - a),\n          _ = a + v - P - 1;\n\n      if (\"tEXt\" == p) G = i.readASCII(t, P + 1, _);else {\n        var y = UPNG.decode._inflate(t.slice(P + 2, P + 2 + _));\n\n        G = i.readUTF8(y, 0, y.length);\n      }\n      s.tabs[p][b] = G;\n    } else if (\"iTXt\" == p) {\n      null == s.tabs[p] && (s.tabs[p] = {});\n      P = 0;\n      var I = a;\n      P = i.nextZero(t, I);\n      b = i.readASCII(t, I, P - I);\n      var F = t[I = P + 1];\n      I += 2, P = i.nextZero(t, I);\n      i.readASCII(t, I, P - I);\n      I = P + 1, P = i.nextZero(t, I);\n      var G;\n      i.readUTF8(t, I, P - I), _ = v - ((I = P + 1) - a);\n      if (0 == F) G = i.readUTF8(t, I, _);else {\n        y = UPNG.decode._inflate(t.slice(I, I + _));\n        G = i.readUTF8(y, 0, y.length);\n      }\n      s.tabs[p][b] = G;\n    } else if (\"PLTE\" == p) s.tabs[p] = i.readBytes(t, a, v);else if (\"hIST\" == p) {\n      var C = s.tabs.PLTE.length / 3;\n      s.tabs[p] = [];\n\n      for (A = 0; A < C; A++) {\n        s.tabs[p].push(f(t, a + 2 * A));\n      }\n    } else if (\"tRNS\" == p) 3 == s.ctype ? s.tabs[p] = i.readBytes(t, a, v) : 0 == s.ctype ? s.tabs[p] = f(t, a) : 2 == s.ctype && (s.tabs[p] = [f(t, a), f(t, a + 2), f(t, a + 4)]);else if (\"gAMA\" == p) s.tabs[p] = i.readUint(t, a) / 1e5;else if (\"sRGB\" == p) s.tabs[p] = t[a];else if (\"bKGD\" == p) 0 == s.ctype || 4 == s.ctype ? s.tabs[p] = [f(t, a)] : 2 == s.ctype || 6 == s.ctype ? s.tabs[p] = [f(t, a), f(t, a + 2), f(t, a + 4)] : 3 == s.ctype && (s.tabs[p] = t[a]);else if (\"IEND\" == p) break;\n    a += v;\n    i.readUint(t, a);\n    a += 4;\n  }\n\n  0 != d && ((U = s.frames[s.frames.length - 1]).data = UPNG.decode._decompress(s, r.slice(0, d), U.rect.width, U.rect.height), d = 0);\n  return s.data = UPNG.decode._decompress(s, l, s.width, s.height), delete s.compress, delete s.interlace, delete s.filter, s;\n}, UPNG.decode._decompress = function (e, r, t, a) {\n  var i = UPNG.decode._getBPP(e),\n      f = Math.ceil(t * i / 8),\n      c = new Uint8Array((f + 1 + e.interlace) * a);\n\n  return r = e.tabs.CgBI ? UPNG.inflateRaw(r, c) : UPNG.decode._inflate(r, c), 0 == e.interlace ? r = UPNG.decode._filterZero(r, e, 0, t, a) : 1 == e.interlace && (r = UPNG.decode._readInterlace(r, e)), r;\n}, UPNG.decode._inflate = function (e, r) {\n  return UPNG.inflateRaw(new Uint8Array(e.buffer, 2, e.length - 6), r);\n}, UPNG.inflateRaw = (H = {}, H.H = {}, H.H.N = function (e, r) {\n  var t,\n      a,\n      i = Uint8Array,\n      f = 0,\n      c = 0,\n      s = 0,\n      l = 0,\n      u = 0,\n      d = 0,\n      h = 0,\n      A = 0,\n      v = 0;\n  if (3 == e[0] && 0 == e[1]) return r || new i(0);\n  var p = H.H,\n      U = p.b,\n      g = p.e,\n      m = p.R,\n      w = p.n,\n      P = p.A,\n      b = p.Z,\n      _ = p.m,\n      y = null == r;\n\n  for (y && (r = new i(e.length >>> 2 << 5)); 0 == f;) {\n    if (f = U(e, v, 1), c = U(e, v + 1, 2), v += 3, 0 != c) {\n      if (y && (r = H.H.W(r, A + (1 << 17))), 1 == c && (t = _.J, a = _.h, d = 511, h = 31), 2 == c) {\n        s = g(e, v, 5) + 257, l = g(e, v + 5, 5) + 1, u = g(e, v + 10, 4) + 4, v += 14;\n\n        for (var I = 1, F = 0; F < 38; F += 2) {\n          _.Q[F] = 0, _.Q[F + 1] = 0;\n        }\n\n        for (F = 0; F < u; F++) {\n          var G = g(e, v + 3 * F, 3);\n          _.Q[1 + (_.X[F] << 1)] = G, G > I && (I = G);\n        }\n\n        v += 3 * u, w(_.Q, I), P(_.Q, I, _.u), t = _.w, a = _.d, v = m(_.u, (1 << I) - 1, s + l, e, v, _.v);\n        var C = p.V(_.v, 0, s, _.C);\n        d = (1 << C) - 1;\n        var E = p.V(_.v, s, l, _.D);\n        h = (1 << E) - 1, w(_.C, C), P(_.C, C, t), w(_.D, E), P(_.D, E, a);\n      }\n\n      for (;;) {\n        var B = t[b(e, v) & d];\n        v += 15 & B;\n        var Z = B >>> 4;\n        if (Z >>> 8 == 0) r[A++] = Z;else {\n          if (256 == Z) break;\n          var x = A + Z - 254;\n\n          if (Z > 264) {\n            var M = _.q[Z - 257];\n            x = A + (M >>> 3) + g(e, v, 7 & M), v += 7 & M;\n          }\n\n          var R = a[b(e, v) & h];\n          v += 15 & R;\n          var Q = R >>> 4,\n              T = _.c[Q],\n              D = (T >>> 4) + U(e, v, 15 & T);\n\n          for (v += 15 & T; A < x;) {\n            r[A] = r[A++ - D], r[A] = r[A++ - D], r[A] = r[A++ - D], r[A] = r[A++ - D];\n          }\n\n          A = x;\n        }\n      }\n    } else {\n      0 != (7 & v) && (v += 8 - (7 & v));\n      var O = 4 + (v >>> 3),\n          V = e[O - 4] | e[O - 3] << 8;\n      y && (r = H.H.W(r, A + V)), r.set(new i(e.buffer, e.byteOffset + O, V), A), v = O + V << 3, A += V;\n    }\n  }\n\n  return r.length == A ? r : r.slice(0, A);\n}, H.H.W = function (e, r) {\n  var t = e.length;\n  if (r <= t) return e;\n  var a = new Uint8Array(t << 1);\n  return a.set(e, 0), a;\n}, H.H.R = function (e, r, t, a, i, f) {\n  for (var c = H.H.e, s = H.H.Z, l = 0; l < t;) {\n    var u = e[s(a, i) & r];\n    i += 15 & u;\n    var d = u >>> 4;\n    if (d <= 15) f[l] = d, l++;else {\n      var h = 0,\n          A = 0;\n      16 == d ? (A = 3 + c(a, i, 2), i += 2, h = f[l - 1]) : 17 == d ? (A = 3 + c(a, i, 3), i += 3) : 18 == d && (A = 11 + c(a, i, 7), i += 7);\n\n      for (var v = l + A; l < v;) {\n        f[l] = h, l++;\n      }\n    }\n  }\n\n  return i;\n}, H.H.V = function (e, r, t, a) {\n  for (var i = 0, f = 0, c = a.length >>> 1; f < t;) {\n    var s = e[f + r];\n    a[f << 1] = 0, a[1 + (f << 1)] = s, s > i && (i = s), f++;\n  }\n\n  for (; f < c;) {\n    a[f << 1] = 0, a[1 + (f << 1)] = 0, f++;\n  }\n\n  return i;\n}, H.H.n = function (e, r) {\n  for (var t, a, i, f, c = H.H.m, s = e.length, l = c.j, u = 0; u <= r; u++) {\n    l[u] = 0;\n  }\n\n  for (u = 1; u < s; u += 2) {\n    l[e[u]]++;\n  }\n\n  var d = c.K;\n\n  for (t = 0, l[0] = 0, a = 1; a <= r; a++) {\n    t = t + l[a - 1] << 1, d[a] = t;\n  }\n\n  for (i = 0; i < s; i += 2) {\n    0 != (f = e[i + 1]) && (e[i] = d[f], d[f]++);\n  }\n}, H.H.A = function (e, r, t) {\n  for (var a = e.length, i = H.H.m.r, f = 0; f < a; f += 2) {\n    if (0 != e[f + 1]) for (var c = f >> 1, s = e[f + 1], l = c << 4 | s, u = r - s, d = e[f] << u, h = d + (1 << u); d != h;) {\n      t[i[d] >>> 15 - r] = l, d++;\n    }\n  }\n}, H.H.l = function (e, r) {\n  for (var t = H.H.m.r, a = 15 - r, i = 0; i < e.length; i += 2) {\n    var f = e[i] << r - e[i + 1];\n    e[i] = t[f] >>> a;\n  }\n}, H.H.M = function (e, r, t) {\n  t <<= 7 & r;\n  var a = r >>> 3;\n  e[a] |= t, e[a + 1] |= t >>> 8;\n}, H.H.I = function (e, r, t) {\n  t <<= 7 & r;\n  var a = r >>> 3;\n  e[a] |= t, e[a + 1] |= t >>> 8, e[a + 2] |= t >>> 16;\n}, H.H.e = function (e, r, t) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8) >>> (7 & r) & (1 << t) - 1;\n}, H.H.b = function (e, r, t) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r) & (1 << t) - 1;\n}, H.H.Z = function (e, r) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r);\n}, H.H.i = function (e, r) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16 | e[3 + (r >>> 3)] << 24) >>> (7 & r);\n}, H.H.m = (N = Uint16Array, W = Uint32Array, {\n  K: new N(16),\n  j: new N(16),\n  X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n  S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n  T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n  q: new N(32),\n  p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n  z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n  c: new W(32),\n  J: new N(512),\n  _: [],\n  h: new N(32),\n  $: [],\n  w: new N(32768),\n  C: [],\n  v: [],\n  d: new N(32768),\n  D: [],\n  u: new N(512),\n  Q: [],\n  r: new N(32768),\n  s: new W(286),\n  Y: new W(30),\n  a: new W(19),\n  t: new W(15e3),\n  k: new N(65536),\n  g: new N(32768)\n}), function () {\n  for (var e = H.H.m, r = 0; r < 32768; r++) {\n    var t = r;\n    t = (4278255360 & (t = (4042322160 & (t = (3435973836 & (t = (2863311530 & t) >>> 1 | (1431655765 & t) << 1)) >>> 2 | (858993459 & t) << 2)) >>> 4 | (252645135 & t) << 4)) >>> 8 | (16711935 & t) << 8, e.r[r] = (t >>> 16 | t << 16) >>> 17;\n  }\n\n  function n(e, r, t) {\n    for (; 0 != r--;) {\n      e.push(0, t);\n    }\n  }\n\n  for (r = 0; r < 32; r++) {\n    e.q[r] = e.S[r] << 3 | e.T[r], e.c[r] = e.p[r] << 4 | e.z[r];\n  }\n\n  n(e._, 144, 8), n(e._, 112, 9), n(e._, 24, 7), n(e._, 8, 8), H.H.n(e._, 9), H.H.A(e._, 9, e.J), H.H.l(e._, 9), n(e.$, 32, 5), H.H.n(e.$, 5), H.H.A(e.$, 5, e.h), H.H.l(e.$, 5), n(e.Q, 19, 0), n(e.C, 286, 0), n(e.D, 30, 0), n(e.v, 320, 0);\n}(), H.H.N), UPNG.decode._readInterlace = function (e, r) {\n  for (var t = r.width, a = r.height, i = UPNG.decode._getBPP(r), f = i >> 3, c = Math.ceil(t * i / 8), s = new Uint8Array(a * c), l = 0, u = [0, 0, 4, 0, 2, 0, 1], d = [0, 4, 0, 2, 0, 1, 0], h = [8, 8, 8, 4, 4, 2, 2], A = [8, 8, 4, 4, 2, 2, 1], v = 0; v < 7;) {\n    for (var p = h[v], U = A[v], g = 0, m = 0, w = u[v]; w < a;) {\n      w += p, m++;\n    }\n\n    for (var P = d[v]; P < t;) {\n      P += U, g++;\n    }\n\n    var b = Math.ceil(g * i / 8);\n\n    UPNG.decode._filterZero(e, r, l, g, m);\n\n    for (var _ = 0, y = u[v]; y < a;) {\n      for (var I = d[v], F = l + _ * b << 3; I < t;) {\n        var G;\n        if (1 == i) G = (G = e[F >> 3]) >> 7 - (7 & F) & 1, s[y * c + (I >> 3)] |= G << 7 - ((7 & I) << 0);\n        if (2 == i) G = (G = e[F >> 3]) >> 6 - (7 & F) & 3, s[y * c + (I >> 2)] |= G << 6 - ((3 & I) << 1);\n        if (4 == i) G = (G = e[F >> 3]) >> 4 - (7 & F) & 15, s[y * c + (I >> 1)] |= G << 4 - ((1 & I) << 2);\n        if (i >= 8) for (var C = y * c + I * f, E = 0; E < f; E++) {\n          s[C + E] = e[(F >> 3) + E];\n        }\n        F += i, I += U;\n      }\n\n      _++, y += p;\n    }\n\n    g * m != 0 && (l += m * (1 + b)), v += 1;\n  }\n\n  return s;\n}, UPNG.decode._getBPP = function (e) {\n  return [1, null, 3, 1, 2, null, 4][e.ctype] * e.depth;\n}, UPNG.decode._filterZero = function (e, r, t, a, i) {\n  var f = UPNG.decode._getBPP(r),\n      c = Math.ceil(a * f / 8),\n      s = UPNG.decode._paeth;\n\n  f = Math.ceil(f / 8);\n  var l = 0,\n      u = 1,\n      d = e[t],\n      h = 0;\n  if (d > 1 && (e[t] = [0, 0, 1][d - 2]), 3 == d) for (h = f; h < c; h++) {\n    e[h + 1] = e[h + 1] + (e[h + 1 - f] >>> 1) & 255;\n  }\n\n  for (var A = 0; A < i; A++) {\n    if (h = 0, 0 == (d = e[(u = (l = t + A * c) + A + 1) - 1])) for (; h < c; h++) {\n      e[l + h] = e[u + h];\n    } else if (1 == d) {\n      for (; h < f; h++) {\n        e[l + h] = e[u + h];\n      }\n\n      for (; h < c; h++) {\n        e[l + h] = e[u + h] + e[l + h - f];\n      }\n    } else if (2 == d) for (; h < c; h++) {\n      e[l + h] = e[u + h] + e[l + h - c];\n    } else if (3 == d) {\n      for (; h < f; h++) {\n        e[l + h] = e[u + h] + (e[l + h - c] >>> 1);\n      }\n\n      for (; h < c; h++) {\n        e[l + h] = e[u + h] + (e[l + h - c] + e[l + h - f] >>> 1);\n      }\n    } else {\n      for (; h < f; h++) {\n        e[l + h] = e[u + h] + s(0, e[l + h - c], 0);\n      }\n\n      for (; h < c; h++) {\n        e[l + h] = e[u + h] + s(e[l + h - f], e[l + h - c], e[l + h - f - c]);\n      }\n    }\n  }\n\n  return e;\n}, UPNG.decode._paeth = function (e, r, t) {\n  var a = e + r - t,\n      i = a - e,\n      f = a - r,\n      c = a - t;\n  return i * i <= f * f && i * i <= c * c ? e : f * f <= c * c ? r : t;\n}, UPNG.decode._IHDR = function (e, r, t) {\n  var a = UPNG._bin;\n  t.width = a.readUint(e, r), r += 4, t.height = a.readUint(e, r), r += 4, t.depth = e[r], r++, t.ctype = e[r], r++, t.compress = e[r], r++, t.filter = e[r], r++, t.interlace = e[r], r++;\n}, UPNG._bin = {\n  nextZero: function nextZero(e, r) {\n    for (; 0 != e[r];) {\n      r++;\n    }\n\n    return r;\n  },\n  readUshort: function readUshort(e, r) {\n    return e[r] << 8 | e[r + 1];\n  },\n  writeUshort: function writeUshort(e, r, t) {\n    e[r] = t >> 8 & 255, e[r + 1] = 255 & t;\n  },\n  readUint: function readUint(e, r) {\n    return 16777216 * e[r] + (e[r + 1] << 16 | e[r + 2] << 8 | e[r + 3]);\n  },\n  writeUint: function writeUint(e, r, t) {\n    e[r] = t >> 24 & 255, e[r + 1] = t >> 16 & 255, e[r + 2] = t >> 8 & 255, e[r + 3] = 255 & t;\n  },\n  readASCII: function readASCII(e, r, t) {\n    for (var a = \"\", i = 0; i < t; i++) {\n      a += String.fromCharCode(e[r + i]);\n    }\n\n    return a;\n  },\n  writeASCII: function writeASCII(e, r, t) {\n    for (var a = 0; a < t.length; a++) {\n      e[r + a] = t.charCodeAt(a);\n    }\n  },\n  readBytes: function readBytes(e, r, t) {\n    for (var a = [], i = 0; i < t; i++) {\n      a.push(e[r + i]);\n    }\n\n    return a;\n  },\n  pad: function pad(e) {\n    return e.length < 2 ? \"0\" + e : e;\n  },\n  readUTF8: function readUTF8(e, r, t) {\n    for (var a, i = \"\", f = 0; f < t; f++) {\n      i += \"%\" + UPNG._bin.pad(e[r + f].toString(16));\n    }\n\n    try {\n      a = decodeURIComponent(i);\n    } catch (a) {\n      return UPNG._bin.readASCII(e, r, t);\n    }\n\n    return a;\n  }\n}, UPNG._copyTile = function (e, r, t, a, i, f, c, s, l) {\n  for (var u = Math.min(r, i), d = Math.min(t, f), h = 0, A = 0, v = 0; v < d; v++) {\n    for (var p = 0; p < u; p++) {\n      if (c >= 0 && s >= 0 ? (h = v * r + p << 2, A = (s + v) * i + c + p << 2) : (h = (-s + v) * r - c + p << 2, A = v * i + p << 2), 0 == l) a[A] = e[h], a[A + 1] = e[h + 1], a[A + 2] = e[h + 2], a[A + 3] = e[h + 3];else if (1 == l) {\n        var U = e[h + 3] * (1 / 255),\n            g = e[h] * U,\n            m = e[h + 1] * U,\n            w = e[h + 2] * U,\n            P = a[A + 3] * (1 / 255),\n            b = a[A] * P,\n            _ = a[A + 1] * P,\n            y = a[A + 2] * P,\n            I = 1 - U,\n            F = U + P * I,\n            G = 0 == F ? 0 : 1 / F;\n\n        a[A + 3] = 255 * F, a[A + 0] = (g + b * I) * G, a[A + 1] = (m + _ * I) * G, a[A + 2] = (w + y * I) * G;\n      } else if (2 == l) {\n        U = e[h + 3], g = e[h], m = e[h + 1], w = e[h + 2], P = a[A + 3], b = a[A], _ = a[A + 1], y = a[A + 2];\n        U == P && g == b && m == _ && w == y ? (a[A] = 0, a[A + 1] = 0, a[A + 2] = 0, a[A + 3] = 0) : (a[A] = g, a[A + 1] = m, a[A + 2] = w, a[A + 3] = U);\n      } else if (3 == l) {\n        U = e[h + 3], g = e[h], m = e[h + 1], w = e[h + 2], P = a[A + 3], b = a[A], _ = a[A + 1], y = a[A + 2];\n        if (U == P && g == b && m == _ && w == y) continue;\n        if (U < 220 && P > 20) return !1;\n      }\n    }\n  }\n\n  return !0;\n}, UPNG.encode = function (e, r, t, a, i, f, c) {\n  null == a && (a = 0), null == c && (c = !1);\n  var s = UPNG.encode.compress(e, r, t, a, [!1, !1, !1, 0, c]);\n  return UPNG.encode.compressPNG(s, -1), UPNG.encode._main(s, r, t, i, f);\n}, UPNG.encodeLL = function (e, r, t, a, i, f, c, s) {\n  for (var l = {\n    ctype: 0 + (1 == a ? 0 : 2) + (0 == i ? 0 : 4),\n    depth: f,\n    frames: []\n  }, u = (a + i) * f, d = u * r, h = 0; h < e.length; h++) {\n    l.frames.push({\n      rect: {\n        x: 0,\n        y: 0,\n        width: r,\n        height: t\n      },\n      img: new Uint8Array(e[h]),\n      blend: 0,\n      dispose: 1,\n      bpp: Math.ceil(u / 8),\n      bpl: Math.ceil(d / 8)\n    });\n  }\n\n  return UPNG.encode.compressPNG(l, 0, !0), UPNG.encode._main(l, r, t, c, s);\n}, UPNG.encode._main = function (e, r, t, a, i) {\n  null == i && (i = {});\n  var f = UPNG.crc.crc,\n      c = UPNG._bin.writeUint,\n      s = UPNG._bin.writeUshort,\n      l = UPNG._bin.writeASCII,\n      u = 8,\n      d = e.frames.length > 1,\n      h = !1,\n      A = 33 + (d ? 20 : 0);\n\n  if (null != i.sRGB && (A += 13), null != i.pHYs && (A += 21), 3 == e.ctype) {\n    for (var v = e.plte.length, p = 0; p < v; p++) {\n      e.plte[p] >>> 24 != 255 && (h = !0);\n    }\n\n    A += 8 + 3 * v + 4 + (h ? 8 + 1 * v + 4 : 0);\n  }\n\n  for (var U = 0; U < e.frames.length; U++) {\n    d && (A += 38), A += (F = e.frames[U]).cimg.length + 12, 0 != U && (A += 4);\n  }\n\n  A += 12;\n  var g = new Uint8Array(A),\n      m = [137, 80, 78, 71, 13, 10, 26, 10];\n\n  for (p = 0; p < 8; p++) {\n    g[p] = m[p];\n  }\n\n  if (c(g, u, 13), l(g, u += 4, \"IHDR\"), c(g, u += 4, r), c(g, u += 4, t), g[u += 4] = e.depth, g[++u] = e.ctype, g[++u] = 0, g[++u] = 0, g[++u] = 0, c(g, ++u, f(g, u - 17, 17)), u += 4, null != i.sRGB && (c(g, u, 1), l(g, u += 4, \"sRGB\"), g[u += 4] = i.sRGB, c(g, ++u, f(g, u - 5, 5)), u += 4), null != i.pHYs && (c(g, u, 9), l(g, u += 4, \"pHYs\"), c(g, u += 4, i.pHYs[0]), c(g, u += 4, i.pHYs[1]), g[u += 4] = i.pHYs[2], c(g, ++u, f(g, u - 13, 13)), u += 4), d && (c(g, u, 8), l(g, u += 4, \"acTL\"), c(g, u += 4, e.frames.length), c(g, u += 4, null != i.loop ? i.loop : 0), c(g, u += 4, f(g, u - 12, 12)), u += 4), 3 == e.ctype) {\n    c(g, u, 3 * (v = e.plte.length)), l(g, u += 4, \"PLTE\"), u += 4;\n\n    for (p = 0; p < v; p++) {\n      var w = 3 * p,\n          P = e.plte[p],\n          b = 255 & P,\n          _ = P >>> 8 & 255,\n          y = P >>> 16 & 255;\n\n      g[u + w + 0] = b, g[u + w + 1] = _, g[u + w + 2] = y;\n    }\n\n    if (c(g, u += 3 * v, f(g, u - 3 * v - 4, 3 * v + 4)), u += 4, h) {\n      c(g, u, v), l(g, u += 4, \"tRNS\"), u += 4;\n\n      for (p = 0; p < v; p++) {\n        g[u + p] = e.plte[p] >>> 24 & 255;\n      }\n\n      c(g, u += v, f(g, u - v - 4, v + 4)), u += 4;\n    }\n  }\n\n  var I = 0;\n\n  for (U = 0; U < e.frames.length; U++) {\n    var F = e.frames[U];\n    d && (c(g, u, 26), l(g, u += 4, \"fcTL\"), c(g, u += 4, I++), c(g, u += 4, F.rect.width), c(g, u += 4, F.rect.height), c(g, u += 4, F.rect.x), c(g, u += 4, F.rect.y), s(g, u += 4, a[U]), s(g, u += 2, 1e3), g[u += 2] = F.dispose, g[++u] = F.blend, c(g, ++u, f(g, u - 30, 30)), u += 4);\n    var G = F.cimg;\n    c(g, u, (v = G.length) + (0 == U ? 0 : 4));\n    var C = u += 4;\n    l(g, u, 0 == U ? \"IDAT\" : \"fdAT\"), u += 4, 0 != U && (c(g, u, I++), u += 4), g.set(G, u), c(g, u += v, f(g, C, u - C)), u += 4;\n  }\n\n  return c(g, u, 0), l(g, u += 4, \"IEND\"), c(g, u += 4, f(g, u - 4, 4)), u += 4, g.buffer;\n}, UPNG.encode.compressPNG = function (e, r, t) {\n  for (var a = 0; a < e.frames.length; a++) {\n    var i = e.frames[a],\n        f = (i.rect.width, i.rect.height),\n        c = new Uint8Array(f * i.bpl + f);\n    i.cimg = UPNG.encode._filterZero(i.img, f, i.bpp, i.bpl, c, r, t);\n  }\n}, UPNG.encode.compress = function (e, r, t, a, i) {\n  for (var f = i[0], c = i[1], s = i[2], l = i[3], u = i[4], d = 6, h = 8, A = 255, v = 0; v < e.length; v++) {\n    for (var p = new Uint8Array(e[v]), U = p.length, g = 0; g < U; g += 4) {\n      A &= p[g + 3];\n    }\n  }\n\n  var m = 255 != A,\n      w = UPNG.encode.framize(e, r, t, f, c, s),\n      P = {},\n      b = [],\n      _ = [];\n\n  if (0 != a) {\n    var y = [];\n\n    for (g = 0; g < w.length; g++) {\n      y.push(w[g].img.buffer);\n    }\n\n    var I = UPNG.encode.concatRGBA(y),\n        F = UPNG.quantize(I, a),\n        G = 0,\n        C = new Uint8Array(F.abuf);\n\n    for (g = 0; g < w.length; g++) {\n      var E = (K = w[g].img).length;\n\n      _.push(new Uint8Array(F.inds.buffer, G >> 2, E >> 2));\n\n      for (v = 0; v < E; v += 4) {\n        K[v] = C[G + v], K[v + 1] = C[G + v + 1], K[v + 2] = C[G + v + 2], K[v + 3] = C[G + v + 3];\n      }\n\n      G += E;\n    }\n\n    for (g = 0; g < F.plte.length; g++) {\n      b.push(F.plte[g].est.rgba);\n    }\n  } else for (v = 0; v < w.length; v++) {\n    var B = w[v],\n        Z = new Uint32Array(B.img.buffer),\n        x = B.rect.width,\n        M = (U = Z.length, new Uint8Array(U));\n\n    _.push(M);\n\n    for (g = 0; g < U; g++) {\n      var R = Z[g];\n      if (0 != g && R == Z[g - 1]) M[g] = M[g - 1];else if (g > x && R == Z[g - x]) M[g] = M[g - x];else {\n        var Q = P[R];\n        if (null == Q && (P[R] = Q = b.length, b.push(R), b.length >= 300)) break;\n        M[g] = Q;\n      }\n    }\n  }\n\n  var T = b.length;\n  T <= 256 && 0 == u && (h = T <= 2 ? 1 : T <= 4 ? 2 : T <= 16 ? 4 : 8, h = Math.max(h, l));\n\n  for (v = 0; v < w.length; v++) {\n    (B = w[v]).rect.x, B.rect.y, x = B.rect.width;\n    var D = B.rect.height,\n        O = B.img,\n        V = (new Uint32Array(O.buffer), 4 * x),\n        z = 4;\n\n    if (T <= 256 && 0 == u) {\n      V = Math.ceil(h * x / 8);\n\n      for (var k = new Uint8Array(V * D), L = _[v], S = 0; S < D; S++) {\n        g = S * V;\n        var q = S * x;\n        if (8 == h) for (var j = 0; j < x; j++) {\n          k[g + j] = L[q + j];\n        } else if (4 == h) for (j = 0; j < x; j++) {\n          k[g + (j >> 1)] |= L[q + j] << 4 - 4 * (1 & j);\n        } else if (2 == h) for (j = 0; j < x; j++) {\n          k[g + (j >> 2)] |= L[q + j] << 6 - 2 * (3 & j);\n        } else if (1 == h) for (j = 0; j < x; j++) {\n          k[g + (j >> 3)] |= L[q + j] << 7 - 1 * (7 & j);\n        }\n      }\n\n      O = k, d = 3, z = 1;\n    } else if (0 == m && 1 == w.length) {\n      k = new Uint8Array(x * D * 3);\n      var $ = x * D;\n\n      for (g = 0; g < $; g++) {\n        var K,\n            J = 4 * g;\n        k[K = 3 * g] = O[J], k[K + 1] = O[J + 1], k[K + 2] = O[J + 2];\n      }\n\n      O = k, d = 2, z = 3, V = 3 * x;\n    }\n\n    B.img = O, B.bpl = V, B.bpp = z;\n  }\n\n  return {\n    ctype: d,\n    depth: h,\n    plte: b,\n    frames: w\n  };\n}, UPNG.encode.framize = function (e, r, t, a, i, f) {\n  for (var c = [], s = 0; s < e.length; s++) {\n    var l,\n        u = new Uint8Array(e[s]),\n        d = new Uint32Array(u.buffer),\n        h = 0,\n        A = 0,\n        v = r,\n        p = t,\n        U = a ? 1 : 0;\n\n    if (0 != s) {\n      for (var g = f || a || 1 == s || 0 != c[s - 2].dispose ? 1 : 2, m = 0, w = 1e9, P = 0; P < g; P++) {\n        for (var b = new Uint8Array(e[s - 1 - P]), _ = new Uint32Array(e[s - 1 - P]), y = r, I = t, F = -1, G = -1, C = 0; C < t; C++) {\n          for (var E = 0; E < r; E++) {\n            d[T = C * r + E] != _[T] && (E < y && (y = E), E > F && (F = E), C < I && (I = C), C > G && (G = C));\n          }\n        }\n\n        -1 == F && (y = I = F = G = 0), i && (1 == (1 & y) && y--, 1 == (1 & I) && I--);\n        var B = (F - y + 1) * (G - I + 1);\n        B < w && (w = B, m = P, h = y, A = I, v = F - y + 1, p = G - I + 1);\n      }\n\n      b = new Uint8Array(e[s - 1 - m]);\n      1 == m && (c[s - 1].dispose = 2), l = new Uint8Array(v * p * 4), UPNG._copyTile(b, r, t, l, v, p, -h, -A, 0), 1 == (U = UPNG._copyTile(u, r, t, l, v, p, -h, -A, 3) ? 1 : 0) ? UPNG.encode._prepareDiff(u, r, t, l, {\n        x: h,\n        y: A,\n        width: v,\n        height: p\n      }) : UPNG._copyTile(u, r, t, l, v, p, -h, -A, 0);\n    } else l = u.slice(0);\n\n    c.push({\n      rect: {\n        x: h,\n        y: A,\n        width: v,\n        height: p\n      },\n      img: l,\n      blend: U,\n      dispose: 0\n    });\n  }\n\n  if (a) for (s = 0; s < c.length; s++) {\n    if (1 != (D = c[s]).blend) {\n      var Z = D.rect,\n          x = c[s - 1].rect,\n          M = Math.min(Z.x, x.x),\n          R = Math.min(Z.y, x.y),\n          Q = {\n        x: M,\n        y: R,\n        width: Math.max(Z.x + Z.width, x.x + x.width) - M,\n        height: Math.max(Z.y + Z.height, x.y + x.height) - R\n      };\n      c[s - 1].dispose = 1, s - 1 != 0 && UPNG.encode._updateFrame(e, r, t, c, s - 1, Q, i), UPNG.encode._updateFrame(e, r, t, c, s, Q, i);\n    }\n  }\n  if (1 != e.length) for (var T = 0; T < c.length; T++) {\n    var D;\n    (D = c[T]).rect.width * D.rect.height;\n  }\n  return c;\n}, UPNG.encode._updateFrame = function (e, r, t, a, i, f, c) {\n  for (var s = Uint8Array, l = Uint32Array, u = new s(e[i - 1]), d = new l(e[i - 1]), h = i + 1 < e.length ? new s(e[i + 1]) : null, A = new s(e[i]), v = new l(A.buffer), p = r, U = t, g = -1, m = -1, w = 0; w < f.height; w++) {\n    for (var P = 0; P < f.width; P++) {\n      var b = f.x + P,\n          _ = f.y + w,\n          y = _ * r + b,\n          I = v[y];\n\n      0 == I || 0 == a[i - 1].dispose && d[y] == I && (null == h || 0 != h[4 * y + 3]) || (b < p && (p = b), b > g && (g = b), _ < U && (U = _), _ > m && (m = _));\n    }\n  }\n\n  -1 == g && (p = U = g = m = 0), c && (1 == (1 & p) && p--, 1 == (1 & U) && U--), f = {\n    x: p,\n    y: U,\n    width: g - p + 1,\n    height: m - U + 1\n  };\n  var F = a[i];\n  F.rect = f, F.blend = 1, F.img = new Uint8Array(f.width * f.height * 4), 0 == a[i - 1].dispose ? (UPNG._copyTile(u, r, t, F.img, f.width, f.height, -f.x, -f.y, 0), UPNG.encode._prepareDiff(A, r, t, F.img, f)) : UPNG._copyTile(A, r, t, F.img, f.width, f.height, -f.x, -f.y, 0);\n}, UPNG.encode._prepareDiff = function (e, r, t, a, i) {\n  UPNG._copyTile(e, r, t, a, i.width, i.height, -i.x, -i.y, 2);\n}, UPNG.encode._filterZero = function (e, r, t, a, i, f, c) {\n  var s,\n      l = [],\n      u = [0, 1, 2, 3, 4];\n  -1 != f ? u = [f] : (r * a > 5e5 || 1 == t) && (u = [0]), c && (s = {\n    level: 0\n  });\n\n  for (var d = UZIP, h = 0; h < u.length; h++) {\n    for (var A = 0; A < r; A++) {\n      UPNG.encode._filterLine(i, e, A, a, t, u[h]);\n    }\n\n    l.push(d.deflate(i, s));\n  }\n\n  var v,\n      p = 1e9;\n\n  for (h = 0; h < l.length; h++) {\n    l[h].length < p && (v = h, p = l[h].length);\n  }\n\n  return l[v];\n}, UPNG.encode._filterLine = function (e, r, t, a, i, f) {\n  var c = t * a,\n      s = c + t,\n      l = UPNG.decode._paeth;\n  if (e[s] = f, s++, 0 == f) {\n    if (a < 500) for (var u = 0; u < a; u++) {\n      e[s + u] = r[c + u];\n    } else e.set(new Uint8Array(r.buffer, c, a), s);\n  } else if (1 == f) {\n    for (u = 0; u < i; u++) {\n      e[s + u] = r[c + u];\n    }\n\n    for (u = i; u < a; u++) {\n      e[s + u] = r[c + u] - r[c + u - i] + 256 & 255;\n    }\n  } else if (0 == t) {\n    for (u = 0; u < i; u++) {\n      e[s + u] = r[c + u];\n    }\n\n    if (2 == f) for (u = i; u < a; u++) {\n      e[s + u] = r[c + u];\n    }\n    if (3 == f) for (u = i; u < a; u++) {\n      e[s + u] = r[c + u] - (r[c + u - i] >> 1) + 256 & 255;\n    }\n    if (4 == f) for (u = i; u < a; u++) {\n      e[s + u] = r[c + u] - l(r[c + u - i], 0, 0) + 256 & 255;\n    }\n  } else {\n    if (2 == f) for (u = 0; u < a; u++) {\n      e[s + u] = r[c + u] + 256 - r[c + u - a] & 255;\n    }\n\n    if (3 == f) {\n      for (u = 0; u < i; u++) {\n        e[s + u] = r[c + u] + 256 - (r[c + u - a] >> 1) & 255;\n      }\n\n      for (u = i; u < a; u++) {\n        e[s + u] = r[c + u] + 256 - (r[c + u - a] + r[c + u - i] >> 1) & 255;\n      }\n    }\n\n    if (4 == f) {\n      for (u = 0; u < i; u++) {\n        e[s + u] = r[c + u] + 256 - l(0, r[c + u - a], 0) & 255;\n      }\n\n      for (u = i; u < a; u++) {\n        e[s + u] = r[c + u] + 256 - l(r[c + u - i], r[c + u - a], r[c + u - i - a]) & 255;\n      }\n    }\n  }\n}, UPNG.crc = {\n  table: function () {\n    for (var e = new Uint32Array(256), r = 0; r < 256; r++) {\n      for (var t = r, a = 0; a < 8; a++) {\n        1 & t ? t = 3988292384 ^ t >>> 1 : t >>>= 1;\n      }\n\n      e[r] = t;\n    }\n\n    return e;\n  }(),\n  update: function update(e, r, t, a) {\n    for (var i = 0; i < a; i++) {\n      e = UPNG.crc.table[255 & (e ^ r[t + i])] ^ e >>> 8;\n    }\n\n    return e;\n  },\n  crc: function crc(e, r, t) {\n    return 4294967295 ^ UPNG.crc.update(4294967295, e, r, t);\n  }\n}, UPNG.quantize = function (e, r) {\n  var t,\n      a = new Uint8Array(e),\n      i = a.slice(0),\n      f = new Uint32Array(i.buffer),\n      c = UPNG.quantize.getKDtree(i, r),\n      s = c[0],\n      l = c[1],\n      u = UPNG.quantize.planeDst,\n      d = a,\n      h = f,\n      A = d.length,\n      v = new Uint8Array(a.length >> 2);\n  if (a.length < 2e7) for (var p = 0; p < A; p += 4) {\n    var U = d[p] * (1 / 255),\n        g = d[p + 1] * (1 / 255),\n        m = d[p + 2] * (1 / 255),\n        w = d[p + 3] * (1 / 255);\n    t = UPNG.quantize.getNearest(s, U, g, m, w), v[p >> 2] = t.ind, h[p >> 2] = t.est.rgba;\n  } else for (p = 0; p < A; p += 4) {\n    U = d[p] * (1 / 255), g = d[p + 1] * (1 / 255), m = d[p + 2] * (1 / 255), w = d[p + 3] * (1 / 255);\n\n    for (t = s; t.left;) {\n      t = u(t.est, U, g, m, w) <= 0 ? t.left : t.right;\n    }\n\n    v[p >> 2] = t.ind, h[p >> 2] = t.est.rgba;\n  }\n  return {\n    abuf: i.buffer,\n    inds: v,\n    plte: l\n  };\n}, UPNG.quantize.getKDtree = function (e, r, t) {\n  null == t && (t = 1e-4);\n  var a = new Uint32Array(e.buffer),\n      i = {\n    i0: 0,\n    i1: e.length,\n    bst: null,\n    est: null,\n    tdst: 0,\n    left: null,\n    right: null\n  };\n  i.bst = UPNG.quantize.stats(e, i.i0, i.i1), i.est = UPNG.quantize.estats(i.bst);\n\n  for (var f = [i]; f.length < r;) {\n    for (var c = 0, s = 0, l = 0; l < f.length; l++) {\n      f[l].est.L > c && (c = f[l].est.L, s = l);\n    }\n\n    if (c < t) break;\n    var u = f[s],\n        d = UPNG.quantize.splitPixels(e, a, u.i0, u.i1, u.est.e, u.est.eMq255);\n    if (u.i0 >= d || u.i1 <= d) u.est.L = 0;else {\n      var h = {\n        i0: u.i0,\n        i1: d,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n      };\n      h.bst = UPNG.quantize.stats(e, h.i0, h.i1), h.est = UPNG.quantize.estats(h.bst);\n      var A = {\n        i0: d,\n        i1: u.i1,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n      };\n      A.bst = {\n        R: [],\n        m: [],\n        N: u.bst.N - h.bst.N\n      };\n\n      for (l = 0; l < 16; l++) {\n        A.bst.R[l] = u.bst.R[l] - h.bst.R[l];\n      }\n\n      for (l = 0; l < 4; l++) {\n        A.bst.m[l] = u.bst.m[l] - h.bst.m[l];\n      }\n\n      A.est = UPNG.quantize.estats(A.bst), u.left = h, u.right = A, f[s] = h, f.push(A);\n    }\n  }\n\n  f.sort(function (e, r) {\n    return r.bst.N - e.bst.N;\n  });\n\n  for (l = 0; l < f.length; l++) {\n    f[l].ind = l;\n  }\n\n  return [i, f];\n}, UPNG.quantize.getNearest = function (e, r, t, a, i) {\n  if (null == e.left) return e.tdst = UPNG.quantize.dist(e.est.q, r, t, a, i), e;\n  var f = UPNG.quantize.planeDst(e.est, r, t, a, i),\n      c = e.left,\n      s = e.right;\n  f > 0 && (c = e.right, s = e.left);\n  var l = UPNG.quantize.getNearest(c, r, t, a, i);\n  if (l.tdst <= f * f) return l;\n  var u = UPNG.quantize.getNearest(s, r, t, a, i);\n  return u.tdst < l.tdst ? u : l;\n}, UPNG.quantize.planeDst = function (e, r, t, a, i) {\n  var f = e.e;\n  return f[0] * r + f[1] * t + f[2] * a + f[3] * i - e.eMq;\n}, UPNG.quantize.dist = function (e, r, t, a, i) {\n  var f = r - e[0],\n      c = t - e[1],\n      s = a - e[2],\n      l = i - e[3];\n  return f * f + c * c + s * s + l * l;\n}, UPNG.quantize.splitPixels = function (e, r, t, a, i, f) {\n  var c = UPNG.quantize.vecDot;\n\n  for (a -= 4; t < a;) {\n    for (; c(e, t, i) <= f;) {\n      t += 4;\n    }\n\n    for (; c(e, a, i) > f;) {\n      a -= 4;\n    }\n\n    if (t >= a) break;\n    var s = r[t >> 2];\n    r[t >> 2] = r[a >> 2], r[a >> 2] = s, t += 4, a -= 4;\n  }\n\n  for (; c(e, t, i) > f;) {\n    t -= 4;\n  }\n\n  return t + 4;\n}, UPNG.quantize.vecDot = function (e, r, t) {\n  return e[r] * t[0] + e[r + 1] * t[1] + e[r + 2] * t[2] + e[r + 3] * t[3];\n}, UPNG.quantize.stats = function (e, r, t) {\n  for (var a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i = [0, 0, 0, 0], f = t - r >> 2, c = r; c < t; c += 4) {\n    var s = e[c] * (1 / 255),\n        l = e[c + 1] * (1 / 255),\n        u = e[c + 2] * (1 / 255),\n        d = e[c + 3] * (1 / 255);\n    i[0] += s, i[1] += l, i[2] += u, i[3] += d, a[0] += s * s, a[1] += s * l, a[2] += s * u, a[3] += s * d, a[5] += l * l, a[6] += l * u, a[7] += l * d, a[10] += u * u, a[11] += u * d, a[15] += d * d;\n  }\n\n  return a[4] = a[1], a[8] = a[2], a[9] = a[6], a[12] = a[3], a[13] = a[7], a[14] = a[11], {\n    R: a,\n    m: i,\n    N: f\n  };\n}, UPNG.quantize.estats = function (e) {\n  var r = e.R,\n      t = e.m,\n      a = e.N,\n      i = t[0],\n      f = t[1],\n      c = t[2],\n      s = t[3],\n      l = 0 == a ? 0 : 1 / a,\n      u = [r[0] - i * i * l, r[1] - i * f * l, r[2] - i * c * l, r[3] - i * s * l, r[4] - f * i * l, r[5] - f * f * l, r[6] - f * c * l, r[7] - f * s * l, r[8] - c * i * l, r[9] - c * f * l, r[10] - c * c * l, r[11] - c * s * l, r[12] - s * i * l, r[13] - s * f * l, r[14] - s * c * l, r[15] - s * s * l],\n      d = u,\n      h = UPNG.M4,\n      A = [Math.random(), Math.random(), Math.random(), Math.random()],\n      v = 0,\n      p = 0;\n  if (0 != a) for (var U = 0; U < 16 && (A = h.multVec(d, A), p = Math.sqrt(h.dot(A, A)), A = h.sml(1 / p, A), !(0 != U && Math.abs(p - v) < 1e-9)); U++) {\n    v = p;\n  }\n  var g = [i * l, f * l, c * l, s * l];\n  return {\n    Cov: u,\n    q: g,\n    e: A,\n    L: v,\n    eMq255: h.dot(h.sml(255, g), A),\n    eMq: h.dot(A, g),\n    rgba: (Math.round(255 * g[3]) << 24 | Math.round(255 * g[2]) << 16 | Math.round(255 * g[1]) << 8 | Math.round(255 * g[0]) << 0) >>> 0\n  };\n}, UPNG.M4 = {\n  multVec: function multVec(e, r) {\n    return [e[0] * r[0] + e[1] * r[1] + e[2] * r[2] + e[3] * r[3], e[4] * r[0] + e[5] * r[1] + e[6] * r[2] + e[7] * r[3], e[8] * r[0] + e[9] * r[1] + e[10] * r[2] + e[11] * r[3], e[12] * r[0] + e[13] * r[1] + e[14] * r[2] + e[15] * r[3]];\n  },\n  dot: function dot(e, r) {\n    return e[0] * r[0] + e[1] * r[1] + e[2] * r[2] + e[3] * r[3];\n  },\n  sml: function sml(e, r) {\n    return [e * r[0], e * r[1], e * r[2], e * r[3]];\n  }\n}, UPNG.encode.concatRGBA = function (e) {\n  for (var r = 0, t = 0; t < e.length; t++) {\n    r += e[t].byteLength;\n  }\n\n  var a = new Uint8Array(r),\n      i = 0;\n\n  for (t = 0; t < e.length; t++) {\n    for (var f = new Uint8Array(e[t]), c = f.length, s = 0; s < c; s += 4) {\n      var l = f[s],\n          u = f[s + 1],\n          d = f[s + 2],\n          h = f[s + 3];\n      0 == h && (l = u = d = 0), a[i + s] = l, a[i + s + 1] = u, a[i + s + 2] = d, a[i + s + 3] = h;\n    }\n\n    i += c;\n  }\n\n  return a.buffer;\n};\n\nvar isBrowser = \"undefined\" != typeof window,\n    moduleMapper = isBrowser && window.cordova && window.cordova.require && window.cordova.require(\"cordova/modulemapper\"),\n    CustomFile = isBrowser && (moduleMapper && moduleMapper.getOriginalSymbol(window, \"File\") || File),\n    CustomFileReader = isBrowser && (moduleMapper && moduleMapper.getOriginalSymbol(window, \"FileReader\") || FileReader);\n\nfunction isAutoOrientationInBrowser() {\n  return new Promise(function (e, r) {\n    var t, a, i, f;\n    return void 0 !== isAutoOrientationInBrowser.result ? e(isAutoOrientationInBrowser.result) : (\"data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==\", getFilefromDataUrl(\"data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==\", \"test.jpg\", Date.now()).then(function (c) {\n      try {\n        return drawFileInCanvas(t = c).then(function (c) {\n          try {\n            return canvasToFile(a = c[1], t.type, t.name, t.lastModified).then(function (t) {\n              try {\n                return i = t, cleanupCanvasMemory(a), drawFileInCanvas(i).then(function (t) {\n                  try {\n                    return f = t[0], isAutoOrientationInBrowser.result = 1 === f.width && 2 === f.height, e(isAutoOrientationInBrowser.result);\n                  } catch (e) {\n                    return r(e);\n                  }\n                }, r);\n              } catch (e) {\n                return r(e);\n              }\n            }, r);\n          } catch (e) {\n            return r(e);\n          }\n        }, r);\n      } catch (e) {\n        return r(e);\n      }\n    }, r));\n  });\n}\n\nfunction getDataUrlFromFile(e) {\n  return new Promise(function (r, t) {\n    var a = new CustomFileReader();\n    a.onload = function () {\n      return r(a.result);\n    }, a.onerror = function (e) {\n      return t(e);\n    }, a.readAsDataURL(e);\n  });\n}\n\nfunction getFilefromDataUrl(e, r) {\n  var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Date.now();\n  return new Promise(function (a) {\n    for (var i = e.split(\",\"), f = i[0].match(/:(.*?);/)[1], c = globalThis.atob(i[1]), s = c.length, l = new Uint8Array(s); s--;) {\n      l[s] = c.charCodeAt(s);\n    }\n\n    var u = new Blob([l], {\n      type: f\n    });\n    u.name = r, u.lastModified = t, a(u);\n  });\n}\n\nfunction loadImage(e) {\n  return new Promise(function (r, t) {\n    var a = new Image();\n    a.onload = function () {\n      return r(a);\n    }, a.onerror = function (e) {\n      return t(e);\n    }, a.src = e;\n  });\n}\n\nfunction drawImageInCanvas(e) {\n  var r = _slicedToArray(getNewCanvasAndCtx(e.width, e.height), 2),\n      t = r[0];\n\n  return r[1].drawImage(e, 0, 0, t.width, t.height), t;\n}\n\nfunction drawFileInCanvas(e) {\n  return new Promise(function (r, t) {\n    var a,\n        i,\n        f = function $Try_1_Post() {\n      try {\n        return i = drawImageInCanvas(a), r([a, i]);\n      } catch (e) {\n        return t(e);\n      }\n    },\n        c = function $Try_1_Catch(r) {\n      try {\n        return getDataUrlFromFile(e).then(function (e) {\n          try {\n            return loadImage(e).then(function (e) {\n              try {\n                return a = e, f();\n              } catch (e) {\n                return t(e);\n              }\n            }, t);\n          } catch (e) {\n            return t(e);\n          }\n        }, t);\n      } catch (e) {\n        return t(e);\n      }\n    };\n\n    try {\n      return createImageBitmap(e).then(function (e) {\n        try {\n          return a = e, f();\n        } catch (e) {\n          return c();\n        }\n      }, c);\n    } catch (e) {\n      c();\n    }\n  });\n}\n\nfunction canvasToFile(e, r, t, a) {\n  var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;\n  return new Promise(function (f, c) {\n    var s, l, u;\n    if (\"image/png\" === r) return l = e.getContext(\"2d\").getImageData(0, 0, e.width, e.height).data, u = UPNG.encode([l], e.width, e.height, 256 * i), (s = new Blob([u], {\n      type: r\n    })).name = t, s.lastModified = a, $If_4.call(this);\n    {\n      var $If_5 = function $If_5() {\n        return $If_4.call(this);\n      };\n\n      return \"function\" == typeof OffscreenCanvas && e instanceof OffscreenCanvas ? e.convertToBlob({\n        type: r,\n        quality: i\n      }).then(function (e) {\n        try {\n          return (s = e).name = t, s.lastModified = a, $If_5.call(this);\n        } catch (e) {\n          return c(e);\n        }\n      }.bind(this), c) : getFilefromDataUrl(e.toDataURL(r, i), t, a).then(function (e) {\n        try {\n          return s = e, $If_5.call(this);\n        } catch (e) {\n          return c(e);\n        }\n      }.bind(this), c);\n    }\n\n    function $If_4() {\n      return f(s);\n    }\n  });\n}\n\nfunction getExifOrientation(e) {\n  return new Promise(function (r, t) {\n    var a = new CustomFileReader();\n    a.onload = function (e) {\n      var t = new DataView(e.target.result);\n      if (65496 != t.getUint16(0, !1)) return r(-2);\n\n      for (var a = t.byteLength, i = 2; i < a;) {\n        if (t.getUint16(i + 2, !1) <= 8) return r(-1);\n        var f = t.getUint16(i, !1);\n\n        if (i += 2, 65505 == f) {\n          if (1165519206 != t.getUint32(i += 2, !1)) return r(-1);\n          var c = 18761 == t.getUint16(i += 6, !1);\n          i += t.getUint32(i + 4, c);\n          var s = t.getUint16(i, c);\n          i += 2;\n\n          for (var l = 0; l < s; l++) {\n            if (274 == t.getUint16(i + 12 * l, c)) return r(t.getUint16(i + 12 * l + 8, c));\n          }\n        } else {\n          if (65280 != (65280 & f)) break;\n          i += t.getUint16(i, !1);\n        }\n      }\n\n      return r(-1);\n    }, a.onerror = function (e) {\n      return t(e);\n    }, a.readAsArrayBuffer(e);\n  });\n}\n\nfunction handleMaxWidthOrHeight(e, r) {\n  var t,\n      a = e.width,\n      i = e.height,\n      f = r.maxWidthOrHeight,\n      c = e;\n\n  if (isFinite(f) && (a > f || i > f)) {\n    var s = _slicedToArray(getNewCanvasAndCtx(a, i), 2);\n\n    c = s[0], t = s[1], a > i ? (c.width = f, c.height = i / a * f) : (c.width = a / i * f, c.height = f), t.drawImage(e, 0, 0, c.width, c.height), cleanupCanvasMemory(e);\n  }\n\n  return c;\n}\n\nfunction followExifOrientation(e, r) {\n  var t = e.width,\n      a = e.height,\n      i = _slicedToArray(getNewCanvasAndCtx(t, a), 2),\n      f = i[0],\n      c = i[1];\n\n  switch (4 < r && r < 9 ? (f.width = a, f.height = t) : (f.width = t, f.height = a), r) {\n    case 2:\n      c.transform(-1, 0, 0, 1, t, 0);\n      break;\n\n    case 3:\n      c.transform(-1, 0, 0, -1, t, a);\n      break;\n\n    case 4:\n      c.transform(1, 0, 0, -1, 0, a);\n      break;\n\n    case 5:\n      c.transform(0, 1, 1, 0, 0, 0);\n      break;\n\n    case 6:\n      c.transform(0, 1, -1, 0, a, 0);\n      break;\n\n    case 7:\n      c.transform(0, -1, -1, 0, a, t);\n      break;\n\n    case 8:\n      c.transform(0, -1, 1, 0, 0, t);\n  }\n\n  return c.drawImage(e, 0, 0, t, a), cleanupCanvasMemory(e), f;\n}\n\nfunction getNewCanvasAndCtx(e, r) {\n  var t, a;\n\n  try {\n    if (null === (a = (t = new OffscreenCanvas(e, r)).getContext(\"2d\"))) throw new Error(\"getContext of OffscreenCanvas returns null\");\n  } catch (e) {\n    a = (t = document.createElement(\"canvas\")).getContext(\"2d\");\n  }\n\n  return t.width = e, t.height = r, [t, a];\n}\n\nfunction cleanupCanvasMemory(e) {\n  e.width = 0, e.height = 0;\n}\n\nfunction compress(e, r) {\n  var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;\n  return new Promise(function (a, i) {\n    var f, c, s, l, u, d, h, A, v, p, U, g, m, w, P, b, _, y;\n\n    function incProgress() {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;\n      f += e, r.onProgress(Math.min(f, 100));\n    }\n\n    function setProgress(e) {\n      f = Math.min(Math.max(e, f), 100), r.onProgress(f);\n    }\n\n    return f = t, c = r.maxIteration || 10, s = 1024 * r.maxSizeMB * 1024, incProgress(), drawFileInCanvas(e).then(function (t) {\n      try {\n        var f = _slicedToArray(t, 2);\n\n        return f[0], l = f[1], incProgress(), u = handleMaxWidthOrHeight(l, r), incProgress(), new Promise(function (t, a) {\n          var i;\n          if (!(i = r.exifOrientation)) return getExifOrientation(e).then(function (e) {\n            try {\n              return i = e, $If_2.call(this);\n            } catch (e) {\n              return a(e);\n            }\n          }.bind(this), a);\n\n          function $If_2() {\n            return t(i);\n          }\n\n          return $If_2.call(this);\n        }).then(function (t) {\n          try {\n            return d = t, incProgress(), isAutoOrientationInBrowser().then(function (t) {\n              try {\n                return h = t ? u : followExifOrientation(u, d), incProgress(), A = r.initialQuality || 1, v = r.fileType || e.type, canvasToFile(h, v, e.name, e.lastModified, A).then(function (r) {\n                  try {\n                    {\n                      var $Loop_3 = function $Loop_3() {\n                        if (c-- && (P > s || P > m)) {\n                          var r,\n                              t,\n                              a = _slicedToArray(getNewCanvasAndCtx(r = U ? .95 * y.width : y.width, t = U ? .95 * y.height : y.height), 2);\n\n                          return _ = a[0], a[1].drawImage(y, 0, 0, r, t), A *= .95, canvasToFile(_, v, e.name, e.lastModified, A).then(function (e) {\n                            try {\n                              return b = e, cleanupCanvasMemory(y), y = _, P = b.size, setProgress(Math.min(99, Math.floor((w - P) / (w - s) * 100))), $Loop_3;\n                            } catch (e) {\n                              return i(e);\n                            }\n                          }, i);\n                        }\n\n                        return [1];\n                      };\n\n                      var $Loop_3_exit = function $Loop_3_exit() {\n                        return cleanupCanvasMemory(y), cleanupCanvasMemory(_), cleanupCanvasMemory(u), cleanupCanvasMemory(h), cleanupCanvasMemory(l), setProgress(100), a(b);\n                      };\n\n                      if (p = r, incProgress(), U = p.size > s, g = p.size > e.size, !U && !g) return setProgress(100), a(p);\n                      var t;\n                      return m = e.size, w = p.size, P = w, y = h, (t = function (e) {\n                        for (; e;) {\n                          if (e.then) return void e.then(t, i);\n\n                          try {\n                            if (e.pop) {\n                              if (e.length) return e.pop() ? $Loop_3_exit.call(this) : e;\n                              e = $Loop_3;\n                            } else e = e.call(this);\n                          } catch (e) {\n                            return i(e);\n                          }\n                        }\n                      }.bind(this))($Loop_3);\n                    }\n                  } catch (e) {\n                    return i(e);\n                  }\n                }.bind(this), i);\n              } catch (e) {\n                return i(e);\n              }\n            }.bind(this), i);\n          } catch (e) {\n            return i(e);\n          }\n        }.bind(this), i);\n      } catch (e) {\n        return i(e);\n      }\n    }.bind(this), i);\n  });\n}\n\nisBrowser && (Number.isInteger = Number.isInteger || function (e) {\n  return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;\n});\nvar cnt = 0,\n    imageCompressionLibUrl,\n    worker;\n\nfunction createWorker(e) {\n  return \"function\" == typeof e && (e = \"(\".concat(f, \")()\")), new Worker(URL.createObjectURL(new Blob([e])));\n}\n\nfunction createSourceObject(e) {\n  return URL.createObjectURL(new Blob([e], {\n    type: \"application/javascript\"\n  }));\n}\n\nfunction stringify(e) {\n  return JSON.stringify(e, function (e, r) {\n    return \"function\" == typeof r ? \"BIC_FN:::(() => \".concat(r.toString(), \")()\") : r;\n  });\n}\n\nfunction parse(o) {\n  if (\"string\" == typeof o) return o;\n  var result = {};\n  return Object.entries(o).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    if (\"string\" == typeof value && value.startsWith(\"BIC_FN:::\")) try {\n      result[key] = eval(value.replace(/^BIC_FN:::/, \"\"));\n    } catch (e) {\n      throw console.log(key, e), e;\n    } else result[key] = parse(value);\n  }), result;\n}\n\nfunction generateLib() {\n  return createSourceObject(\"\\n    // reconstruct library\\n    function imageCompression (){return (\".concat(imageCompression, \").apply(null, arguments)}\\n\\n    imageCompression.getDataUrlFromFile = \").concat(imageCompression.getDataUrlFromFile, \"\\n    imageCompression.getFilefromDataUrl = \").concat(imageCompression.getFilefromDataUrl, \"\\n    imageCompression.loadImage = \").concat(imageCompression.loadImage, \"\\n    imageCompression.drawImageInCanvas = \").concat(imageCompression.drawImageInCanvas, \"\\n    imageCompression.drawFileInCanvas = \").concat(imageCompression.drawFileInCanvas, \"\\n    imageCompression.canvasToFile = \").concat(imageCompression.canvasToFile, \"\\n    imageCompression.getExifOrientation = \").concat(imageCompression.getExifOrientation, \"\\n    imageCompression.handleMaxWidthOrHeight = \").concat(imageCompression.handleMaxWidthOrHeight, \"\\n    imageCompression.followExifOrientation = \").concat(imageCompression.followExifOrientation, \"\\n    imageCompression.cleanupCanvasMemory = \").concat(imageCompression.cleanupCanvasMemory, \"\\n    imageCompression.isAutoOrientationInBrowser = \").concat(imageCompression.isAutoOrientationInBrowser, \"\\n\\n    // functions / objects\\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\\n    loadImage = imageCompression.loadImage\\n    drawImageInCanvas = imageCompression.drawImageInCanvas\\n    drawFileInCanvas = imageCompression.drawFileInCanvas\\n    canvasToFile = imageCompression.canvasToFile\\n    getExifOrientation = imageCompression.getExifOrientation\\n    handleMaxWidthOrHeight = imageCompression.handleMaxWidthOrHeight\\n    followExifOrientation = imageCompression.followExifOrientation\\n    cleanupCanvasMemory = imageCompression.cleanupCanvasMemory\\n    isAutoOrientationInBrowser = imageCompression.isAutoOrientationInBrowser\\n    \\n    getNewCanvasAndCtx = \").concat(getNewCanvasAndCtx, \"\\n    CustomFileReader = FileReader\\n    CustomFile = File\\n    function _slicedToArray(arr, n) { return arr }\\n    function _typeof(a) { return typeof a }\\n    function compress (){return (\").concat(compress, \").apply(null, arguments)}\\n\\n    // Libraries\\n    const parse = \").concat(parse, \"\\n    const UPNG = {}\\n    UPNG.toRGBA8 = \").concat(UPNG.toRGBA8, \"\\n    UPNG.toRGBA8.decodeImage = \").concat(UPNG.toRGBA8.decodeImage, \"\\n    UPNG.decode = \").concat(UPNG.decode, \"\\n    UPNG.decode._decompress = \").concat(UPNG.decode._decompress, \"\\n    UPNG.decode._inflate = \").concat(UPNG.decode._inflate, \"\\n    UPNG.decode._readInterlace = \").concat(UPNG.decode._readInterlace, \"\\n    UPNG.decode._getBPP = \").concat(UPNG.decode._getBPP, \" \\n    UPNG.decode._filterZero = \").concat(UPNG.decode._filterZero, \"\\n    UPNG.decode._paeth = \").concat(UPNG.decode._paeth, \"\\n    UPNG.decode._IHDR = \").concat(UPNG.decode._IHDR, \"\\n    UPNG._bin = parse(\").concat(stringify(UPNG._bin), \")\\n    UPNG._copyTile = \").concat(UPNG._copyTile, \"\\n    UPNG.encode = \").concat(UPNG.encode, \"\\n    UPNG.encodeLL = \").concat(UPNG.encodeLL, \" \\n    UPNG.encode._main = \").concat(UPNG.encode._main, \"\\n    UPNG.encode.compressPNG = \").concat(UPNG.encode.compressPNG, \" \\n    UPNG.encode.compress = \").concat(UPNG.encode.compress, \"\\n    UPNG.encode.framize = \").concat(UPNG.encode.framize, \" \\n    UPNG.encode._updateFrame = \").concat(UPNG.encode._updateFrame, \" \\n    UPNG.encode._prepareDiff = \").concat(UPNG.encode._prepareDiff, \" \\n    UPNG.encode._filterZero = \").concat(UPNG.encode._filterZero, \" \\n    UPNG.encode._filterLine = \").concat(UPNG.encode._filterLine, \"\\n    UPNG.encode.concatRGBA = \").concat(UPNG.encode.concatRGBA, \"\\n    UPNG.crc = parse(\").concat(stringify(UPNG.crc), \")\\n    UPNG.crc.table = ( function() {\\n    var tab = new Uint32Array(256);\\n    for (var n=0; n<256; n++) {\\n      var c = n;\\n      for (var k=0; k<8; k++) {\\n        if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\\n        else        c = c >>> 1;\\n      }\\n      tab[n] = c;  }\\n    return tab;  })()\\n    UPNG.quantize = \").concat(UPNG.quantize, \" \\n    UPNG.quantize.getKDtree = \").concat(UPNG.quantize.getKDtree, \" \\n    UPNG.quantize.getNearest = \").concat(UPNG.quantize.getNearest, \" \\n    UPNG.quantize.planeDst = \").concat(UPNG.quantize.planeDst, \" \\n    UPNG.quantize.dist = \").concat(UPNG.quantize.dist, \"     \\n    UPNG.quantize.splitPixels = \").concat(UPNG.quantize.splitPixels, \" \\n    UPNG.quantize.vecDot = \").concat(UPNG.quantize.vecDot, \" \\n    UPNG.quantize.stats = \").concat(UPNG.quantize.stats, \" \\n    UPNG.quantize.estats = \").concat(UPNG.quantize.estats, \"\\n    UPNG.M4 = parse(\").concat(stringify(UPNG.M4), \")\\n    UPNG.encode.concatRGBA = \").concat(UPNG.encode.concatRGBA, '\\n    UPNG.inflateRaw=function(){\\n    var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;\\n      if(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;\\n      if(Z)W=new R(N.length>>>2<<5);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);\\n        var D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;\\n        w+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;\\n        h=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;\\n                                                                                                        c<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;\\n        d=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);\\n        I(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;\\n        if(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);\\n        d+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};\\n      H.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};\\n      H.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;\\n        if(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);\\n          n+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;\\n        while(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};\\n      H.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;\\n        var b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];\\n          b[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);\\n        while(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;\\n                                                                                                 n+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};\\n      H.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};\\n      H.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};\\n      H.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;\\n        return{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();\\n      (function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;\\n        V=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;\\n        N.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];\\n        N.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);\\n        H.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);\\n        n(N.D,30,0);n(N.v,320,0)}());return H.H.N}()\\n    \\n    const UZIP = {}\\n    UZIP[\"parse\"] = ').concat(UZIP_1.parse, \"\\n    UZIP._readLocal = \").concat(UZIP_1._readLocal, \"\\n    UZIP.inflateRaw = \").concat(UZIP_1.inflateRaw, \"\\n    UZIP.inflate = \").concat(UZIP_1.inflate, \"\\n    UZIP.deflate = \").concat(UZIP_1.deflate, \"\\n    UZIP.deflateRaw = \").concat(UZIP_1.deflateRaw, \"\\n    UZIP.encode = \").concat(UZIP_1.encode, \"\\n    UZIP._noNeed = \").concat(UZIP_1._noNeed, \"\\n    UZIP._writeHeader = \").concat(UZIP_1._writeHeader, \"\\n    UZIP.crc = parse(\").concat(stringify(UZIP_1.crc), \")\\n    UZIP.crc.table = ( function() {\\n      var tab = new Uint32Array(256);\\n      for (var n=0; n<256; n++) {\\n        var c = n;\\n        for (var k=0; k<8; k++) {\\n          if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\\n          else        c = c >>> 1;\\n        }\\n        tab[n] = c;  }\\n      return tab;  })()\\n    \\n    UZIP.adler = \").concat(UZIP_1.adler, \"\\n    UZIP.bin = parse(\").concat(stringify(UZIP_1.bin), \")\\n    UZIP.F = {}\\n    UZIP.F.deflateRaw = \").concat(UZIP_1.F.deflateRaw, \"\\n    UZIP.F._bestMatch = \").concat(UZIP_1.F._bestMatch, \"\\n    UZIP.F._howLong = \").concat(UZIP_1.F._howLong, \"\\n    UZIP.F._hash = \").concat(UZIP_1.F._hash, \"\\n    UZIP.saved = \").concat(UZIP_1.saved, \"\\n    UZIP.F._writeBlock = \").concat(UZIP_1.F._writeBlock, \"\\n    UZIP.F._copyExact = \").concat(UZIP_1.F._copyExact, \"\\n    UZIP.F.getTrees = \").concat(UZIP_1.F.getTrees, \"\\n    UZIP.F.getSecond = \").concat(UZIP_1.F.getSecond, \"\\n    UZIP.F.nonZero = \").concat(UZIP_1.F.nonZero, \"\\n    UZIP.F.contSize = \").concat(UZIP_1.F.contSize, \"\\n    UZIP.F._codeTiny = \").concat(UZIP_1.F._codeTiny, \" \\n    UZIP.F._lenCodes = \").concat(UZIP_1.F._lenCodes, \" \\n    UZIP.F._hufTree = \").concat(UZIP_1.F._hufTree, \" \\n    UZIP.F.setDepth = \").concat(UZIP_1.F.setDepth, \" \\n    UZIP.F.restrictDepth = \").concat(UZIP_1.F.restrictDepth, \"\\n    UZIP.F._goodIndex = \").concat(UZIP_1.F._goodIndex, \" \\n    UZIP.F._writeLit = \").concat(UZIP_1.F._writeLit, \" \\n    UZIP.F.inflate = \").concat(UZIP_1.F.inflate, \" \\n    UZIP.F._check = \").concat(UZIP_1.F._check, \" \\n    UZIP.F._decodeTiny = \").concat(UZIP_1.F._decodeTiny, \" \\n    UZIP.F._copyOut = \").concat(UZIP_1.F._copyOut, \" \\n    UZIP.F.makeCodes = \").concat(UZIP_1.F.makeCodes, \" \\n    UZIP.F.codes2map = \").concat(UZIP_1.F.codes2map, \" \\n    UZIP.F.revCodes = \").concat(UZIP_1.F.revCodes, \" \\n\\n    // used only in deflate\\n    UZIP.F._putsE = \").concat(UZIP_1.F._putsE, \"\\n    UZIP.F._putsF = \").concat(UZIP_1.F._putsF, \"\\n  \\n    UZIP.F._bitsE = \").concat(UZIP_1.F._bitsE, \"\\n    UZIP.F._bitsF = \").concat(UZIP_1.F._bitsF, \"\\n\\n    UZIP.F._get17 = \").concat(UZIP_1.F._get17, \"\\n    UZIP.F._get25 = \").concat(UZIP_1.F._get25, \"\\n    UZIP.F.U = function(){\\n      var u16=Uint16Array, u32=Uint32Array;\\n      return {\\n        next_code : new u16(16),\\n        bl_count  : new u16(16),\\n        ordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\\n        of0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\\n        exb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\\n        ldef : new u16(32),\\n        df0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\\n        dxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\\n        ddef : new u32(32),\\n        flmap: new u16(  512),  fltree: [],\\n        fdmap: new u16(   32),  fdtree: [],\\n        lmap : new u16(32768),  ltree : [],  ttree:[],\\n        dmap : new u16(32768),  dtree : [],\\n        imap : new u16(  512),  itree : [],\\n        //rev9 : new u16(  512)\\n        rev15: new u16(1<<15),\\n        lhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\\n        lits : new u32(15000),\\n        strt : new u16(1<<16),\\n        prev : new u16(1<<15)\\n      };\\n    } ();\\n\\n    (function(){\\n      var U = UZIP.F.U;\\n      var len = 1<<15;\\n      for(var i=0; i<len; i++) {\\n        var x = i;\\n        x = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\\n        x = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\\n        x = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\\n        x = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\\n        U.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\\n      }\\n  \\n      function pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\\n  \\n      for(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\\n  \\n      pushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\\n      /*\\n        var i = 0;\\n        for(; i<=143; i++) U.fltree.push(0,8);\\n        for(; i<=255; i++) U.fltree.push(0,9);\\n        for(; i<=279; i++) U.fltree.push(0,7);\\n        for(; i<=287; i++) U.fltree.push(0,8);\\n        */\\n      UZIP.F.makeCodes(U.fltree, 9);\\n      UZIP.F.codes2map(U.fltree, 9, U.flmap);\\n      UZIP.F.revCodes (U.fltree, 9)\\n  \\n      pushV(U.fdtree,32,5);\\n      //for(i=0;i<32; i++) U.fdtree.push(0,5);\\n      UZIP.F.makeCodes(U.fdtree, 5);\\n      UZIP.F.codes2map(U.fdtree, 5, U.fdmap);\\n      UZIP.F.revCodes (U.fdtree, 5)\\n  \\n      pushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\\n      /*\\n        for(var i=0; i< 19; i++) U.itree.push(0,0);\\n        for(var i=0; i<286; i++) U.ltree.push(0,0);\\n        for(var i=0; i< 30; i++) U.dtree.push(0,0);\\n        for(var i=0; i<320; i++) U.ttree.push(0,0);\\n        */\\n    })()\\n    \"));\n}\n\nfunction generateWorkerScript() {\n  return createWorker(\"\\n    let scriptImported = false\\n    self.addEventListener('message', async (e) => {\\n      const { file, id, imageCompressionLibUrl, options } = e.data\\n      options.onProgress = (progress) => self.postMessage({ progress, id })\\n      try {\\n        if (!scriptImported) {\\n          // console.log('[worker] importScripts', imageCompressionLibUrl)\\n          self.importScripts(imageCompressionLibUrl)\\n          scriptImported = true\\n        }\\n        // console.log('[worker] self', self)\\n        const compressedFile = await imageCompression(file, options)\\n        self.postMessage({ file: compressedFile, id })\\n      } catch (e) {\\n        // console.error('[worker] error', e)\\n        self.postMessage({ error: e.message + '\\\\n' + e.stack, id })\\n      }\\n    })\\n  \");\n}\n\nfunction compressOnWebWorker(e, r) {\n  return new Promise(function (t, a) {\n    return new Promise(function (i, f) {\n      var c = cnt++;\n      return imageCompressionLibUrl || (imageCompressionLibUrl = generateLib()), worker || (worker = generateWorkerScript()), worker.addEventListener(\"message\", function handler(e) {\n        if (e.data.id === c) {\n          if (void 0 !== e.data.progress) return void r.onProgress(e.data.progress);\n          worker.removeEventListener(\"message\", handler), e.data.error && a(new Error(e.data.error)), t(e.data.file);\n        }\n      }), worker.addEventListener(\"error\", a), worker.postMessage({\n        file: e,\n        id: c,\n        imageCompressionLibUrl: imageCompressionLibUrl,\n        options: _objectSpread2(_objectSpread2({}, r), {}, {\n          onProgress: void 0\n        })\n      }), i();\n    });\n  });\n}\n\nfunction imageCompression(e, r) {\n  return new Promise(function (t, a) {\n    var i, f, c, s, l;\n    if (f = 0, r.maxSizeMB = r.maxSizeMB || Number.POSITIVE_INFINITY, s = \"boolean\" != typeof r.useWebWorker || r.useWebWorker, delete r.useWebWorker, c = r.onProgress, r.onProgress = function (e) {\n      f = e, \"function\" == typeof c && c(f);\n    }, !(e instanceof Blob || e instanceof CustomFile)) return a(new Error(\"The file given is not an instance of Blob or File\"));\n    if (!/^image/.test(e.type)) return a(new Error(\"The file given is not an image\"));\n    if (l = \"undefined\" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope, !s || \"function\" != typeof Worker || l) return compress(e, r).then(function (e) {\n      try {\n        return i = e, $If_3.call(this);\n      } catch (e) {\n        return a(e);\n      }\n    }.bind(this), a);\n\n    var u = function () {\n      try {\n        return $If_3.call(this);\n      } catch (e) {\n        return a(e);\n      }\n    }.bind(this),\n        d = function $Try_1_Catch(t) {\n      try {\n        return compress(e, r).then(function (e) {\n          try {\n            return i = e, u();\n          } catch (e) {\n            return a(e);\n          }\n        }, a);\n      } catch (e) {\n        return a(e);\n      }\n    };\n\n    try {\n      return compressOnWebWorker(e, r).then(function (e) {\n        try {\n          return i = e, u();\n        } catch (e) {\n          return d();\n        }\n      }, d);\n    } catch (e) {\n      d();\n    }\n\n    function $If_3() {\n      try {\n        i.name = e.name, i.lastModified = e.lastModified;\n      } catch (e) {}\n\n      return t(i);\n    }\n  });\n}\n\nimageCompression.getDataUrlFromFile = getDataUrlFromFile, imageCompression.getFilefromDataUrl = getFilefromDataUrl, imageCompression.loadImage = loadImage, imageCompression.drawImageInCanvas = drawImageInCanvas, imageCompression.drawFileInCanvas = drawFileInCanvas, imageCompression.canvasToFile = canvasToFile, imageCompression.getExifOrientation = getExifOrientation, imageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight, imageCompression.followExifOrientation = followExifOrientation, imageCompression.cleanupCanvasMemory = cleanupCanvasMemory, imageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser, imageCompression.version = \"1.0.14\";\nexport default imageCompression;","map":null,"metadata":{},"sourceType":"module"}